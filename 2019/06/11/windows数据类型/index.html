<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">


















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Windows数据类型详解Windows字符和字符串处理友情提示：为了方便你更好的学习和阅读，也更好的体现尊重原创作者的劳动成果，请您直接查看转载原本链接： http://blog.csdn.net/ithomer/article/details/5019367VC++常用数据类型及其操作详解 一.VC常用数据类型列表二.常用数据类型转化2.1数学类型变量与字符串相互转换2.2 CString及s">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows数据类型解析">
<meta property="og:url" content="http://yoursite.com/2019/06/11/windows数据类型/index.html">
<meta property="og:site_name" content="Create-Blog">
<meta property="og:description" content="Windows数据类型详解Windows字符和字符串处理友情提示：为了方便你更好的学习和阅读，也更好的体现尊重原创作者的劳动成果，请您直接查看转载原本链接： http://blog.csdn.net/ithomer/article/details/5019367VC++常用数据类型及其操作详解 一.VC常用数据类型列表二.常用数据类型转化2.1数学类型变量与字符串相互转换2.2 CString及s">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-11T06:57:03.286Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Windows数据类型解析">
<meta name="twitter:description" content="Windows数据类型详解Windows字符和字符串处理友情提示：为了方便你更好的学习和阅读，也更好的体现尊重原创作者的劳动成果，请您直接查看转载原本链接： http://blog.csdn.net/ithomer/article/details/5019367VC++常用数据类型及其操作详解 一.VC常用数据类型列表二.常用数据类型转化2.1数学类型变量与字符串相互转换2.2 CString及s">



  <link rel="alternate" href="/atom.xml" title="Create-Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/11/windows数据类型/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Windows数据类型解析 | Create-Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Create-Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">GitHub + Git + Hexo 搭建博客思考，记录，构造，分享</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-history"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-list"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tools">

    
    
    
      
    

    

    <a href="/categories/工具资源/" rel="section"><i class="menu-item-icon fa fa-fw fa-briefcase"></i> <br>tools</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/windows数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JoAiden Lee">
      <meta itemprop="description" content="学海无涯，不一定非要苦作舟">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Create-Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Windows数据类型解析

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-06-11 13:32:14 / Modified: 14:57:03" itemprop="dateCreated datePublished" datetime="2019-06-11T13:32:14+08:00">2019-06-11</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
		
	<div>
		
			<div>
    
        <div style="text-align:center;color: #636363;font-size:14px;letter-spacing: 10px">本文结束啦<i class="fa fa-bell"></i>感谢您的阅读</div>
    
</div>

		
		}
	</div>
      
      

      
        <h1 id="Windows数据类型详解"><a href="#Windows数据类型详解" class="headerlink" title="Windows数据类型详解"></a>Windows数据类型详解</h1><p>Windows字符和字符串处理<br>友情提示：<br>为了方便你更好的学习和阅读，也更好的体现尊重原创作者的劳动成果，请您直接查看转载原本链接：</p>
<h1 id="http-blog-csdn-net-ithomer-article-details-5019367"><a href="#http-blog-csdn-net-ithomer-article-details-5019367" class="headerlink" title="http://blog.csdn.net/ithomer/article/details/5019367"></a><a href="http://blog.csdn.net/ithomer/article/details/5019367" target="_blank" rel="noopener">http://blog.csdn.net/ithomer/article/details/5019367</a></h1><p>VC++常用数据类型及其操作详解</p>
<p>一.VC常用数据类型列表<br>二.常用数据类型转化<br>2.1数学类型变量与字符串相互转换<br>2.2 CString及string,char <em>与其他数据类型的转换和操作<br>●CString,string,char</em>的综合比较<br>●数学类型与CString相互转化<br>●CString与char*相互转换举例<br>●CString 与 BSTR 型转换<br>●VARIANT 型转化成 CString 型<br>2.3 BSTR、_bstr_t与CComBSTR<br>2.4 VARIANT 、_variant_t 与 COleVariant<br>附录CString及字符串转及操作详解</p>
<p>参考书籍:CSDN,&lt;&lt;MFC深入浅出(Second Edit)&gt;&gt;</p>
<pre><code>一．VC常用数据类型列表
</code></pre><table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:center">Default Size</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td style="text-align:center">unsigned 8 bit</td>
<td style="text-align:center">取值TRUE/FALSE</td>
</tr>
<tr>
<td>byte</td>
<td style="text-align:center">unsigned 8 bit</td>
<td style="text-align:center">整数,输出按字符输出</td>
</tr>
<tr>
<td>char</td>
<td style="text-align:center">unsigned 8 bit</td>
<td style="text-align:center">字符</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">signed 64 bit</td>
<td style="text-align:center">浮点型</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">signed32 bit</td>
<td style="text-align:center">浮点型</td>
</tr>
<tr>
<td>hyper</td>
<td style="text-align:center">signed 64 bit</td>
<td style="text-align:center">整型 </td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">signed 32 bit</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">signed 32 bit</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">signed 16 bit</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>small</td>
<td style="text-align:center">signed 8 bit</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>void *</td>
<td style="text-align:center">32-bit</td>
<td style="text-align:center">指向未知类型的指针</td>
</tr>
<tr>
<td>wchar_t</td>
<td style="text-align:center">unsigned 16 bit</td>
<td style="text-align:center">16位字符,比char可容纳更多的字符</td>
</tr>
</tbody>
</table>
<p>Win32 API常用数据类型 全大写</p>
<table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:center">Default Size</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BOOL\BOOLEAN</td>
<td style="text-align:center">8bit,TRUE/FALSE</td>
<td style="text-align:center">布尔型</td>
</tr>
<tr>
<td>BYTE</td>
<td style="text-align:center">unsigned 8 bit</td>
</tr>
<tr>
<td>BSTR_bstr_t</td>
<td style="text-align:center">32 bit</td>
<td style="text-align:center">BSTR是指向字符串的32位指针 是对BSTR的封装 是对BSTR的封装</td>
</tr>
<tr>
<td>CHAR</td>
<td style="text-align:center">8 bit</td>
<td style="text-align:center">(ANSI）字符类型</td>
</tr>
<tr>
<td>COLORREF</td>
<td style="text-align:center">32 bit</td>
<td style="text-align:center">RGB颜色值 整型</td>
</tr>
<tr>
<td>DWORD</td>
<td style="text-align:center">unsigned 32 bit</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>FLOAT</td>
<td style="text-align:center">float型</td>
<td style="text-align:center">float型</td>
</tr>
<tr>
<td>HANDLE</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">Object句柄</td>
</tr>
<tr>
<td>HBITMAP</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">bitmap句柄</td>
</tr>
<tr>
<td>HBRUSH</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">brush句柄</td>
</tr>
<tr>
<td>HCURSOR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">cursor句柄</td>
</tr>
<tr>
<td>HDC</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">设备上下文句柄</td>
</tr>
<tr>
<td>HFILE</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">OpenFile打开的File句柄</td>
</tr>
<tr>
<td>HFONT</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">font句柄</td>
</tr>
<tr>
<td>HHOOK</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">hook句柄</td>
</tr>
<tr>
<td>HKEY</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">注册表键句柄</td>
</tr>
<tr>
<td>HPEN</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">pen句柄</td>
</tr>
<tr>
<td>HWND</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">window句柄</td>
</tr>
<tr>
<td>INT</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">——–</td>
</tr>
<tr>
<td>LONG</td>
<td style="text-align:center">——–</td>
<td style="text-align:center">———</td>
</tr>
<tr>
<td>LONGLONG</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">64位带符号整型</td>
</tr>
<tr>
<td>LPARAM</td>
<td style="text-align:center">32 bit</td>
<td style="text-align:center">消息参数</td>
</tr>
<tr>
<td>LPBOOL</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">BOOL型指针</td>
</tr>
<tr>
<td>LPBYTE</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">BYTE型指针</td>
</tr>
<tr>
<td>LPCOLOREF</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">COLORREF型指针</td>
</tr>
<tr>
<td>LPCSTR/LPSTR/PCSTR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向8位（ANSI）字符串类型指针</td>
</tr>
<tr>
<td>LPCWSTR/LPWSTR/PCWSTR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向16位Unicode字符串类型</td>
</tr>
<tr>
<td>LPCTSTR/LPTSTR/PCTSTR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向一8位或16位字符串类型指针</td>
</tr>
<tr>
<td>LPVOID</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向一个未指定类型的32位指针</td>
</tr>
<tr>
<td>LPDWORD</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向一个DWORD型指针</td>
</tr>
<tr>
<td>SHORT</td>
<td style="text-align:center">usigned</td>
<td style="text-align:center">整型</td>
</tr>
<tr>
<td>其他相似类型: LPHANDLE、LPINT、LPLONG、LPWORD、LPRESULTPBOOL、PBOOLEAN、PBYTE、PCHAR、PDWORD、PFLOAT、PHANDLE、PINT、PLONG、PSHORT……</td>
<td style="text-align:center">(1)在16位系统中 LP为16bit,P为8bit,在32位系统中都是32bit(此时等价)(2)LPCSTR等 中的C指Const,T表示TCHAR模式即可以工作在ANSI下也可UNICODE</td>
<td style="text-align:center">其他UCHAR、UINT、ULONG、ULONGLONG、USHORT为无符号相应类型</td>
</tr>
<tr>
<td>TBYTE</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">WCHAR型或者CHAR型</td>
</tr>
<tr>
<td>TCHAR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">ANSI与unicode均可</td>
</tr>
<tr>
<td>VARIANT_variant_t\COleVariant</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">一个结构体参考OAIDL.H_variant_t是VARIANT的封装类\COleVariant也是VARIANT的封装类</td>
</tr>
<tr>
<td>WNDPROC</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向一个窗口过程的32位指针</td>
</tr>
<tr>
<td>WCHAR</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">16位Unicode字符型</td>
</tr>
<tr>
<td>WORD</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">16位无符号整型</td>
</tr>
<tr>
<td>WPARAM</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">消息参数</td>
</tr>
<tr>
<td>MFC独有类型</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">下面两个数据类型是微软基础类库中独有的数据类型</td>
</tr>
<tr>
<td>POSITION</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">标记集合中一个元素的位置的值,被MFC中的集合类所使用</td>
</tr>
<tr>
<td>LPCRECT</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">指向一个RECT结构体常量（不能修改）的32位指针</td>
</tr>
<tr>
<td>CString</td>
<td style="text-align:center">——-</td>
<td style="text-align:center">其实是MFC中的一个类</td>
</tr>
</tbody>
</table>
<p>说明:<br>(1)——-表示省略<br>(2)1Byte=8Bit,<br>字与机器有关,在8位系统中:字=1字节,16位系统中,1字=2字节，32位中:1字=4字节,<br>64位中1字=8字节.不要搞混这些概念.</p>
<p>二．常用数据类型转化及操作<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br></pre></td><td class="code"><pre><span class="line">2．1 数学类型变量与字符串相互转换(这些函数都在STDLIB.H里)</span><br><span class="line">（1）将数学类型转换为字符串可以用以下一些函数:</span><br><span class="line">举例: _CRTIMP char * __cdecl _itoa(int, char *, int);//这是一个将数字转换为一个字符串类型的函数,最后一个int表示转换的进制</span><br><span class="line">如以下程序:</span><br><span class="line">int iTyep=3;</span><br><span class="line">char *szChar;</span><br><span class="line">itoa(iType,szChar,2);</span><br><span class="line">cout&lt;&lt;szChar;//输出为1010</span><br><span class="line">类似函数列表:</span><br><span class="line">_CRTIMP char * __cdecl _itoa(int, char *, int);//为了完整性,也列在其中</span><br><span class="line">_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);</span><br><span class="line">_CRTIMP char * __cdecl _ltoa(long, char *, int);</span><br><span class="line">_CRTIMP char * __cdecl _i64toa(__int64, char *, int);</span><br><span class="line">_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);</span><br><span class="line">_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);</span><br><span class="line">_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);</span><br><span class="line">_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);//转换为长字符串类型</span><br><span class="line">_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);</span><br><span class="line">_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);</span><br><span class="line">还有很多,请自行研究</span><br><span class="line"> </span><br><span class="line">（2）将字符串类型转换为数学类型变量可以用以下一些函数:</span><br><span class="line">举例: _CRTIMP int  __cdecl atoi(const char *);//参数一看就很明了</span><br><span class="line">char *szChar=”88”;</span><br><span class="line">int temp(0);</span><br><span class="line">temp=atoi(szChar);</span><br><span class="line">cout&lt;&lt;temp;</span><br><span class="line">类似的函数列表:</span><br><span class="line">_CRTIMP int    __cdecl atoi(const char *);</span><br><span class="line">_CRTIMP double __cdecl atof(const char *);</span><br><span class="line">_CRTIMP long   __cdecl atol(const char *);</span><br><span class="line">_CRTIMP long double __cdecl _atold(const char *);</span><br><span class="line">_CRTIMP __int64 __cdecl _atoi64(const char *);</span><br><span class="line">_CRTIMP double __cdecl strtod(const char *, char **);//</span><br><span class="line">_CRTIMP long   __cdecl strtol(const char *, char **, int);//</span><br><span class="line">_CRTIMP long double __cdecl _strtold(const char *, char **);</span><br><span class="line">_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);</span><br><span class="line">_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);//长字符串类型转换为数学类型</span><br><span class="line">_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);</span><br><span class="line">_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);</span><br><span class="line">_CRTIMP int __cdecl _wtoi(const wchar_t *);</span><br><span class="line">_CRTIMP long __cdecl _wtol(const wchar_t *);</span><br><span class="line">_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);</span><br><span class="line">还有很多,请自行研究</span><br><span class="line"> </span><br><span class="line">2．2．CString及string,char *与其他数据类型的转换和操作</span><br><span class="line">（1）CString,string,char*的综合比较（这部分CSDN上的作者joise的文章</span><br><span class="line">&lt;&lt; CString,string,char*的综合比较&gt;&gt;写的很详细,请大家在仔细阅读他的文章.</span><br><span class="line">地址: http://blog.csdn.net/joise/</span><br><span class="line">或参考附录:</span><br><span class="line"> </span><br><span class="line"> (2)转换:</span><br><span class="line">●数学类型与CString相互转化</span><br><span class="line"> 数学类型转化为CString</span><br><span class="line">可用Format函数,举例:</span><br><span class="line">CString s;</span><br><span class="line">int i = 64;</span><br><span class="line">s.Format(&quot;%d&quot;, i)</span><br><span class="line">CString转换为数学类型:举例CString strValue(&quot;1.234&quot;);</span><br><span class="line">double dblValue;</span><br><span class="line">dblValue = atof((LPCTSTR)strValue);</span><br><span class="line">●CString与char*相互转换举例</span><br><span class="line">CString strValue(“Hello”);</span><br><span class="line">char *szValue;</span><br><span class="line">szValue=strValue.GetBuffer(szValue);</span><br><span class="line">也可用(LPSTR)(LPCTSTR)对CString //  进行强制转换.  </span><br><span class="line">szValue=(LPSTR)(LPCTSTR)strValue;</span><br><span class="line">反过来可直接赋值:</span><br><span class="line">char *szChar=NULL;</span><br><span class="line">CString strValue;</span><br><span class="line">szChar=new char[10];</span><br><span class="line">memset(szChar,0,10);</span><br><span class="line">strcpy(szChar,”Hello”);</span><br><span class="line">strValue=szChar;</span><br><span class="line">●CString 与 BSTR 型转换</span><br><span class="line">CString 型转化成 BSTR 型</span><br><span class="line">当我们使用 ActiveX 控件编程时，经常需要用到将某个值表示成 BSTR 类型.BSTR 是一种记数字符串，Intel平台上的宽字符串（Unicode），并且可以包含嵌入的 NULL 字符。</span><br><span class="line">可以调用 CString 对象的 AllocSysString 方法将 CString 转化成 BSTR：</span><br><span class="line">CString str;</span><br><span class="line">str = .....; // whatever</span><br><span class="line">BSTR bStr = str.AllocSysString();</span><br><span class="line"> </span><br><span class="line">BSTR型转换为CString</span><br><span class="line">如果你在 UNICODE 模式下编译代码，你可以简单地写成：</span><br><span class="line">CString convert(BSTR bStr)</span><br><span class="line">&#123;</span><br><span class="line">    if(bStr == NULL)</span><br><span class="line">        return CString(_T(&quot;&quot;));</span><br><span class="line">    CString s(bStr); // in UNICODE mode</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">如果是 ANSI 模式</span><br><span class="line">CString convert(BSTR b)</span><br><span class="line">&#123;</span><br><span class="line">    CString s;</span><br><span class="line">    if(b == NULL)</span><br><span class="line">       return s; // empty for NULL BSTR</span><br><span class="line">#ifdef UNICODE</span><br><span class="line">    s = b;</span><br><span class="line">#else</span><br><span class="line">    LPSTR p = s.GetBuffer(SysStringLen(b) + 1);</span><br><span class="line">    ::WideCharToMultiByte(CP_ACP,            // ANSI Code Page</span><br><span class="line">                          0,                 // no flags</span><br><span class="line">                          b,                 // source widechar string</span><br><span class="line">                          -1,                // assume NUL-terminated</span><br><span class="line">                          p,                 // target buffer</span><br><span class="line">                          SysStringLen(b)+1, // target buffer length</span><br><span class="line">                          NULL,              // use system default char</span><br><span class="line">                          NULL);             // don&apos;&apos;t care if default used</span><br><span class="line">    s.ReleaseBuffer();</span><br><span class="line">#endif</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">●VARIANT 型转化成 CString 型</span><br><span class="line">VARIANT 类型经常用来给 COM 对象传递参数，或者接收从 COM 对象返回的值。你也能自己编写返回 VARIANT 类型的方法，函数返回什么类型 依赖可能（并且常常）方法的输入参数（比如，在自动化操作中，依赖与你调用哪个方法。IDispatch::Invoke 可能返回（通过其一个参数）一个 包含有BYTE、WORD、float、double、date、BSTR 等等 VARIANT 类型的结果，（详见 MSDN 上的 VARIANT 结构的定义）。在下面的例子中，假设 类型是一个BSTR的变体，也就是说在串中的值是通过 bsrtVal 来引用，其优点是在 ANSI 应用中，有一个构造函数会把 LPCWCHAR 引用的值转换为一个 CString（见 BSTR-to-CString 部分）。在 Unicode 模式中，将成为标准的 CString 构造函数，参见对缺省::WideCharToMultiByte 转换的告诫，以及你觉得是否可以接受（大多数情况下，你会满意的）。VARIANT vaData;</span><br><span class="line">vaData = m_com.YourMethodHere();</span><br><span class="line">ASSERT(vaData.vt == VT_BSTR);</span><br><span class="line">CString strData(vaData.bstrVal);</span><br><span class="line">你还可以根据 vt 域的不同来建立更通用的转换例程。为此你可能会考虑：</span><br><span class="line">CString VariantToString(VARIANT * va)</span><br><span class="line">&#123;</span><br><span class="line">    CString s;</span><br><span class="line">    switch(va-&gt;vt)</span><br><span class="line">      &#123; /* vt */</span><br><span class="line">       case VT_BSTR:</span><br><span class="line">          return CString(vaData-&gt;bstrVal);</span><br><span class="line">       case VT_BSTR | VT_BYREF:</span><br><span class="line">          return CString(*vaData-&gt;pbstrVal);</span><br><span class="line">       case VT_I4:</span><br><span class="line">          s.Format(_T(&quot;%d&quot;), va-&gt;lVal);</span><br><span class="line">          return s;</span><br><span class="line">       case VT_I4 | VT_BYREF:</span><br><span class="line">          s.Format(_T(&quot;%d&quot;), *va-&gt;plVal);</span><br><span class="line">       case VT_R8:</span><br><span class="line">          s.Format(_T(&quot;%f&quot;), va-&gt;dblVal);</span><br><span class="line">          return s;</span><br><span class="line">       ... 剩下的类型转换由读者自己完成</span><br><span class="line">       default:</span><br><span class="line">          ASSERT(FALSE); // unknown VARIANT type (this ASSERT is optional)</span><br><span class="line">          return CString(&quot;&quot;);</span><br><span class="line">      &#125; /* vt */</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">2．3 BSTR、_bstr_t与CComBSTR</span><br><span class="line">CComBSTR、_bstr_t是对BSTR的封装,BSTR是指向字符串的32位指针。</span><br><span class="line">char *转换到BSTR可以这样:</span><br><span class="line">BSTR b=_com_util::ConvertStringToBSTR(&quot;数据&quot;);///使用前需要加上头文件comutil.h</span><br><span class="line">反之可以使用char *p=_com_util::ConvertBSTRToString(b);</span><br><span class="line"> </span><br><span class="line">2．4(引)VARIANT 、_variant_t 与 COleVariant</span><br><span class="line">VARIANT的结构可以参考头文件VC98/Include/OAIDL.H中关于结构体tagVARIANT的定义。</span><br><span class="line">对于VARIANT变量的赋值：首先给vt成员赋值，指明数据类型，再对联合结构中相同数据类型的变量赋值，举个例子：</span><br><span class="line">VARIANT va;</span><br><span class="line">int a=2001;</span><br><span class="line">va.vt=VT_I4;///指明整型数据</span><br><span class="line">va.lVal=a; ///赋值</span><br><span class="line">对于不马上赋值的VARIANT，最好先用Void VariantInit(VARIANTARG FAR* pvarg);进行初始化,其本质是将vt设置为VT_EMPTY,下表我们列举vt与常用数据的对应关系:</span><br><span class="line">unsigned char bVal; VT_UI1</span><br><span class="line">short iVal; VT_I2</span><br><span class="line">long lVal; VT_I4</span><br><span class="line">float fltVal; VT_R4</span><br><span class="line">double dblVal; VT_R8</span><br><span class="line">VARIANT_BOOL boolVal; VT_BOOL</span><br><span class="line">SCODE scode; VT_ERROR</span><br><span class="line">CY cyVal; VT_CY</span><br><span class="line">DATE date; VT_DATE</span><br><span class="line">BSTR bstrVal; VT_BSTR</span><br><span class="line">IUnknown FAR* punkVal; VT_UNKNOWN</span><br><span class="line">IDispatch FAR* pdispVal; VT_DISPATCH</span><br><span class="line">SAFEARRAY FAR* parray; VT_ARRAY|*</span><br><span class="line">unsigned char FAR* pbVal; VT_BYREF|VT_UI1</span><br><span class="line">short FAR* piVal; VT_BYREF|VT_I2</span><br><span class="line">long FAR* plVal; VT_BYREF|VT_I4</span><br><span class="line">float FAR* pfltVal; VT_BYREF|VT_R4</span><br><span class="line">double FAR* pdblVal; VT_BYREF|VT_R8</span><br><span class="line">VARIANT_BOOL FAR* pboolVal; VT_BYREF|VT_BOOL</span><br><span class="line">SCODE FAR* pscode; VT_BYREF|VT_ERROR</span><br><span class="line">CY FAR* pcyVal; VT_BYREF|VT_CY</span><br><span class="line">DATE FAR* pdate; VT_BYREF|VT_DATE</span><br><span class="line">BSTR FAR* pbstrVal; VT_BYREF|VT_BSTR</span><br><span class="line">IUnknown FAR* FAR* ppunkVal; VT_BYREF|VT_UNKNOWN</span><br><span class="line">IDispatch FAR* FAR* ppdispVal; VT_BYREF|VT_DISPATCH</span><br><span class="line">SAFEARRAY FAR* FAR* pparray; VT_ARRAY|*</span><br><span class="line">VARIANT FAR* pvarVal; VT_BYREF|VT_VARIANT</span><br><span class="line">void FAR* byref; VT_BYREF</span><br><span class="line">_variant_t是VARIANT的封装类，其赋值可以使用强制类型转换，其构造函数会自动处理这些数据类型。</span><br><span class="line">例如：</span><br><span class="line">long l=222;</span><br><span class="line">ing i=100;</span><br><span class="line">_variant_t lVal(l);</span><br><span class="line">lVal = (long)i;</span><br><span class="line">COleVariant的使用与_variant_t的方法基本一样，请参考如下例子：</span><br><span class="line">COleVariant v3 = &quot;字符串&quot;, v4 = (long)1999;</span><br><span class="line">CString str =(BSTR)v3.pbstrVal;</span><br><span class="line">long i = v4.lVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　一、BSTR、LPSTR和LPWSTR </span><br><span class="line"></span><br><span class="line">　　在Visual C++.NET的所有编程方式中，我们常常要用到这样的一些基本字符串类型，如BSTR、LPSTR和LPWSTR等。之所以出现类似上述的这些数据类型，是因为不同编程语言之间的数据交换以及对ANSI、Unicode和多字节字符集(MBCS)的支持。 </span><br><span class="line"></span><br><span class="line">　　那么什么是BSTR、LPSTR以及LPWSTR呢？ </span><br><span class="line"></span><br><span class="line">　　BSTR(Basic STRing，Basic字符串)是一个OLECHAR*类型的Unicode字符串。它被描述成一个与自动化相兼容的类型。由于操作系统提供相应的 API函数(如SysAllocString)来管理它以及一些默认的调度代码，因此BSTR实际上就是一个COM字符串，但它却在自动化技术以外的多种场合下得到广泛使用。图1描述了BSTR的结构，其中DWORD值是字符串中实际所占用的字节数，且它的值是字符串中Unicode字符的两倍。 </span><br><span class="line"></span><br><span class="line">　　LPSTR和LPWSTR是Win32和VC++所使用的一种字符串数据类型。LPSTR被定义成是一个指向以NULL(‘/0’)结尾的8位ANSI 字符数组指针，而LPWSTR是一个指向以NULL结尾的16位双字节字符数组指针。在VC++中，还有类似的字符串类型，如LPTSTR、 LPCTSTR等，它们的含义如图2所示。 </span><br><span class="line"></span><br><span class="line">　　例如，LPCTSTR是指“long pointer to a constant generic string”，表示“一个指向一般字符串常量的长指针类型”，与C/C++的const char*相映射，而LPTSTR映射为 char*。 </span><br><span class="line"></span><br><span class="line">　　一般地，还有下列类型定义： </span><br><span class="line"></span><br><span class="line">#ifdef UNICODE </span><br><span class="line">　typedef LPWSTR LPTSTR; </span><br><span class="line">　typedef LPCWSTR LPCTSTR; </span><br><span class="line">#else </span><br><span class="line">　typedef LPSTR LPTSTR; </span><br><span class="line">　typedef LPCSTR LPCTSTR; </span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">　　二、CString、CStringA 和 CStringW </span><br><span class="line"></span><br><span class="line">　　Visual C++.NET中将CStringT作为ATL和MFC的共享的“一般”字符串类，它有CString、CStringA和CStringW三种形式，分别操作不同字符类型的字符串。这些字符类型是TCHAR、char和wchar_t。TCHAR在Unicode平台中等同于WCHAR(16位 Unicode字符)，在ANSI中等价于char。wchar_t通常定义为unsigned short。由于CString在MFC应用程序中经常用到，这里不再重复。 </span><br><span class="line"></span><br><span class="line">　　三、VARIANT、COleVariant 和_variant_t </span><br><span class="line"></span><br><span class="line">　　在OLE、ActiveX和COM中，VARIANT数据类型提供了一种非常有效的机制，由于它既包含了数据本身，也包含了数据的类型，因而它可以实现各种不同的自动化数据的传输。下面让我们来看看OAIDL.H文件中VARIANT定义的一个简化版： </span><br><span class="line"></span><br><span class="line">struct tagVARIANT &#123; </span><br><span class="line">　VARTYPE vt; </span><br><span class="line">　union &#123; </span><br><span class="line">　　short iVal;   // VT_I2. </span><br><span class="line">　　long lVal;    // VT_I4. </span><br><span class="line">　　float fltVal;  // VT_R4. </span><br><span class="line">　　double dblVal; // VT_R8. </span><br><span class="line">　　DATE date;     // VT_DATE. </span><br><span class="line">　　BSTR bstrVal; // VT_BSTR. </span><br><span class="line">　　… </span><br><span class="line">　　short * piVal;  // VT_BYREF|VT_I2. </span><br><span class="line">　　long * plVal;   // VT_BYREF|VT_I4. </span><br><span class="line">　　float * pfltVal; // VT_BYREF|VT_R4. </span><br><span class="line">　　double * pdblVal; // VT_BYREF|VT_R8. </span><br><span class="line">　　DATE * pdate;     // VT_BYREF|VT_DATE. </span><br><span class="line">　　BSTR * pbstrVal; // VT_BYREF|VT_BSTR. </span><br><span class="line">　&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">　　显然，VARIANT类型是一个C结构，它包含了一个类型成员vt、一些保留字节以及一个大的union类型。例如，如果vt为VT_I2，那么我们可以从iVal中读出VARIANT的值。同样，当给一个VARIANT变量赋值时，也要先指明其类型。例如： </span><br><span class="line"></span><br><span class="line">VARIANT va; </span><br><span class="line">:: VariantInit(&amp;va); // 初始化 </span><br><span class="line">int a = 2002; </span><br><span class="line">va.vt = VT_I4; // 指明long数据类型 </span><br><span class="line">va.lVal = a; // 赋值 </span><br><span class="line"></span><br><span class="line">　　为了方便处理VARIANT类型的变量，Windows还提供了这样一些非常有用的函数： </span><br><span class="line"></span><br><span class="line">　　VariantInit —— 将变量初始化为VT_EMPTY； </span><br><span class="line"></span><br><span class="line">　　VariantClear —— 消除并初始化VARIANT； </span><br><span class="line"></span><br><span class="line">　　VariantChangeType —— 改变VARIANT的类型； </span><br><span class="line"></span><br><span class="line">　　VariantCopy —— 释放与目标VARIANT相连的内存并复制源VARIANT。 </span><br><span class="line"></span><br><span class="line">　　COleVariant类是对VARIANT结构的封装。它的构造函数具有极为强大大的功能，当对象构造时首先调用VariantInit进行初始化，然后根据参数中的标准类型调用相应的构造函数，并使用VariantCopy进行转换赋值操作，当VARIANT对象不在有效范围时，它的析构函数就会被自动调用，由于析构函数调用了VariantClear，因而相应的内存就会被自动清除。除此之外，COleVariant的赋值操作符在与VARIANT类型转换中为我们提供极大的方便。例如下面的代码： </span><br><span class="line"></span><br><span class="line">COleVariant v1(&quot;This is a test&quot;); // 直接构造 </span><br><span class="line">COleVariant v2 = &quot;This is a test&quot;; </span><br><span class="line">// 结果是VT_BSTR类型，值为&quot;This is a test&quot; </span><br><span class="line">COleVariant v3((long)2002); </span><br><span class="line">COleVariant v4 = (long)2002; </span><br><span class="line">// 结果是VT_I4类型，值为2002 </span><br><span class="line"></span><br><span class="line">　　_variant_t是一个用于COM的VARIANT类，它的功能与COleVariant相似。不过在Visual C++.NET的MFC应用程序中使用时需要在代码文件前面添加下列两句： </span><br><span class="line"></span><br><span class="line">　　#include &quot;comutil.h&quot; </span><br><span class="line"></span><br><span class="line">　　#pragma comment( lib, &quot;comsupp.lib&quot; )</span><br><span class="line"></span><br><span class="line">    四、CComBSTR和_bstr_t </span><br><span class="line"></span><br><span class="line">　　CComBSTR是对BSTR数据类型封装的一个ATL类，它的操作比较方便。例如： </span><br><span class="line"></span><br><span class="line">CComBSTR bstr1; </span><br><span class="line">bstr1 = &quot;Bye&quot;; // 直接赋值 </span><br><span class="line">OLECHAR* str = OLESTR(&quot;ta ta&quot;); // 长度为5的宽字符 </span><br><span class="line">CComBSTR bstr2(wcslen(str)); // 定义长度为5 </span><br><span class="line">wcscpy(bstr2.m_str, str); // 将宽字符串复制到BSTR中 </span><br><span class="line">CComBSTR bstr3(5, OLESTR(&quot;Hello World&quot;)); </span><br><span class="line">CComBSTR bstr4(5, &quot;Hello World&quot;); </span><br><span class="line">CComBSTR bstr5(OLESTR(&quot;Hey there&quot;)); </span><br><span class="line">CComBSTR bstr6(&quot;Hey there&quot;); </span><br><span class="line">CComBSTR bstr7(bstr6); </span><br><span class="line">// 构造时复制，内容为&quot;Hey there&quot; </span><br><span class="line"></span><br><span class="line">　　_bstr_t是是C++对BSTR的封装，它的构造和析构函数分别调用SysAllocString和SysFreeString函数，其他操作是借用BSTR API函数。与_variant_t相似，使用时也要添加comutil.h和comsupp.lib。 </span><br><span class="line"></span><br><span class="line">　　五、BSTR、char*和CString转换 </span><br><span class="line"></span><br><span class="line">　　(1) char*转换成CString </span><br><span class="line"></span><br><span class="line">　　若将char*转换成CString，除了直接赋值外，还可使用CString::Format进行。例如： </span><br><span class="line"></span><br><span class="line">char chArray[] = &quot;This is a test&quot;; </span><br><span class="line">char * p = &quot;This is a test&quot;; </span><br><span class="line"></span><br><span class="line">　　或 </span><br><span class="line"></span><br><span class="line">LPSTR p = &quot;This is a test&quot;; </span><br><span class="line"></span><br><span class="line">　　或在已定义Unicode应的用程序中 </span><br><span class="line"></span><br><span class="line">TCHAR * p = _T(&quot;This is a test&quot;); </span><br><span class="line"></span><br><span class="line">　　或 </span><br><span class="line"></span><br><span class="line">LPTSTR p = _T(&quot;This is a test&quot;); </span><br><span class="line">CString theString = chArray; </span><br><span class="line">theString.Format(_T(&quot;%s&quot;), chArray); </span><br><span class="line">theString = p; </span><br><span class="line"></span><br><span class="line">　　(2) CString转换成char* </span><br><span class="line"></span><br><span class="line">若将CString类转换成char*(LPSTR)类型，常常使用下列三种方法： </span><br><span class="line"></span><br><span class="line">方法一，使用强制转换。例如： </span><br><span class="line">CString theString( &quot;This is a test&quot; ); </span><br><span class="line">LPTSTR lpsz =(LPTSTR)(LPCTSTR)theString; </span><br><span class="line"></span><br><span class="line">方法二，使用strcpy。例如： </span><br><span class="line">CString theString( &quot;This is a test&quot; ); </span><br><span class="line">LPTSTR lpsz = new TCHAR[theString.GetLength()+1]; </span><br><span class="line">_tcscpy(lpsz, theString); </span><br><span class="line"></span><br><span class="line">　　需要说明的是，strcpy(或可移值Unicode/MBCS的_tcscpy)的第二个参数是 const wchar_t* (Unicode)或const char* (ANSI)，系统编译器将会自动对其进行转换。 </span><br><span class="line"></span><br><span class="line">方法三，使用CString::GetBuffer。例如： </span><br><span class="line">CString s(_T(&quot;This is a test &quot;)); </span><br><span class="line">LPTSTR p = s.GetBuffer(); </span><br><span class="line">// 在这里添加使用p的代码 </span><br><span class="line">if(p != NULL) *p = _T(&apos;/0&apos;); </span><br><span class="line">s.ReleaseBuffer(); </span><br><span class="line">// 使用完后及时释放，以便能使用其它的CString成员函数 </span><br><span class="line"></span><br><span class="line">　　(3) BSTR转换成char* </span><br><span class="line"></span><br><span class="line">方法一，使用ConvertBSTRToString。例如： </span><br><span class="line">#include </span><br><span class="line">#pragma comment(lib, &quot;comsupp.lib&quot;) </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])&#123; </span><br><span class="line">BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); </span><br><span class="line">char* lpszText2 = _com_util::ConvertBSTRToString(bstrText); </span><br><span class="line">SysFreeString(bstrText); // 用完释放 </span><br><span class="line">delete[] lpszText2; </span><br><span class="line">return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">　　方法二，使用_bstr_t的赋值运算符重载。例如： </span><br><span class="line"></span><br><span class="line">_bstr_t b = bstrText; </span><br><span class="line">char* lpszText2 = b; </span><br><span class="line"></span><br><span class="line">　　(4) char*转换成BSTR </span><br><span class="line"></span><br><span class="line">方法一，使用SysAllocString等API函数。例如： </span><br><span class="line">BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); </span><br><span class="line">BSTR bstrText = ::SysAllocStringLen(L&quot;Test&quot;,4); </span><br><span class="line">BSTR bstrText = ::SysAllocStringByteLen(&quot;Test&quot;,4); </span><br><span class="line"></span><br><span class="line">方法二，使用COleVariant或_variant_t。例如： </span><br><span class="line">//COleVariant strVar(&quot;This is a test&quot;); </span><br><span class="line">_variant_t strVar(&quot;This is a test&quot;); </span><br><span class="line">BSTR bstrText = strVar.bstrVal; </span><br><span class="line"></span><br><span class="line">方法三，使用_bstr_t，这是一种最简单的方法。例如： </span><br><span class="line">BSTR bstrText = _bstr_t(&quot;This is a test&quot;); </span><br><span class="line"></span><br><span class="line">方法四，使用CComBSTR。例如： </span><br><span class="line">BSTR bstrText = CComBSTR(&quot;This is a test&quot;); </span><br><span class="line">或 </span><br><span class="line">CComBSTR bstr(&quot;This is a test&quot;); </span><br><span class="line">BSTR bstrText = bstr.m_str; </span><br><span class="line"></span><br><span class="line">方法五，使用ConvertStringToBSTR。例如： </span><br><span class="line">char* lpszText = &quot;Test&quot;; </span><br><span class="line">BSTR bstrText = _com_util::ConvertStringToBSTR(lpszText); </span><br><span class="line"></span><br><span class="line">　　(5) CString转换成BSTR </span><br><span class="line"></span><br><span class="line">　　通常是通过使用CStringT::AllocSysString来实现。例如： </span><br><span class="line"></span><br><span class="line">CString str(&quot;This is a test&quot;); </span><br><span class="line">BSTR bstrText = str.AllocSysString(); </span><br><span class="line">… </span><br><span class="line">SysFreeString(bstrText); // 用完释放 </span><br><span class="line"></span><br><span class="line">　　(6) BSTR转换成CString </span><br><span class="line"></span><br><span class="line">　　一般可按下列方法进行： </span><br><span class="line"></span><br><span class="line">BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); </span><br><span class="line">CStringA str; </span><br><span class="line">str.Empty(); </span><br><span class="line">str = bstrText; </span><br><span class="line"></span><br><span class="line">　　或 </span><br><span class="line"></span><br><span class="line">CStringA str(bstrText); </span><br><span class="line"></span><br><span class="line">　　(7) ANSI、Unicode和宽字符之间的转换 </span><br><span class="line"></span><br><span class="line">　　方法一，使用MultiByteToWideChar将ANSI字符转换成Unicode字符，使用WideCharToMultiByte将Unicode字符转换成ANSI字符。 </span><br><span class="line"></span><br><span class="line">　　方法二，使用“_T”将ANSI转换成“一般”类型字符串，使用“L”将ANSI转换成Unicode，而在托管C++环境中还可使用S将ANSI字符串转换成String*对象。例如： </span><br><span class="line">TCHAR tstr[] = _T(&quot;this is a test&quot;); </span><br><span class="line">wchar_t wszStr[] = L&quot;This is a test&quot;; </span><br><span class="line">String* str = S”This is a test”; </span><br><span class="line"></span><br><span class="line">　　方法三，使用ATL 7.0的转换宏和类。ATL7.0在原有3.0基础上完善和增加了许多字符串转换宏以及提供相应的类，它具有如图3所示的统一形式： </span><br><span class="line">　　其中，第一个C表示“类”，以便于ATL 3.0宏相区别，第二个C表示常量，2表示“to”，EX表示要开辟一定大小的缓冲。SourceType和DestinationType可以是A、 T、W和OLE，其含义分别是ANSI、Unicode、“一般”类型和OLE字符串。例如，CA2CT就是将ANSI转换成一般类型的字符串常量。下面是一些示例代码： </span><br><span class="line">LPTSTR tstr= CA2TEX&lt;16&gt;(&quot;this is a test&quot;); </span><br><span class="line">LPCTSTR tcstr= CA2CT(&quot;this is a test&quot;); </span><br><span class="line">wchar_t wszStr[] = L&quot;This is a test&quot;; </span><br><span class="line">char* chstr = CW2A(wszStr); </span><br><span class="line"></span><br><span class="line">　　六、结语</span><br><span class="line">几乎所有的程序都要用到字符串，而Visual C++.NET由于功能强大、应用广泛，因而字符串之间的转换更为频繁。本文几乎涉及到目前的所有转换方法。当然对于.NET框架来说，还可使用Convert和Text类进行不同数据类型以及字符编码之间的相互转换。</span><br><span class="line">int i = 100;</span><br><span class="line">long l = 2001;</span><br><span class="line">float f=300.2;</span><br><span class="line">double d=12345.119;</span><br><span class="line">char username[]=&quot;程佩君&quot;;</span><br><span class="line">char temp[200];</span><br><span class="line">char *buf;</span><br><span class="line">CString str;</span><br><span class="line">_variant_t v1;</span><br><span class="line">_bstr_t v2;</span><br><span class="line"></span><br><span class="line">一、其它数据类型转换为字符串</span><br><span class="line"> </span><br><span class="line">短整型(int)</span><br><span class="line">itoa(i,temp,10);///将i转换为字符串放入temp中,最后一个数字表示十进制</span><br><span class="line">itoa(i,temp,2); ///按二进制方式转换</span><br><span class="line">长整型(long)</span><br><span class="line">ltoa(l,temp,10);</span><br><span class="line">浮点数(float,double)</span><br><span class="line">用fcvt可以完成转换,这是MSDN中的例子:</span><br><span class="line">int decimal, sign; </span><br><span class="line">char *buffer; </span><br><span class="line">double source = 3.1415926535; </span><br><span class="line">buffer = _fcvt( source, 7, &amp;decimal, &amp;sign ); </span><br><span class="line">运行结果:source: 3.1415926535 buffer: &apos;31415927&apos; decimal: 1 sign: 0</span><br><span class="line">decimal表示小数点的位置,sign表示符号:0为正数，1为负数</span><br><span class="line">CString变量</span><br><span class="line">str = &quot;2008北京奥运&quot;;</span><br><span class="line">buf = (LPSTR)(LPCTSTR)str;</span><br><span class="line">BSTR变量</span><br><span class="line">BSTR bstrValue = ::SysAllocString(L&quot;程序员&quot;); </span><br><span class="line">char * buf = _com_util::ConvertBSTRToString(bstrValue); </span><br><span class="line">SysFreeString(bstrValue); </span><br><span class="line">AfxMessageBox(buf); </span><br><span class="line">delete(buf);</span><br><span class="line">CComBSTR变量</span><br><span class="line">CComBSTR bstrVar(&quot;test&quot;); </span><br><span class="line">char *buf = _com_util::ConvertBSTRToString(bstrVar.m_str); </span><br><span class="line">AfxMessageBox(buf); </span><br><span class="line">delete(buf);</span><br><span class="line">_bstr_t变量</span><br><span class="line">_bstr_t类型是对BSTR的封装，因为已经重载了=操作符，所以很容易使用</span><br><span class="line">_bstr_t bstrVar(&quot;test&quot;); </span><br><span class="line">const char *buf = bstrVar;///不要修改buf中的内容 </span><br><span class="line">AfxMessageBox(buf);</span><br><span class="line">通用方法(针对非COM数据类型)</span><br><span class="line">用sprintf完成转换</span><br><span class="line">char  buffer[200];char  c = &apos;1&apos;;int   i = 35;long  j = 1000;float f = 1.7320534f;sprintf( buffer, &quot;%c&quot;,c);sprintf( buffer, &quot;%d&quot;,i);sprintf( buffer, &quot;%d&quot;,j);sprintf( buffer, &quot;%f&quot;,f);</span><br><span class="line">二、字符串转换为其它数据类型</span><br><span class="line">strcpy(temp,&quot;123&quot;);</span><br><span class="line">短整型(int)</span><br><span class="line">i = atoi(temp);</span><br><span class="line">长整型(long)</span><br><span class="line">l = atol(temp);</span><br><span class="line">浮点(double)</span><br><span class="line">d = atof(temp);</span><br><span class="line">CString变量</span><br><span class="line">CString name = temp;</span><br><span class="line">BSTR变量 </span><br><span class="line">BSTR bstrValue = ::SysAllocString(L&quot;程序员&quot;); </span><br><span class="line">...///完成对bstrValue的使用</span><br><span class="line">SysFreeString(bstrValue);</span><br><span class="line">CComBSTR变量</span><br><span class="line">CComBSTR类型变量可以直接赋值</span><br><span class="line">CComBSTR bstrVar1(&quot;test&quot;);</span><br><span class="line">CComBSTR bstrVar2(temp);</span><br><span class="line">_bstr_t变量</span><br><span class="line">_bstr_t类型的变量可以直接赋值</span><br><span class="line">_bstr_t bstrVar1(&quot;test&quot;); </span><br><span class="line">_bstr_t bstrVar2(temp);</span><br><span class="line">三、其它数据类型转换到CString</span><br><span class="line">使用CString的成员函数Format来转换,例如:</span><br><span class="line">整数(int)</span><br><span class="line">str.Format(&quot;%d&quot;,i);</span><br><span class="line">浮点数(float)</span><br><span class="line">str.Format(&quot;%f&quot;,i);</span><br><span class="line">字符串指针(char *)等已经被CString构造函数支持的数据类型可以直接赋值</span><br><span class="line">str = username;</span><br><span class="line">对于Format所不支持的数据类型，可以通过上面所说的关于其它数据类型转化到char *的方法先转到char *，然后赋值给CString变量。</span><br><span class="line">四、BSTR、_bstr_t与CComBSTR</span><br><span class="line">CComBSTR 是ATL对BSTR的封装，_bstr_t是C++对BSTR的封装,BSTR是32位指针,但并不直接指向字串的缓冲区。</span><br><span class="line">char *转换到BSTR可以这样: </span><br><span class="line">BSTR b=_com_util::ConvertStringToBSTR(&quot;数据&quot;);///使用前需要加上comutil.h和comsupp.lib</span><br><span class="line">SysFreeString(bstrValue); </span><br><span class="line">反之可以使用</span><br><span class="line">char *p=_com_util::ConvertBSTRToString(b);</span><br><span class="line">delete p;</span><br><span class="line">具体可以参考一，二段落里的具体说明。</span><br><span class="line"></span><br><span class="line">CComBSTR与_bstr_t对大量的操作符进行了重载，可以直接进行=,!=,==等操作，所以使用非常方便。</span><br><span class="line">特别是_bstr_t,建议大家使用它。</span><br><span class="line">五、VARIANT 、_variant_t 与 COleVariant</span><br><span class="line">VARIANT的结构可以参考头文件VC98/Include/OAIDL.H中关于结构体tagVARIANT的定义。</span><br><span class="line">对于VARIANT变量的赋值：首先给vt成员赋值，指明数据类型，再对联合结构中相同数据类型的变量赋值，举个例子：</span><br><span class="line">VARIANT va;</span><br><span class="line">int a=2001;</span><br><span class="line">va.vt=VT_I4;///指明整型数据</span><br><span class="line">va.lVal=a; ///赋值</span><br><span class="line"></span><br><span class="line">对于不马上赋值的VARIANT，最好先用Void VariantInit(VARIANTARG FAR* pvarg);进行初始化,其本质是将vt设置为VT_EMPTY,下表我们列举vt与常用数据的对应关系:</span><br><span class="line"></span><br><span class="line">Byte bVal;</span><br><span class="line">// VT_UI1.</span><br><span class="line">Short iVal;</span><br><span class="line">// VT_I2.</span><br><span class="line">long lVal;</span><br><span class="line">// VT_I4.</span><br><span class="line">float fltVal;</span><br><span class="line">// VT_R4.</span><br><span class="line">double dblVal;</span><br><span class="line">// VT_R8.</span><br><span class="line">VARIANT_BOOL boolVal;</span><br><span class="line">// VT_BOOL.</span><br><span class="line">SCODE scode;</span><br><span class="line">// VT_ERROR.</span><br><span class="line">CY cyVal;</span><br><span class="line">// VT_CY.</span><br><span class="line">DATE date;</span><br><span class="line">// VT_DATE.</span><br><span class="line">BSTR bstrVal;</span><br><span class="line">// VT_BSTR.</span><br><span class="line">DECIMAL FAR* pdecVal</span><br><span class="line">// VT_BYREF|VT_DECIMAL.</span><br><span class="line">IUnknown FAR* punkVal;</span><br><span class="line">// VT_UNKNOWN.</span><br><span class="line">IDispatch FAR* pdispVal;</span><br><span class="line">// VT_DISPATCH.</span><br><span class="line">SAFEARRAY FAR* parray;</span><br><span class="line">// VT_ARRAY|*.</span><br><span class="line">Byte FAR* pbVal;</span><br><span class="line">// VT_BYREF|VT_UI1.</span><br><span class="line">short FAR* piVal;</span><br><span class="line">// VT_BYREF|VT_I2.</span><br><span class="line">long FAR* plVal;</span><br><span class="line">// VT_BYREF|VT_I4.</span><br><span class="line">float FAR* pfltVal;</span><br><span class="line">// VT_BYREF|VT_R4.</span><br><span class="line">double FAR* pdblVal;</span><br><span class="line">// VT_BYREF|VT_R8.</span><br><span class="line">VARIANT_BOOL FAR* pboolVal;</span><br><span class="line">// VT_BYREF|VT_BOOL.</span><br><span class="line">SCODE FAR* pscode;</span><br><span class="line">// VT_BYREF|VT_ERROR.</span><br><span class="line">CY FAR* pcyVal;</span><br><span class="line">// VT_BYREF|VT_CY.</span><br><span class="line">DATE FAR* pdate;</span><br><span class="line">// VT_BYREF|VT_DATE.</span><br><span class="line">BSTR FAR* pbstrVal;</span><br><span class="line">// VT_BYREF|VT_BSTR.</span><br><span class="line">IUnknown FAR* FAR* ppunkVal;</span><br><span class="line">// VT_BYREF|VT_UNKNOWN.</span><br><span class="line">IDispatch FAR* FAR* ppdispVal;</span><br><span class="line">// VT_BYREF|VT_DISPATCH.</span><br><span class="line">SAFEARRAY FAR* FAR* pparray;</span><br><span class="line">// VT_ARRAY|*.</span><br><span class="line">VARIANT FAR* pvarVal;</span><br><span class="line">// VT_BYREF|VT_VARIANT.</span><br><span class="line">void FAR* byref;</span><br><span class="line">// Generic ByRef.</span><br><span class="line">char cVal;</span><br><span class="line">// VT_I1.</span><br><span class="line">unsigned short uiVal;</span><br><span class="line">// VT_UI2.</span><br><span class="line">unsigned long ulVal;</span><br><span class="line">// VT_UI4.</span><br><span class="line">int intVal;</span><br><span class="line">// VT_INT.</span><br><span class="line">unsigned int uintVal;</span><br><span class="line">// VT_UINT.</span><br><span class="line">char FAR * pcVal;</span><br><span class="line">// VT_BYREF|VT_I1.</span><br><span class="line">unsigned short FAR * puiVal;</span><br><span class="line">// VT_BYREF|VT_UI2.</span><br><span class="line">unsigned long FAR * pulVal;</span><br><span class="line">// VT_BYREF|VT_UI4.</span><br><span class="line">int FAR * pintVal;</span><br><span class="line">// VT_BYREF|VT_INT.</span><br><span class="line">unsigned int FAR * puintVal;</span><br><span class="line">//VT_BYREF|VT_UINT.</span><br><span class="line">_variant_t是VARIANT的封装类，其赋值可以使用强制类型转换，其构造函数会自动处理这些数据类型。</span><br><span class="line">使用时需加上#include &lt;comdef.h&gt;</span><br><span class="line">例如：</span><br><span class="line">long l=222;</span><br><span class="line">ing i=100;</span><br><span class="line">_variant_t lVal(l);</span><br><span class="line">lVal = (long)i;</span><br><span class="line">COleVariant的使用与_variant_t的方法基本一样，请参考如下例子：</span><br><span class="line">COleVariant v3 = &quot;字符串&quot;, v4 = (long)1999;</span><br><span class="line">CString str =(BSTR)v3.pbstrVal;</span><br><span class="line">long i = v4.lVal;</span><br><span class="line">六、其它一些COM数据类型</span><br><span class="line">根据ProgID得到CLSID</span><br><span class="line">HRESULT CLSIDFromProgID( LPCOLESTR lpszProgID,LPCLSID pclsid);</span><br><span class="line">CLSID clsid;</span><br><span class="line">CLSIDFromProgID( L&quot;MAPI.Folder&quot;,&amp;clsid);</span><br><span class="line">根据CLSID得到ProgID</span><br><span class="line">WINOLEAPI ProgIDFromCLSID( REFCLSID clsid,LPOLESTR * lplpszProgID); </span><br><span class="line">例如我们已经定义了 CLSID_IApplication,下面的代码得到ProgID</span><br><span class="line">LPOLESTR pProgID = 0;</span><br><span class="line">ProgIDFromCLSID( CLSID_IApplication,&amp;pProgID);</span><br><span class="line">...///可以使用pProgID </span><br><span class="line">CoTaskMemFree(pProgID);//不要忘记释放</span><br><span class="line">七、ANSI与Unicode</span><br><span class="line">Unicode称为宽字符型字串,COM里使用的都是Unicode字符串。</span><br><span class="line">将ANSI转换到Unicode</span><br><span class="line">(1)通过L这个宏来实现，例如: CLSIDFromProgID( L&quot;MAPI.Folder&quot;,&amp;clsid);</span><br><span class="line">(2)通过MultiByteToWideChar函数实现转换,例如:</span><br><span class="line">char *szProgID = &quot;MAPI.Folder&quot;;</span><br><span class="line">WCHAR szWideProgID[128];</span><br><span class="line">CLSID clsid;</span><br><span class="line">long lLen = MultiByteToWideChar(CP_ACP,0,szProgID,strlen(szProgID),szWideProgID,sizeof(szWideProgID));</span><br><span class="line">szWideProgID[lLen] = &apos;/0&apos;; </span><br><span class="line">(3)通过A2W宏来实现,例如: </span><br><span class="line">USES_CONVERSION; </span><br><span class="line">CLSIDFromProgID( A2W(szProgID),&amp;clsid);</span><br><span class="line">将Unicode转换到ANSI</span><br><span class="line">(1)使用WideCharToMultiByte,例如:</span><br><span class="line">// 假设已经有了一个Unicode 串 wszSomeString... </span><br><span class="line">char szANSIString [MAX_PATH]; </span><br><span class="line">WideCharToMultiByte ( CP_ACP, WC_COMPOSITECHECK, wszSomeString, -1, szANSIString, sizeof(szANSIString), NULL, NULL ); </span><br><span class="line">(2)使用W2A宏来实现,例如:</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">pTemp=W2A(wszSomeString);</span><br><span class="line">八、其它</span><br><span class="line">对消息的处理中我们经常需要将WPARAM或LPARAM等32位数据（DWORD)分解成两个16位数据（WORD),例如：</span><br><span class="line">LPARAM lParam;</span><br><span class="line">WORD loValue = LOWORD(lParam);///取低16位</span><br><span class="line">WORD hiValue = HIWORD(lParam);///取高16位</span><br><span class="line">对于16位的数据(WORD)我们可以用同样的方法分解成高低两个8位数据(BYTE),例如:</span><br><span class="line">WORD wValue;</span><br><span class="line">BYTE loValue = LOBYTE(wValue);///取低8位</span><br><span class="line">BYTE hiValue = HIBYTE(wValue);///取高8位</span><br><span class="line">两个16位数据（WORD）合成32位数据(DWORD,LRESULT,LPARAM,或WPARAM)</span><br><span class="line">LONG MAKELONG( WORD wLow, WORD wHigh );</span><br><span class="line">WPARAM MAKEWPARAM( WORD wLow, WORD wHigh ); </span><br><span class="line">LPARAM MAKELPARAM( WORD wLow, WORD wHigh );</span><br><span class="line">LRESULT MAKELRESULT( WORD wLow, WORD wHigh );</span><br><span class="line">两个8位的数据(BYTE)合成16位的数据(WORD)</span><br><span class="line">WORD MAKEWORD( BYTE bLow, BYTE bHigh );</span><br><span class="line">从R(red),G(green),B(blue)三色得到COLORREF类型的颜色值</span><br><span class="line">COLORREF RGB( BYTE byRed,BYTE byGreen,BYTE byBlue );</span><br><span class="line">例如COLORREF bkcolor = RGB(0x22,0x98,0x34);</span><br><span class="line">从COLORREF类型的颜色值得到RGB三个颜色值</span><br><span class="line">BYTE Red = GetRValue(bkcolor); ///得到红颜色</span><br><span class="line">BYTE Green = GetGValue(bkcolor); ///得到绿颜色</span><br><span class="line">BYTE Blue = GetBValue(bkcolor); ///得到兰颜色</span><br><span class="line">九、注意事项</span><br><span class="line">假如需要使用到ConvertBSTRToString此类函数,需要加上头文件comutil.h,并在setting中加入comsupp.lib或者直接加上#pragma comment( lib, &quot;comsupp.lib&quot; )</span><br><span class="line">后记：本文匆匆写成，错误之处在所难免，欢迎指正.</span><br><span class="line">关于把BSTR类型数据转换成CString 类型数据时的问题?</span><br><span class="line">当我在把BSTR类型数据转换成CString 或 “char* 类型”数据时，发现在BSTR类型字符串较短的情况下没问题，当较长时就会出现</span><br><span class="line">内存读写错了。（在NT，2000下都测试是这样的。）</span><br><span class="line">根据你所说：</span><br><span class="line">1）字符串指针(char *)等已经被CString构造函数支持的数据类型 可以直接赋值 str = username;</span><br><span class="line">2）当b 为BSTR类型时可以使用</span><br><span class="line">char *p=_com_util::ConvertBSTRToString(b);</span><br><span class="line">于是以下是对的：</span><br><span class="line">CString cstr;</span><br><span class="line">BSTR bstr;</span><br><span class="line">....</span><br><span class="line">cstr=com_util::ConvertBSTRToString(bstr);</span><br><span class="line">...</span><br><span class="line">可是当bstr非常大时（其实，较大时就会）就会出现内存读写错，不知何故。</span><br><span class="line">此外我发现cstr=com_util::ConvertBSTRToString(bstr);</span><br><span class="line">可以简化为 cstr=bstr; 但当bstr较大时同样出现这个问题。</span><br><span class="line">请兄弟帮忙！急。谢谢！</span><br><span class="line">如何转化((list*)fileip.bian)-&gt;liang</span><br><span class="line">关于把CString转化成LPCTSTR的问题 作者:jakiesun 发表日期:2001-9-5 20:08:48</span><br><span class="line">我记的我以前写过这样一段代码</span><br><span class="line">void function()</span><br><span class="line">&#123;</span><br><span class="line">CString str,str1,str2;</span><br><span class="line">function((char*)(LPCTSTR)str1);</span><br><span class="line">str=str1;</span><br><span class="line">...//调试道此发现str2的值随着str的改变而改变，请问能解释一下为什么，如有回答，请通知</span><br><span class="line">wangshaohong@sohu.com,tx先</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">添加lib支持 作者:磨刀霍霍 发表日期:2001-9-10 11:32:12</span><br><span class="line">如果不添加会产生错误，在setting中加入comsupp.lib或者直接#pragma comment( lib, &quot;comsupp.lib&quot; )</span><br><span class="line">微软认为缺省的设置call convention如果不设置成__cdecl也会出现同样的错误。</span><br><span class="line"></span><br><span class="line">1。int 转成cstring ？？</span><br><span class="line"></span><br><span class="line">回复人：　caigzhi(caigzhi)　(2001-10-17 11:27:35) 得0分 </span><br><span class="line">CString 的成员函数Format()</span><br><span class="line"></span><br><span class="line">int a = 2131;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(&quot;%d&quot;,a);</span><br><span class="line"></span><br><span class="line">回复人：　tenchi(C与C++之间)　(2001-10-17 11:32:12) 得0分 </span><br><span class="line">int i=2001;</span><br><span class="line">char str[10];</span><br><span class="line">_itoa(i,str,10);</span><br><span class="line">CString szString=str; </span><br><span class="line">回复人：　fiolin(幽深的水)　(2001-10-17 11:45:40) 得0分 </span><br><span class="line">他们两个的都可以！！ </span><br><span class="line"></span><br><span class="line">回复人：　sohucsdnvc(thanks)　(2001-10-17 13:24:17) 得0分 </span><br><span class="line">那如何把double转成cstring </span><br><span class="line">回复人：　yihugang(小虎子)　(2001-10-17 13:29:15) 得6分 </span><br><span class="line">int i = 2131;</span><br><span class="line">char *c=new char[20];</span><br><span class="line">CString str;</span><br><span class="line">sprintf(c,&apos;%d&apos;,i);</span><br><span class="line">str=*c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回复人：　Gu_c_h(Gu)　(2001-10-17 14:07:17) 得0分 </span><br><span class="line">用 _gcvt 下面是 msdn 的例子</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line"></span><br><span class="line">/* _GCVT.C: This program converts -3.1415e5</span><br><span class="line">* to its string representation.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main( void )</span><br><span class="line">&#123;</span><br><span class="line">char buffer[50];</span><br><span class="line">double source = -3.1415e5;</span><br><span class="line">_gcvt( source, 7, buffer );</span><br><span class="line">printf( &quot;source: %f buffer: &apos;%s&apos;/n&quot;, source, buffer );</span><br><span class="line">_gcvt( source, 7, buffer );</span><br><span class="line">printf( &quot;source: %e buffer: &apos;%s&apos;/n&quot;, source, buffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">source: -314150.000000 buffer: &apos;-314150.&apos;</span><br><span class="line">source: -3.141500e+005 buffer: &apos;-314150.&apos;</span><br><span class="line"></span><br><span class="line">回复人：　Gu_c_h(Gu)　(2001-10-17 14:49:56) 得6分 </span><br><span class="line">int a = -3.1415e5;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(&quot;%f&quot;,a); </span><br><span class="line">回复人：　ruixp(锐剑)　(2001-10-17 15:06:48) 得6分 </span><br><span class="line">CString 的成员函数Format()</span><br><span class="line">int a = 2131;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(&quot;%d&quot;,a);</span><br><span class="line"></span><br><span class="line">2。基类对象怎么能转换成派生类对象？</span><br><span class="line">int CDaoListView::OnCreate(LPCREATESTRUCT lpCreateStruct) </span><br><span class="line">&#123;</span><br><span class="line">lpCreateStruct-&gt;style |= LVS_REPORT |LVS_EDITLABELS;</span><br><span class="line">if (CListView::OnCreate(lpCreateStruct) == -1)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">//////////// 创建ImageList;</span><br><span class="line">CDaoViewApp * pApp = (CDaoViewApp *) AfxGetApp();</span><br><span class="line"></span><br><span class="line">m_pImageList = new CImageList();</span><br><span class="line">ASSERT(m_pImageList !=NULL);</span><br><span class="line">m_pImageList-&gt;Create(16,16,TRUE,4,4);</span><br><span class="line">m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_KEY));</span><br><span class="line">m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_ICON4));</span><br><span class="line">m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_ICON5));</span><br><span class="line"></span><br><span class="line">CListCtrlEx&amp; ctlList = (CListCtrlEx&amp;) GetListCtrl();//我不懂的就这句，cListCtrlEx看下面的声明。</span><br><span class="line">ctlList.SetImageList (m_pImageList, LVSIL_SMALL) ;</span><br><span class="line">////////////</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CListCtrlEx : public CListCtrl//类cListCtrlEx定义。</span><br><span class="line">&#123;.....</span><br><span class="line">&#125;</span><br><span class="line">class CDaoListView : public CListView//cDaoListView定义！</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">注：我的问题是GetListCtrl()返回的是一个cListCtrl对象的引用,怎么能把它转换成一个它的派生类对象的引用？c++的类型转换怎么支持？ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回复贴子： </span><br><span class="line">回复人：　lhj(努力加油)　(2002-1-29 18:56:06) 得0分 </span><br><span class="line">CListCtrlEx&amp; ctlList = (CListCtrlEx&amp;) GetListCtrl();</span><br><span class="line">这是强制类型转换，&amp;表示是一个引用，lctList的值在这次赋值后不能被修改。</span><br><span class="line"></span><br><span class="line">回复人：　wwwsq(wwwsq)　(2002-1-29 19:09:22) 得0分 </span><br><span class="line">建议你找本C++方面的书看看，VC虽然号称可视，实际上C++基础还是很重要的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回复人：　xcopy(xcopy)　(2002-1-29 19:26:16) 得0分 </span><br><span class="line">用dynamic_cast()可以安全的转换。 </span><br><span class="line"></span><br><span class="line">3。如何在CString和double之间转换？要求转换之后能保留小数点，保留正负号？？</span><br><span class="line"></span><br><span class="line">cstring::format(%.xe) x为精度位 </span><br><span class="line"></span><br><span class="line">回复人：　pchaos(杂讲)　(2002-1-28 11:21:46) 得0分 </span><br><span class="line">CString str;</span><br><span class="line">double db;</span><br><span class="line">str = &quot;123.456&quot;;</span><br><span class="line">db = atof((LPCTSTR)str); </span><br><span class="line">回复人：　hgw111(hg)　(2002-1-28 11:52:57) 得0分 </span><br><span class="line">CString -&gt; double : atof</span><br><span class="line">double -&gt;CString :Format </span><br><span class="line">回复人：　pchaos(杂讲)　(2002-1-28 13:46:04) 得0分 </span><br><span class="line">CString str;</span><br><span class="line">double db;</span><br><span class="line">str = &quot;123.456&quot;;</span><br><span class="line">db = atof((LPCTSTR)str); </span><br><span class="line">db = 777.999;</span><br><span class="line">str.format(&quot;%e&quot;, db); </span><br><span class="line"></span><br><span class="line">4。字符型要转换成int？？</span><br><span class="line">atoi(str) </span><br><span class="line"></span><br><span class="line">5。_bstr_t 到 unsigned int？？</span><br><span class="line">_bstr_t str;</span><br><span class="line">unsigned int Length=6;</span><br><span class="line">Length=Length-str.length(); </span><br><span class="line"></span><br><span class="line">6。VARIANT类型转换问题？</span><br><span class="line">我在使用MSCOMM中SetOutput()函数时</span><br><span class="line">形参必须为VARIANT变量</span><br><span class="line">如何将其它的数据类型转换为VARIANT类型？</span><br><span class="line">如：Cstring-&gt;VARIANT、 *char-&gt;VARIANT</span><br><span class="line">我对VARIANT的类型结构体不太熟，请讲详细些（最好有范例），谢谢！</span><br><span class="line"></span><br><span class="line">回复贴子： </span><br><span class="line">回复人：　vc_xiaoxin(小新)　(2001-12-26 15:43:57) 得0分 </span><br><span class="line">VARIANT本身是一个复杂的结构，别的数据怎么转呀？关注 </span><br><span class="line">回复人：　mpg_liu(星仁)　(2001-12-27 18:33:50) 得10分 </span><br><span class="line">定义一个VARIANT变量后，他应该是一个结构体变量，其中有一个成员是字符型的，给这个成员赋值 </span><br><span class="line">回复人：　LLnju(LLnju)　(2001-12-27 18:36:10) 得0分 </span><br><span class="line">实在不清楚嘛就用 _variant_t , COleVariant 这些东东嘛，很好用的啊 </span><br><span class="line">回复人：　softarts(CDMA2000)　(2001-12-27 18:41:32) 得10分 </span><br><span class="line">构造一个就行了。</span><br><span class="line">VARIANT varXX;</span><br><span class="line">CString strYY;</span><br><span class="line">varXX.vt=VT_BSTR;</span><br><span class="line">varXX.bstrVal = strYY.allocsysstring();</span><br><span class="line">应该可以了。</span><br><span class="line">回复人：　softarts(CDMA2000)　(2001-12-27 18:42:11) 得0分 </span><br><span class="line">我也觉得COleVariant要好用一些，呵呵，我都用它。 </span><br><span class="line">回复人：　bobofu(有问题要问)　(2001-12-27 19:32:18) 得10分 </span><br><span class="line">CString str;</span><br><span class="line">_variant_t var;</span><br><span class="line">var = _variant_t(str); </span><br><span class="line"></span><br><span class="line">7。COleVarant 如何转换为 CString?</span><br><span class="line">CString 如何转换为 char *</span><br><span class="line">CString 如何转换为 char[xx] ？？</span><br><span class="line"></span><br><span class="line">CString 如何转换为 char * wsprintf或者＝</span><br><span class="line">CString 如何转换为 char[xx] strcpy（） </span><br><span class="line">回复人：　SecretGarden(天堂鸟)　(2002-1-14 11:55:23) 得0分 </span><br><span class="line">COleVarant封装了VAREANT类型。</span><br><span class="line">VAREANT类型其实是个巨大地Union，里面自然有你</span><br><span class="line">想要地unsigned char *类型。</span><br><span class="line">CString地GetBuffer和Format可以实现你的后两个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8。v_variant_t类型转换成cstring</span><br><span class="line">总提示我cstring未定义</span><br><span class="line">程序如下</span><br><span class="line">_variant_t vfirstname;//存储的是数据库中的数据</span><br><span class="line">CString str;//提示出错</span><br><span class="line">vfirstname=pRs-&gt;GetCollect (_variant_t(&quot;Phone_Num&quot;));</span><br><span class="line">vfirstname.ChangeType (VT_BSTR);</span><br><span class="line">str=vfirstname.bstrVal;//提示出错 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回复贴子： </span><br><span class="line">回复人：　hydnoahark(诺亚方舟)　(2001-11-12 11:56:51) 得10分 </span><br><span class="line">&gt;&gt;CString str;//提示出错</span><br><span class="line">要求include &lt;afx.h&gt;并且设置Use run-time Library为Multithreaded </span><br><span class="line">回复人：　zhengyun_ustc(^-^)　(2001-11-12 12:04:39) 得15分 </span><br><span class="line">CString未定义，说明你的工程没有引用MFC！！</span><br><span class="line"></span><br><span class="line">要想使你的工程支持MFC，请按照以下步骤作：</span><br><span class="line">1：在你的stdafx.h的头文件中加入：</span><br><span class="line">#include &quot;afxtempl.h&quot;</span><br><span class="line">这是一个囊括了MFC的集合定义的头文件，有了它，你的工程就识别Cstring类了。</span><br><span class="line"></span><br><span class="line">2：在你的工程设置中，在General页中，选择“MFC”为“Using MFC in a shared DLL”</span><br><span class="line"></span><br><span class="line">OK，现在再编译你的工程即可。 </span><br><span class="line">回复人：　zhengyun_ustc(^-^)　(2001-11-12 12:06:56) 得5分 </span><br><span class="line">_variant_t的bstrVal成员是BSTR类型。</span><br><span class="line">它是一个指向一个OLECHART*的指针。 </span><br><span class="line">回复人：　vickowang(小苍)　(2001-11-12 12:48:21) 得5分 </span><br><span class="line">(char *)_bstr_t(vfirstname) </span><br><span class="line">回复人：　smallfool(smallfool)　(2001-11-12 13:52:54) 得4分 </span><br><span class="line">或许你还需要一个从UNICODE字符到ANSI字符的转变函数 </span><br><span class="line">回复人：　sun_1112(萧)　(2001-11-12 17:34:44) 得0分 </span><br><span class="line">谢谢大家</span><br><span class="line">给我这么大的支持！：） </span><br><span class="line">回复人：　zhengyun_ustc(^-^)　(2001-11-14 13:24:07) 得0分 </span><br><span class="line">用vickowang(小苍)的意见可能会有问题，转换出的字符串应该是乱码。</span><br><span class="line"></span><br><span class="line">因为(char *)转换需要一个const的字符串资源，才能强制转换。</span><br><span class="line">所以应该：</span><br><span class="line">_bstr_t bstrTemp = _bstr_t(vfirstname.bstrVal);</span><br><span class="line">TCHAR szTemp[MAX_PATH];</span><br><span class="line">szTemp = (char*)bstrTemp;</span><br><span class="line"></span><br><span class="line">9。char * 转换为TCHAR类型？？</span><br><span class="line">直接转换,TCHAR相当于char了</span><br><span class="line">char * s;</span><br><span class="line">TCHAR * s1=(TCHAR *)s; </span><br><span class="line">回复人：　dysxq()　(2001-12-21 21:26:25) 得0分 </span><br><span class="line">要看你的程序设置是ANSI还是UNICODE, 如果是ANSI,直接转,如果是UNICODE,TCHAR相当于WCHAR, 要用mbstowcsz转一下 </span><br><span class="line">回复人：　xiaoxiaohan(萧晓寒)　(2001-12-21 23:52:17) 得0分 </span><br><span class="line">Unicode ：宽字节字符集</span><br><span class="line">1. 如何取得一个既包含单字节字符又包含双字节字符的字符串的字符个数？</span><br><span class="line">可以调用Microsoft Visual C++的运行期库包含函数_mbslen来操作多字节（既包括单字节也包括双字节）字符串。</span><br><span class="line">调用strlen函数，无法真正了解字符串中究竟有多少字符，它只能告诉你到达结尾的0之前有多少个字节。</span><br><span class="line">2. 如何对DBCS（双字节字符集）字符串进行操作？</span><br><span class="line">函数 描述</span><br><span class="line">PTSTR CharNext （ LPCTSTR ）; 返回字符串中下一个字符的地址</span><br><span class="line">PTSTR CharPrev （ LPCTSTR, LPCTSTR ）； 返回字符串中上一个字符的地址</span><br><span class="line">BOOL IsDBCSLeadByte( BYTE )； 如果该字节是DBCS字符的第一个字节，则返回非0值</span><br><span class="line">3. 为什么要使用Unicode？</span><br><span class="line">（1） 可以很容易地在不同语言之间进行数据交换。</span><br><span class="line">（2） 使你能够分配支持所有语言的单个二进制.exe文件或DLL文件。</span><br><span class="line">（3） 提高应用程序的运行效率。</span><br><span class="line">Windows 2000是使用Unicode从头进行开发的，如果调用任何一个Windows函数并给它传递一个ANSI字符串，那么系统首先要将字符串转换成</span><br><span class="line">Unicode，然后将Unicode字符串传递给操作系统。如果希望函数返回ANSI字符串，系统就会首先将Unicode字符串转换成ANSI字符串，然后将结</span><br><span class="line">果返回给你的应用程序。进行这些字符串的转换需要占用系统的时间和内存。通过从头开始用Unicode来开发应用程序，就能够使你的应用程序</span><br><span class="line">更加有效地运行。</span><br><span class="line">Windows CE 本身就是使用Unicode的一种操作系统，完全不支持ANSI Windows函数</span><br><span class="line">Windows 98 只支持ANSI，只能为ANSI开发应用程序。</span><br><span class="line">Microsoft公司将COM从16位Windows转换成Win32时，公司决定需要字符串的所有COM接口方法都只能接受Unicode字符串。</span><br><span class="line">4. 如何编写Unicode源代码？</span><br><span class="line">Microsoft公司为Unicode设计了WindowsAPI，这样，可以尽量减少代码的影响。实际上，可以编写单个源代码文件，以便使用或者不使用</span><br><span class="line">Unicode来对它进行编译。只需要定义两个宏（UNICODE和_UNICODE），就可以修改然后重新编译该源文件。</span><br><span class="line">_UNICODE宏用于C运行期头文件，而UNICODE宏则用于Windows头文件。当编译源代码模块时，通常必须同时定义这两个宏。</span><br><span class="line">5. Windows定义的Unicode数据类型有哪些？</span><br><span class="line">数据类型 说明</span><br><span class="line">WCHAR Unicode字符</span><br><span class="line">PWSTR 指向Unicode字符串的指针</span><br><span class="line">PCWSTR 指向一个恒定的Unicode字符串的指针</span><br><span class="line">对应的ANSI数据类型为CHAR，LPSTR和LPCSTR。</span><br><span class="line">ANSI/Unicode通用数据类型为TCHAR，PTSTR,LPCTSTR。</span><br><span class="line">6. 如何对Unicode进行操作？</span><br><span class="line">字符集 特性 实例</span><br><span class="line">ANSI 操作函数以str开头 strcpy</span><br><span class="line">Unicode 操作函数以wcs开头 wcscpy</span><br><span class="line">MBCS 操作函数以_mbs开头 _mbscpy</span><br><span class="line">ANSI/Unicode 操作函数以_tcs开头 _tcscpy（C运行期库）</span><br><span class="line">ANSI/Unicode 操作函数以lstr开头 lstrcpy（Windows函数）</span><br><span class="line">所有新的和未过时的函数在Windows2000中都同时拥有ANSI和Unicode两个版本。ANSI版本函数结尾以A表示；Unicode版本函数结尾以W表示。</span><br><span class="line">Windows会如下定义：</span><br><span class="line">#ifdef UNICODE</span><br><span class="line">#define CreateWindowEx CreateWindowExW</span><br><span class="line">#else</span><br><span class="line">#define CreateWindowEx CreateWindowExA</span><br><span class="line">#endif // !UNICODE</span><br><span class="line">7. 如何表示Unicode字符串常量？</span><br><span class="line">字符集 实例</span><br><span class="line">ANSI “string”</span><br><span class="line">Unicode L“string”</span><br><span class="line">ANSI/Unicode T(“string”)或_TEXT(“string”)if( szError[0] == _TEXT(‘J’) )&#123; &#125;</span><br><span class="line">8. 为什么应当尽量使用操作系统函数？</span><br><span class="line">这将有助于稍稍提高应用程序的运行性能，因为操作系统字符串函数常常被大型应用程序比如操作系统的外壳进程Explorer.exe所使用。由于</span><br><span class="line">这些函数使用得很多，因此，在应用程序运行时，它们可能已经被装入RAM。</span><br><span class="line">如：StrCat，StrChr，StrCmp和StrCpy等。</span><br><span class="line">9. 如何编写符合ANSI和Unicode的应用程序？</span><br><span class="line">（1） 将文本串视为字符数组，而不是chars数组或字节数组。</span><br><span class="line">（2） 将通用数据类型（如TCHAR和PTSTR）用于文本字符和字符串。</span><br><span class="line">（3） 将显式数据类型（如BYTE和PBYTE）用于字节、字节指针和数据缓存。</span><br><span class="line">（4） 将TEXT宏用于原义字符和字符串。</span><br><span class="line">（5） 执行全局性替换（例如用PTSTR替换PSTR）。</span><br><span class="line">（6） 修改字符串运算问题。例如函数通常希望在字符中传递一个缓存的大小，而不是字节。这意味着不应该传递sizeof(szBuffer),而应该传</span><br><span class="line">递（sizeof(szBuffer)/sizeof(TCHAR)。另外，如果需要为字符串分配一个内存块，并且拥有该字符串中的字符数目，那么请记住要按字节来</span><br><span class="line">分配内存。这就是说，应该调用malloc(nCharacters *sizeof(TCHAR)),而不是调用malloc(nCharacters)。</span><br><span class="line">10. 如何对字符串进行有选择的比较？</span><br><span class="line">通过调用CompareString来实现。</span><br><span class="line">标志 含义</span><br><span class="line">NORM_IGNORECASE 忽略字母的大小写</span><br><span class="line">NORM_IGNOREKANATYPE 不区分平假名与片假名字符</span><br><span class="line">NORM_IGNORENONSPACE 忽略无间隔字符</span><br><span class="line">NORM_IGNORESYMBOLS 忽略符号</span><br><span class="line">NORM_IGNOREWIDTH 不区分单字节字符与作为双字节字符的同一个字符</span><br><span class="line">SORT_STRINGSORT 将标点符号作为普通符号来处理</span><br><span class="line">11. 如何判断一个文本文件是ANSI还是Unicode？</span><br><span class="line">判断如果文本文件的开头两个字节是0xFF和0xFE，那么就是Unicode，否则是ANSI。</span><br><span class="line">12. 如何判断一段字符串是ANSI还是Unicode？</span><br><span class="line">用IsTextUnicode进行判断。IsTextUnicode使用一系列统计方法和定性方法，以便猜测缓存的内容。由于这不是一种确切的科学方法，因此 </span><br><span class="line">IsTextUnicode有可能返回不正确的结果。</span><br><span class="line">13. 如何在Unicode与ANSI之间转换字符串？</span><br><span class="line">Windows函数MultiByteToWideChar用于将多字节字符串转换成宽字符串；函数WideCharToMultiByte将宽字符串转换成等价的多字节字符串。</span><br><span class="line"></span><br><span class="line">回复人：　xtky_limi(痛在心中笑在脸上)　(2001-12-22 0:35:58) 得0分 </span><br><span class="line">上面说的已经比较全了。 </span><br><span class="line">回复人：　xtky_limi(痛在心中笑在脸上)　(2001-12-22 0:38:13) 得0分 </span><br><span class="line">TEXT是宏</span><br><span class="line">相当于L##</span><br><span class="line"></span><br><span class="line">它可以根据编译环境确定为DBMS,还是UNICODE字符集</span><br><span class="line"></span><br><span class="line">10。int类型转换为CString类型？</span><br><span class="line">回复人：　tjmxf(天涯)　(2001-12-17 19:59:34) 得0分 </span><br><span class="line">itoa() </span><br><span class="line">回复人：　zf925(天下哪来那么多高手)　(2001-12-17 20:00:30) 得22分 </span><br><span class="line">char m[20];</span><br><span class="line">str=str + itoa(i,m,10); </span><br><span class="line">回复人：　yuezifeng(wybzd)　(2001-12-17 20:00:50) 得22分 </span><br><span class="line">CString str;</span><br><span class="line">str.Format(&quot;%d&quot;,i);</span><br><span class="line"></span><br><span class="line">回复人：　kingfish(今飞)　(2001-12-17 20:06:27) 得0分 </span><br><span class="line">str.Format(&quot;%s%d&quot;,str,i); </span><br><span class="line">回复人：　tanyajun(谈子)　(2001-12-17 20:09:25) 得0分 </span><br><span class="line">CString str=&quot;test&quot;;</span><br><span class="line">int i=11;</span><br><span class="line">CString str1;</span><br><span class="line">str1.Format(&quot;%d&quot;,i);</span><br><span class="line">str = str+str1;</span><br><span class="line"></span><br><span class="line">回复人：　guanjinke(纶巾客)　(2001-12-17 20:10:42) 得0分 </span><br><span class="line">int i=11;</span><br><span class="line">CString str=&quot;test&quot;;</span><br><span class="line">CString addition;</span><br><span class="line">addition.Format(&quot;%d&quot;,i);</span><br><span class="line">str+=addition;</span><br><span class="line">就可以了。 </span><br><span class="line"></span><br><span class="line">11。关于sprintf类型转换的问题</span><br><span class="line">sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%&apos;&quot;,t_date)</span><br><span class="line">其中t_date是CTime类型，%后面应该是什么呢？%s是String类型,%c是char,那么CTime型对应的是什么呢？ </span><br><span class="line"> </span><br><span class="line">回复人：　yakai(日落长河)　(2001-12-17 17:45:47) 得0分 </span><br><span class="line">sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%S&apos;&quot;,(LPCSTR)t_date.Format( &quot;%A, %B %d, %Y&quot; ));</span><br><span class="line">如果不行，就</span><br><span class="line">char temp[50];</span><br><span class="line">CString str=t_date.Format( &quot;%A, %B %d, %Y&quot; );</span><br><span class="line">strcpy(temp,(LPCSTR)str);</span><br><span class="line">sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%S&apos;&quot;,temp);</span><br><span class="line">CTime::Format返回CString </span><br><span class="line">回复人：　loh(乐啸天涯)　(2001-12-17 17:52:57) 得0分 </span><br><span class="line">wait</span><br><span class="line"></span><br><span class="line">don&apos;t know </span><br><span class="line">回复人：　masterz()　(2001-12-17 20:21:05) 得0分 </span><br><span class="line">SQL语句中日期要写成字符串&quot;yyyymmdd&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">12。类型转换 unsigned int &lt;==&gt;CString??</span><br><span class="line">回复次数：8</span><br><span class="line">发表时间：2001-12-17 10:25:23</span><br><span class="line"></span><br><span class="line">unsigned int f;//unsigned int 0~4294967295</span><br><span class="line">CString g;</span><br><span class="line">f=2300000000;</span><br><span class="line">g.Format(&quot;%d&quot;,f);</span><br><span class="line">AfxMessageBox(g);</span><br><span class="line">出错。 </span><br><span class="line"></span><br><span class="line">回复人：　ydogg(灰毛兔频频)　(2001-12-17 10:31:29) 得0分 </span><br><span class="line">unsigned int f;//unsigned int 0~4294967295</span><br><span class="line">CString g;</span><br><span class="line">f=2300000000;</span><br><span class="line">g.Format(&quot;%d&quot;,f);</span><br><span class="line">MessageBox(g);//使用AfxMessageBox，需要窗口的句炳参数</span><br><span class="line"></span><br><span class="line">回复人：　asdmusic8(asdmusic8)　(2001-12-17 10:35:15) 得0分 </span><br><span class="line">我 AfxMessageBox(g); 和MessageBox(g); 都不错。</span><br><span class="line">错的是g.从 2300000000=》1994967296</span><br><span class="line"></span><br><span class="line">回复人：　asdmusic8(asdmusic8)　(2001-12-17 10:36:10) 得0分 </span><br><span class="line">是2300000000=》-1994967296 类型转换错。</span><br><span class="line"></span><br><span class="line">回复人：　ydogg(灰毛兔频频)　(2001-12-17 10:37:54) 得6分 </span><br><span class="line">g.Format(&quot;%u&quot;,f);</span><br><span class="line"></span><br><span class="line">回复人：　asdmusic8(asdmusic8)　(2001-12-17 10:40:24) 得0分 </span><br><span class="line">to dgsnmpoperate 那怎么从 CString ==&gt;&gt;unsigned int </span><br><span class="line">回复人：　kingfish(今飞)　(2001-12-17 10:42:10) 得6分 </span><br><span class="line">既然是 unsigned int,</span><br><span class="line">超过 0x7f000000 (2130706432) 当然不能用 %d (signed int)用%u </span><br><span class="line">回复人：　kingfish(今飞)　(2001-12-17 10:44:57) 得8分 </span><br><span class="line">CString ==&gt;&gt;unsigned int  </span><br><span class="line">char *p = (LPSTR)(LPCSTR) g;</span><br><span class="line">f = atoi(p); </span><br><span class="line"></span><br><span class="line">13。static_cast、dynamic_cast 和直接类型转换（如 (void *)p ）的区别?</span><br><span class="line">发表时间：2001-12-14 9:31:13</span><br><span class="line"></span><br><span class="line">先拷贝MSDN中的一小段话：</span><br><span class="line">class B &#123; ... &#125;;</span><br><span class="line">class C : public B &#123; ... &#125;;</span><br><span class="line">class D : public C &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">void f(D* pd)</span><br><span class="line">&#123;</span><br><span class="line">C* pc = dynamic_cast&lt;C*&gt;(pd); // ok: C is a direct base class</span><br><span class="line">// pc points to C subobject of pd </span><br><span class="line"></span><br><span class="line">B* pb = dynamic_cast&lt;B*&gt;(pd); // ok: B is an indirect base class</span><br><span class="line">// pb points to B subobject of pd </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">我已经知道 static_cast 和 dynamic_cast 的作用，但MSDN中并没有提到这两个操作符与直接类型转换如</span><br><span class="line">void f(D* pd)</span><br><span class="line">&#123;</span><br><span class="line">C* pc = （C*）(pd);</span><br><span class="line"></span><br><span class="line">B* pb = （B*）(pd); </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">的不同啊。不知道那位知道的告诉一声，在此不胜感谢，50分奉上。</span><br><span class="line"></span><br><span class="line">回复贴子：ysdesigned(清泉)　(2001-12-14 10:03:07) 得0分 </span><br><span class="line">static_cast、dynamic_cast 代 替 简 单 的 强 制 转 化， 从 而 消 除 多 继 承 带 来 的 歧 义。 使 用 这 两 个 运 算 符 号， 我 们可以 在 对 象 运 行 过 程 中 获 取 对 象 的 类 型 信 息</span><br><span class="line">dynamic_cast 用于多态类型的转换</span><br><span class="line">static_cast 用于非多态类型的转换</span><br><span class="line"></span><br><span class="line">回复人：　masterz()　(2001-12-14 10:05:48) 得0分 </span><br><span class="line">static_cast&lt;...&gt;compile时能发现不正确的指针类型转换</span><br><span class="line">dynamic_cast&lt;...&gt;运行时如果发现是不正确的指针类型转换会返回NULL</span><br><span class="line">(void*)强制转换，如果是不正确的指针类型转换，没有办法检查，不如上面2中安全 </span><br><span class="line">回复人：　meady()　(2001-12-14 11:29:05) 得0分 </span><br><span class="line">类型安全 </span><br><span class="line">回复人：　bluecrest(为什么我的VC还是那么的菜)　(2001-12-14 11:45:34) 得0分 </span><br><span class="line">com技术内幕介绍过</span><br><span class="line">我刚看完就忘了 </span><br><span class="line"></span><br><span class="line">14。byte数据类型转换成int型??</span><br><span class="line">我用byte型读进一组数据想把他转成int型进行运算如何做呢?</span><br><span class="line">如果再把int型转回byte又怎么实现呢? </span><br><span class="line"></span><br><span class="line">回复人：　louifox(兰陵笑笑生)　(2001-12-6 9:18:38) 得0分 </span><br><span class="line">用下面这些宏：</span><br><span class="line">WORD MAKEWORD(</span><br><span class="line">BYTE bLow, </span><br><span class="line">BYTE bHigh </span><br><span class="line">);</span><br><span class="line">BYTE LOBYTE(</span><br><span class="line">WORD wValue </span><br><span class="line">);</span><br><span class="line">BYTE HIBYTE(</span><br><span class="line">WORD wValue </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">回复人：　chskim(大刀阔斧)　(2001-12-6 9:21:04) 得0分 </span><br><span class="line">int i;</span><br><span class="line">BYTE b;</span><br><span class="line">b=128;</span><br><span class="line">i=(int)b;</span><br><span class="line"></span><br><span class="line">回复人：　nannet(似的)　(2001-12-6 9:38:24) 得0分 </span><br><span class="line">这个宏怎么用呀?有没有简单一点儿的，我现在能把BYTE 转成INT 型了，再转回去直接赋值可以吗？ </span><br><span class="line">回复人：　louifox(兰陵笑笑生)　(2001-12-6 9:46:24) 得20分 </span><br><span class="line">WORD wa;</span><br><span class="line">BYTE ba=32,bb=64;</span><br><span class="line">wa=MAKEWORD(ba,bb);</span><br><span class="line">...</span><br><span class="line">WORD wa=1234;</span><br><span class="line">BYTE ba,bb;</span><br><span class="line">ba=LOBYTE(wa);</span><br><span class="line">bb=LOBYTE(wa);</span><br><span class="line"></span><br><span class="line">回复人：　nannet(似的)　(2001-12-6 9:54:55) 得0分 </span><br><span class="line">问题解决了，多谢各位 </span><br><span class="line"></span><br><span class="line">15。类型转换的问题，unsigned int --&gt; lptstr/lpctstr??</span><br><span class="line">发表时间：2001-8-7 23:49:41</span><br><span class="line">如果强制转换的话，会出现致命错误，有什么好的办法呢？</span><br><span class="line">能列举一些其他的办法吗？</span><br><span class="line">谢谢大虾！ </span><br><span class="line"></span><br><span class="line">回复人：　AlphaOne(总是第一个倒下)　(2001-8-8 0:02:43) 得5分 </span><br><span class="line">你为什么要强行转换呢？</span><br><span class="line">如果你是要把int 的值作为 lptstr/lpctstr 的内容的话，</span><br><span class="line">可以用CString:</span><br><span class="line">unsigned int a = 100;</span><br><span class="line">LPCTSTR lpText;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(&quot;%d&quot;,a);</span><br><span class="line">lpText = (LPCTSTR)str;</span><br><span class="line"></span><br><span class="line">回复人：　tryibest(编の魂)　(2001-8-8 8:20:20) 得5分 </span><br><span class="line">wsprintf(str,&quot;%u&quot;,ui); </span><br><span class="line">回复人：　zzh()　(2001-8-8 9:04:39) 得5分 </span><br><span class="line">这种情况不需要进行强制转换，直接使用wsprintf就可以了。 </span><br><span class="line">回复人：　GJA106(中文字符)　(2001-8-8 10:10:51) 得5分 </span><br><span class="line">unsigned int m_na=22;</span><br><span class="line">LPTSTR lptstr;</span><br><span class="line">wsprintf(lptstr,&quot;%u&quot;,m_na);</span><br><span class="line"></span><br><span class="line">16。关于COM类型转换问题??</span><br><span class="line">我定义了两个变量，一个是void *piaRef=new unsigned char[1000];另一个是m_Temp=new CComVariant();我的问题是如何将piaRef中的值</span><br><span class="line">COPY到m_Temp中。 </span><br><span class="line"></span><br><span class="line">回复人：　nichang()　(2001-11-21 15:34:04) 得0分 </span><br><span class="line">CComBSTR bsRef=piaRef;</span><br><span class="line">m_Temp=bsRef.copy() </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-21 17:04:24) 得0分 </span><br><span class="line">CComBSTR bsRef=piaRef;</span><br><span class="line">//error C2440: &apos;initializing&apos; : cannot convert from &apos;void *&apos; to &apos;class ATL::CComBSTR&apos;</span><br><span class="line">m_Temp=bsRef.copy();</span><br><span class="line">//error C2440: &apos;=&apos; : cannot convert from &apos;unsigned short *&apos; to &apos;class ATL::CComVariant *&apos; </span><br><span class="line">回复人：　nichang()　(2001-11-21 17:14:28) 得0分 </span><br><span class="line">将void*改为unsigned char * </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-21 17:22:22) 得0分 </span><br><span class="line">我用CComBSTR bsRef=(unsigned char*)piaRef，也不行吗？ </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-21 17:28:06) 得0分 </span><br><span class="line">会报错：</span><br><span class="line">error C2440: &apos;type cast&apos; : cannot convert from &apos;unsigned char *&apos; to &apos;class ATL::CComBSTR&apos; </span><br><span class="line">回复人：　nichang()　(2001-11-22 9:12:14) 得0分 </span><br><span class="line">m_Temp=::SysAllocString((OLECHAR *)piaRef) </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 10:43:07) 得0分 </span><br><span class="line">//error C2440: &apos;=&apos; : cannot convert from &apos;unsigned short *&apos; to &apos;class ATL::CComVariant *&apos; </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 11:22:35) 得0分 </span><br><span class="line">m_Temp=new CComVariant(::SysAllocString(OLECHAR *)piaRef));没有出错，但是我的m_Temp是COM组件中的一个PROPERTY，我想返回的是</span><br><span class="line">unsigned char类型（单字节），但经过上述转换后，就不再是单字节了呀！怎么办？ </span><br><span class="line">回复人：　jiangsheng(蒋晟)　(2001-11-22 11:36:58) 得0分 </span><br><span class="line">把这个属性的类型改成BSTR </span><br><span class="line">回复人：　GrayWhite(灰白)　(2001-11-22 12:01:09) 得0分 </span><br><span class="line">m_Temp = new CComVariant((char*) piaRef);就可以了。VB就是用的BSTR,你要给谁用阿？VC不用VARIANT的。 </span><br><span class="line">回复人：　GrayWhite(灰白)　(2001-11-22 12:18:18) 得19分 </span><br><span class="line">哦，我明白了，你要各字节数组：</span><br><span class="line">SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, 1000);</span><br><span class="line">if (!psa)</span><br><span class="line">_com_issue_error(ERROR_NOT_ENOUGH_MEMORY);</span><br><span class="line"></span><br><span class="line">HRESULT hr</span><br><span class="line">for (long i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if (FAILED (hr = SafeArrayPutElement(psa, &amp;i, piaRef + i)))</span><br><span class="line">_com_issue_error(hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_variant_t va; // include &lt;comdef.h&gt;</span><br><span class="line">va.vt = VT_ARRAY | VT_UI1;</span><br><span class="line">va.parray = psa;</span><br><span class="line"></span><br><span class="line">m_Temp = new CComVariant(va); </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 14:21:08) 得0分 </span><br><span class="line">SafeArrayPutElement(psa, &amp;i, piaRef + i)</span><br><span class="line">//error C2036: &apos;void *&apos; : unknown size </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 14:46:05) 得0分 </span><br><span class="line">To GrayWhite:为什么要for(long i=0;i&lt;2;i++)? </span><br><span class="line">回复人：　nichang()　(2001-11-22 15:16:35) 得0分 </span><br><span class="line">到底你想怎样转换嘛，是将数组内的值拷贝到CComVariant中存为字符串吗? </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 15:28:35) 得0分 </span><br><span class="line">我是想把piaRef中的值照原样返回给其它程序使用。我正在做的是一个COM组件。谢谢各位！ </span><br><span class="line">回复人：　nichang()　(2001-11-22 15:34:40) 得10分 </span><br><span class="line">unsigned char *s=new unsigned char[1000];</span><br><span class="line">strcpy((char*)s,&quot;1234&quot;);//可以用你自己方法设置s中的值。</span><br><span class="line">BSTR bstrS;</span><br><span class="line">oleS=A2WBSTR((char*)s);//将char*转换成BSTR类型</span><br><span class="line"></span><br><span class="line">CComVariant comVT;</span><br><span class="line">comVT=oleS;//将BSTR转成CComVariant,这里一步也可，comVT=A2WBSTR((char*)s);</span><br><span class="line"></span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-22 16:54:07) 得0分 </span><br><span class="line">谢谢你！</span><br><span class="line">但我还有一个问题，就是如果在s中有&apos;/0&apos;之类的东西我该怎么返回呢？char *遇到&apos;/0&apos;会认为到头了。完整的设计是这样的，我定义一个void * 用来从一个外部设备获取数据，该数据应该是unsigned char，我想把这个返回的数据作为属性传出，让其它应用使用（如VB）。 </span><br><span class="line">回复人：　nichang()　(2001-11-22 17:18:09) 得0分 </span><br><span class="line">将&apos;/0&apos;转换成其它如&apos;/1&apos;就OK了， </span><br><span class="line">回复人：　jiangsheng(蒋晟)　(2001-11-22 18:07:16) 得0分 </span><br><span class="line">用字符串数组 </span><br><span class="line">回复人：　VincentChin(瘟神)　(2001-11-23 15:54:39) 得0分 </span><br><span class="line">谢谢各位的回复！我的问题解决了！如下：</span><br><span class="line">SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, 1000);</span><br><span class="line">if (!psa)</span><br><span class="line">return S_FALSE;</span><br><span class="line">HRESULT hr;</span><br><span class="line">for (long i = 0; i &lt; 1000; i ++)</span><br><span class="line">if (FAILED (hr = SafeArrayPutElement(psa, &amp;i, ((unsigned char*)piaRefTemplate) + i)))</span><br><span class="line">return S_FALSE;</span><br><span class="line">VARIANT va;</span><br><span class="line">va.vt = VT_ARRAY | VT_UI1;</span><br><span class="line">va.parray = psa;</span><br><span class="line">CComVariant *m_Temp = new CComVariant();</span><br><span class="line">m_Temp-&gt;Copy(&amp;va);</span><br><span class="line"></span><br><span class="line">17。类型转换 static_cast reinterprete_cast 的区别??</span><br><span class="line">static_cast reinterprete_cast 的区别 </span><br><span class="line"></span><br><span class="line">回复人：　tar(GPS)　(2001-11-21 10:06:41) 得0分 </span><br><span class="line">static_cast会检查转换类型健的相关性</span><br><span class="line">如果没有的画会有编译错误</span><br><span class="line">reinterprete_cast就是硬转了 </span><br><span class="line">回复人：　tigerwoods(tao)　(2001-11-21 12:28:19) 得0分 </span><br><span class="line">是否可以这样理解：在多重继承中，static_cast可实现对象指针的移动，从而指向正确的父类对象部分，而reinterprete_cast不作偏移？ </span><br><span class="line">回复人：　liu_feng_fly(我恨死驱动程序了，哎，就是为了混口饭吃)　(2001-11-21 12:35:14) 得0分 </span><br><span class="line">在多重继承中可以用dynamic_cast啊 </span><br><span class="line"></span><br><span class="line">18。那如何取得CString中的字符串？？</span><br><span class="line">回复人：　nichang()　(2001-11-5 17:06:00) 得0分 </span><br><span class="line">=(LPCTSTR)CString变量 </span><br><span class="line">回复人：　snake1122(领悟)　(2001-11-5 17:12:16) 得0分 </span><br><span class="line">方法太多了:</span><br><span class="line">GetAt,Left,Mid,Right等等，就看你怎么取了！ </span><br><span class="line">回复人：　dusb(保时捷)　(2001-11-5 17:34:29) 得0分 </span><br><span class="line">可是不管是GetAt，Left，Mid，Right返回类型都是CString，还是不能用，我是要取其中的字符串，奇怪的是，VC中没有string类型。（我要的字符串是给树型控件中的分支名称） </span><br><span class="line">回复人：　Alps_lou(云飞扬)　(2001-11-5 17:41:36) 得0分 </span><br><span class="line">有string类型的啊，要包含&lt;string&gt; </span><br><span class="line">回复人：　luxes()　(2001-11-5 17:42:19) 得0分 </span><br><span class="line">加上(LPCTSTR)，相当于一个const char *了，还不能用？ </span><br><span class="line">回复人：　wt007(tt)　(2001-11-5 17:48:33) 得0分 </span><br><span class="line">GetBuffer </span><br><span class="line">回复人：　espon99()　(2001-11-5 17:54:06) 得20分 </span><br><span class="line">(LPSTR)(LPCTSTR)</span><br><span class="line"></span><br><span class="line">回复人：　ineedyou(古寺僧)　(2001-11-5 17:59:29) 得0分 </span><br><span class="line">...m_str.GetBuffer(needlen)...;</span><br><span class="line">....</span><br><span class="line">m_str.ReleaseBuffer() </span><br><span class="line">回复人：　dusb(保时捷)　(2001-11-6 15:08:36) 得0分 </span><br><span class="line">espon99大侠，果然是绝招，不过能否解释一下啊？ </span><br><span class="line"></span><br><span class="line">19。如何从CString类型转换为Unicode string 类型？</span><br><span class="line">回复人：　ychener(贫血)　(2001-10-20 10:28:48) 得0分 </span><br><span class="line">CString本身就支持Unicode的。 </span><br><span class="line">只要你选择的是UniCode编译，生成的可执行程序就是支持UniCode的 </span><br><span class="line"></span><br><span class="line">回复人：　ychener(贫血)　(2001-10-20 10:30:04) 得0分 </span><br><span class="line">CString类是自适应的就像TCHAR一样，如果你定义了UniCode宏 就会以UniCode编译 </span><br><span class="line"></span><br><span class="line">回复人：　xjl1980_81(阿龙)　(2001-10-20 10:35:16) 得0分 </span><br><span class="line">不是呀，我有个函数中有一个参数需Unicode string 类型的，比如应该填L&quot;abc&quot;,而且引号中的内容要有变化，现在我有一个 temp变量，是CString类型的，如何用呀？ </span><br><span class="line">回复人：　xt_jat(桑巴)　(2001-10-20 10:39:37) 得0分 </span><br><span class="line">_T()</span><br><span class="line">_TEXT()</span><br><span class="line">行不行？ </span><br><span class="line">回复人：　xjl1980_81(阿龙)　(2001-10-20 10:43:18) 得0分 </span><br><span class="line">不行 </span><br><span class="line">回复人：　Jeffery__Chen()　(2001-10-20 11:04:53) 得0分 </span><br><span class="line">强制转化：</span><br><span class="line">CString temp;</span><br><span class="line">WCHAR wTemp = (WCHAR)temp; </span><br><span class="line">回复人：　xjl1980_81(阿龙)　(2001-10-20 11:37:06) 得0分 </span><br><span class="line">to:Jeffery__Chen()　</span><br><span class="line">不对呀，出现不能转换的错误 </span><br><span class="line">回复人：　hongzhh(关儿)　(2001-10-20 11:39:42) 得0分 </span><br><span class="line">问题是这样的：</span><br><span class="line">temp 是 CString类型变量，值为zhh</span><br><span class="line">现在有一个API </span><br><span class="line">PCCERT_CONTEXT WINAPI CertFindCertificateInStore(</span><br><span class="line">HCERTSTORE hCertStore, </span><br><span class="line">DWORD dwCertEncodingType, </span><br><span class="line">DWORD dwFindFlags, </span><br><span class="line">DWORD dwFindType, </span><br><span class="line">const void *pvFindPara, //此处用 L&quot;zhh&quot; 没问题 </span><br><span class="line">//请问怎么转换 可以 用temp</span><br><span class="line"></span><br><span class="line">PCCERT_CONTEXT pPrevCertContext </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">在此谢谢大家，请帮忙看看</span><br><span class="line"></span><br><span class="line">回复人：　hongzhh(关儿)　(2001-10-20 13:27:10) 得0分 </span><br><span class="line">WCHAR wszDomain[256]; </span><br><span class="line">MultiByteToWideChar( CP_ACP, 0, temp,</span><br><span class="line">strlen(temp)+1, wszUserName, </span><br><span class="line">sizeof(wszUserName)/sizeof(wszUserName[0]) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wszUserName就是转换后的值</span><br><span class="line"></span><br><span class="line">回复人：　ychener(贫血)　(2001-10-23 11:43:05) 得0分 </span><br><span class="line">只要你用的是CString的函数就行的，如果你要用类似strcpy函数时，看看MSDN中一般情况下都有响应的函数对于Unicode的。只要换成_tcscpy等等。 </span><br><span class="line">回复人：　ychener(贫血)　(2001-10-23 11:44:10) 得0分 </span><br><span class="line">你有没有定义Unicode宏？  </span><br><span class="line">20。请问在用ATL且不支持MFC的组件开发中，如何将从数据库中读到的DATE数据类型转换回为字符串?? </span><br><span class="line"></span><br><span class="line">复人：　zhxuys(zhxuys)　(2001-9-24 10:36:47) 得0分 </span><br><span class="line">ATL把datetime类型的列映射为DBTIMESTAMP类型，可取出该类型的year、month、day等，然后将这些数据传递回客户端，在客户端用CTime来构造 </span><br><span class="line">回复人：　YUANXU(旭)　(2001-9-24 11:18:14) 得0分 </span><br><span class="line">to zhxuys:CTime是MFC类，在ATL 不支持MFC时不能用。DATE其实质是个double* </span><br><span class="line">回复人：　zhxuys(zhxuys)　(2001-9-24 11:57:01) 得0分 </span><br><span class="line">你在客户端与服务器端只用ATL规定的数据类型或VARIANT类型，而在客户端，可以用MFC来重新构造想要的数据结构 </span><br><span class="line"></span><br><span class="line">21。类型转换，CString to wchar_t ??</span><br><span class="line"></span><br><span class="line">CString ss(&quot;aabb&quot;);</span><br><span class="line">wchar_t* cc;</span><br><span class="line">cc=ss.AllocSysString();</span><br><span class="line"></span><br><span class="line">22。如何将CString类型转换为_bstr_t类型？</span><br><span class="line">回复人：　wei97081116(韦小宝)　(2001-9-4 11:19:30) 得20分 </span><br><span class="line">CString b;</span><br><span class="line">_bstr_t a;</span><br><span class="line">a=(_bstr_t)b; </span><br><span class="line"></span><br><span class="line">回复人：　zhaozhen1212(赵振)　(2001-9-18 1:30:18) 得0分 </span><br><span class="line">_bstr_t a=b.AllocSysString();;</span><br><span class="line"></span><br><span class="line">23。如何把一个CString类型转换成一个普通的字符串，如char*?</span><br><span class="line"></span><br><span class="line">回复人：　liu_feng_fly(我恨死驱动程序了，哎，就是为了混口饭吃)　(2001-9-17 18:00:52) 得0分 </span><br><span class="line">所以，直接用就可以，因为类里边有这样的转换函数 </span><br><span class="line">回复人：　ydogg(灰毛兔频频)　(2001-9-17 18:01:21) 得0分 </span><br><span class="line">CString show;</span><br><span class="line"></span><br><span class="line">char *p = show.GetBuffer(show.GetLength()); </span><br><span class="line">回复人：　jiangping_zhu(娜可露露之风之刃)　(2001-9-17 18:02:05) 得0分 </span><br><span class="line">(char*)(LPCTSTR)str </span><br><span class="line">回复人：　bmouse(老鼠)　(2001-9-18 0:10:56) 得0分 </span><br><span class="line">同意楼上! </span><br><span class="line">回复人：　bmouse(老鼠)　(2001-9-18 0:13:22) 得0分 </span><br><span class="line">你还可以通过GetBuff来直接操作CString的缓冲区,不过要记着释放缓冲区. </span><br><span class="line"></span><br><span class="line">24。CString 类型转换成 unsigned char类型吗？？</span><br><span class="line">回复人：　LJN(*)风流倜傥无人及，玉树偏又临风立(*)　(2001-9-17 12:46:01) 得0分 </span><br><span class="line">可以用CString.GetBuffer函数 </span><br><span class="line">回复人：　xpmao()　(2001-9-17 13:09:09) 得0分 </span><br><span class="line">CString strWork;</span><br><span class="line">MessageBox(0,(LPSTR)strWork,0,0);</span><br><span class="line">或MessageBox(0,strWork.GetBuffer(0),0,0);</span><br><span class="line"></span><br><span class="line">回复人：　sandd(降龙掌)　(2001-9-17 13:17:32) 得0分 </span><br><span class="line">CString string;</span><br><span class="line"></span><br><span class="line">(LPCTSTR)string; </span><br><span class="line">回复人：　jeff_hunter(PandaLee)　(2001-9-17 13:45:30) 得0分 </span><br><span class="line">(unsigned char *)(LPCTSTR) </span><br><span class="line">回复人：　fandh(好了)　(2001-9-17 14:00:57) 得0分 </span><br><span class="line">用(unsigned char *)(LPCTSTR)即可  </span><br><span class="line">回复人：　ygd(ygd)　(2001-9-17 16:11:17) 得0分 </span><br><span class="line">unsigned char *p;</span><br><span class="line">CString str;</span><br><span class="line">int length=str.GetLength();</span><br><span class="line">for(int i=0;i&lt;length;i++)</span><br><span class="line">p[i]=str.GetAt(i); </span><br><span class="line">回复人：　swordbroken(断剑书生)　(2001-9-17 16:25:57) 得0分 </span><br><span class="line">CString str;</span><br><span class="line">unsigned char string[30];</span><br><span class="line">strcpy(string,str); </span><br><span class="line"></span><br><span class="line">25。何将一个unsigned int 类型变量值赋给类型为unsigned short的变量，并保证数值不丢失（当然数值在一定范围内)？</span><br><span class="line">回复人：　maxsuy(魔法师兔子)　(2001-8-14 16:37:30) 得0分 </span><br><span class="line">直接=就OK了 </span><br><span class="line">回复人：　oppmm(ppmm)　(2001-8-14 16:38:11) 得0分 </span><br><span class="line">直接赋值 </span><br><span class="line">回复人：　milefo(弥勒佛)　(2001-8-14 16:40:40) 得0分 </span><br><span class="line">如果数值在一定范围内怎么回丢失呢？</span><br><span class="line">unsigned short a;</span><br><span class="line">unsigned int b;</span><br><span class="line">a=( b &amp; 0xffff);</span><br><span class="line">你试试看吧！</span><br><span class="line"></span><br><span class="line">26。CString ----char* </span><br><span class="line">定义了char* aa的变量，现在有一个CString的变量bb，怎样把bb的值赋给aa呢? </span><br><span class="line"></span><br><span class="line">回复人：　emmai(WaTaXiWaWaTaXi)　(2001-8-10 11:57:33) 得0分 </span><br><span class="line">aa=bb.GetBuffer(); </span><br><span class="line">回复人：　hswqs(??????????????????)　(2001-8-10 11:59:01) 得0分 </span><br><span class="line">aa= (LPSTR)(LPCTSTR)bb; </span><br><span class="line">回复人：　ydogg(灰毛兔)　(2001-8-10 12:27:23) 得0分 </span><br><span class="line">1.aa=bb.GetBuffer(bb.GetLenth());//第一种方法</span><br><span class="line">2.aa= (LPSTR)(LPCTSTR)bb; //第二种方法 </span><br><span class="line">回复人：　zhizhi()　(2001-8-10 13:16:23) 得0分 </span><br><span class="line">aa= (char *)(LPCTSTR)bb,hehe </span><br><span class="line"></span><br><span class="line">27。在一个COM的接口函数中有一个 BSTR* 类型的参数，需要把一个 char * 类型转换为 BSTR* 类型，不知道如何转换？ 由于调用这个函数后需要把这个参数值再取出来所以只能用指针，另外在调用的时候应该用什么类型的数据传递参数呢？大虾帮忙。</span><br><span class="line"></span><br><span class="line">BSTR bstr = SysAllocString(L&quot;字符串&quot;);</span><br><span class="line">这样转换,用的时候你用地址操作符&amp;啊，要不指针还得new </span><br><span class="line"></span><br><span class="line">回复人：　yongyue2000i(小吕)　(2001-9-9 18:38:26) 得13分 </span><br><span class="line">CString str = &quot;abcd&quot;;</span><br><span class="line">BSTR bstr = str.AllocSysString(); </span><br><span class="line">回复人：　houjzs()　(2001-9-9 19:14:44) 得13分 </span><br><span class="line">BSTR b = SysAllocString(OLESTR(&quot;your string&quot;));</span><br><span class="line"></span><br><span class="line">28。要把一个double的数字输出到CEdit控件是否需要类型转换？</span><br><span class="line">回复人：　jiangsheng(蒋晟)　(2001-8-24 14:46:17) 得0分 </span><br><span class="line">void AFXAPI DDX_Text( CDataExchange* pDX, int nIDC, double&amp; value ); </span><br><span class="line">回复人：　xiezhsh(雪中行)　(2001-8-24 14:56:22) 得0分 </span><br><span class="line">假如你的ＣＥｄｉｔ相关的成员变量是Ｄｏｕｂｌｅ型的，那根本用不着．（ＣｌａｓｓＷｉｚａｒｄ增加成员变量的对话框中，Variable Type选择Double可） </span><br><span class="line">回复人：　xiezhsh(雪中行)　(2001-8-24 14:58:16) 得0分 </span><br><span class="line">假如你的ＣＥｄｉｔ相关的成员变量不是Ｄｏｕｂｌｅ型的，是ＣＳｔｒｉｎｇ型，那就需要用ltoa()来转换成ＣＳｔｒｉｎｇ型， </span><br><span class="line">回复人：　haven(大天)　(2001-8-24 14:58:32) 得0分 </span><br><span class="line">m_Edit.Fromat(&quot;%l&quot;,VarBouble);</span><br><span class="line">updatedata(false); </span><br><span class="line">回复人：　12345678()　(2001-8-24 14:59:54) 得0分 </span><br><span class="line">CString m_Edit.Format(&quot;%lf&quot;, doubleVar); </span><br><span class="line">GetDlgItem(EditID)-&gt;SetWindowText(m_strEdit); </span><br><span class="line"></span><br><span class="line">29。该如何把 WINDOWPLACEMENT * 转换成 char **类型??</span><br><span class="line"></span><br><span class="line">(char**)&amp;pWP </span><br><span class="line"></span><br><span class="line">30。怎样把CString的类型转换成char*型的？</span><br><span class="line">回复人：　dcz(dcz)　(2001-8-19 19:13:27) 得5分 </span><br><span class="line">// str is CString var</span><br><span class="line">char* temp = strdup(str);</span><br><span class="line">...</span><br><span class="line">free(temp); </span><br><span class="line">回复人：　yu900(疾风之狼)　(2001-8-19 19:57:25) 得0分 </span><br><span class="line">getbuffer()；即可！ </span><br><span class="line">回复人：　aileen_long(挑战2001)　(2001-8-19 21:10:35) 得0分 </span><br><span class="line">同意楼上的意见！ </span><br><span class="line">回复人：　czh912()　(2001-8-19 21:27:08) 得0分 </span><br><span class="line">char buf[20];</span><br><span class="line">printf(buf,&quot;%s&quot;,string);</span><br><span class="line"></span><br><span class="line">回复人：　casl(casl)　(2001-8-19 22:59:44) 得5分 </span><br><span class="line">CString s(&quot;abc&quot;);</span><br><span class="line">char* temp=s.GetBuffer(10);</span><br><span class="line">...</span><br><span class="line">s.ReleaseBuffer(); </span><br><span class="line">回复人：　cocia(高亚)　(2001-8-19 23:04:23) 得0分 </span><br><span class="line">char* temp=s.GetBuffer(10);</span><br><span class="line">10是什么意思啊</span><br><span class="line"></span><br><span class="line">回复人：　kevin_dong(梦仙人)　(2001-8-20 10:26:35) 得0分 </span><br><span class="line">// str is CString var</span><br><span class="line">char* temp = strdup(str);</span><br><span class="line">// free</span><br><span class="line">free(temp); </span><br><span class="line">我的这段代码在一个程序中能通过编译，但是在另外一个中总是出现cannot convert parameter 1 from &apos;class CString&apos; to &apos;const char *&apos;的错误。str和temp的类型都一样。这是为什么？</span><br><span class="line"></span><br><span class="line">回复人：　dcz(dcz)　(2001-8-20 14:13:45) 得0分 </span><br><span class="line">you may setting your compiler option to UNICODE, in this case, declare the var:</span><br><span class="line"></span><br><span class="line">// str is CString var</span><br><span class="line">_TCHAR* temp = _tcsdup(str);</span><br><span class="line"></span><br><span class="line">// free</span><br><span class="line">free(str);</span><br><span class="line"></span><br><span class="line">31。SA,SB为两个结构类型??</span><br><span class="line">SA* A;</span><br><span class="line">SB* B;</span><br><span class="line">(SB*)A-&gt;...（调用函数）</span><br><span class="line">请问此时A的类型，是指向SA还是SB</span><br><span class="line">此时编译器是生成一个临时指针吗？</span><br><span class="line">另外，</span><br><span class="line">B=(SB*)A;此时A又是什么类型？？？</span><br><span class="line"></span><br><span class="line">回复贴子： </span><br><span class="line">回复人：　ddeng(登登)　(2001-8-9 17:13:58) 得0分 </span><br><span class="line">A的类型始终是SA *</span><br><span class="line">B的类型始终是SB *</span><br><span class="line">当进行强制类型转换时使的是临时指针 </span><br><span class="line">回复人：　gold_water(风雨无阻)　(2001-8-9 17:30:46) 得0分 </span><br><span class="line">同意楼上的。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line">32。char buff[100],char UserName[50][100],怎么将buff的值传给UserName，是其成为UserName数组中的某一项呢？？</span><br><span class="line"></span><br><span class="line">//0=&lt;i&lt;50</span><br><span class="line">strcpy(UserName[i],buff); </span><br><span class="line">回复人：　Ashura(阿修罗)　(2001-7-26 10:08:20) 得0分 </span><br><span class="line">呵呵，benbensan抢先一步。 </span><br><span class="line">回复人：　tuita(斗牛士)　(2001-7-26 10:13:22) 得0分 </span><br><span class="line">for (i=0;i&lt;100;i++)</span><br><span class="line">*(*(username+x)+i)=*(buffer+i)</span><br><span class="line">其中0《X〈50</span><br><span class="line">benbensan写的也对</span><br><span class="line"></span><br><span class="line">回复人：　kekeke(我是来向大家学习的)　(2001-7-26 10:24:22) 得0分 </span><br><span class="line">那反过来呢？把UserName中的某一项读出赋值给buff呢？怎么弄？ </span><br><span class="line">回复人：　benbensan(笨笨三)　(2001-7-26 10:26:53) 得0分 </span><br><span class="line">//0=&lt;i&lt;50</span><br><span class="line">strcpy(UserName[i],buff); </span><br><span class="line">回复人：　benbensan(笨笨三)　(2001-7-26 10:28:15) 得0分 </span><br><span class="line">对不起，能错了，不过建议你看一下C语言了的指针和数组</span><br><span class="line">//0=&lt;i&lt;50</span><br><span class="line">strcpy(buff,UserName[i]); </span><br><span class="line"></span><br><span class="line">回复人：　jfzsl(剿匪总司令)　(2001-7-26 10:32:57) 得0分 </span><br><span class="line">好好看看老潭的书先！OK？ </span><br><span class="line">回复人：　kekeke(我是来向大家学习的)　(2001-7-26 10:44:25) 得0分 </span><br><span class="line">好。。。。！ </span><br><span class="line"></span><br><span class="line">33。请问怎样把SYSTEMTIME类型转换成time_t类型?</span><br><span class="line">SYSTEMTIME st;</span><br><span class="line">GetLocalTime(&amp;st);</span><br><span class="line">CTime tm(st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);</span><br><span class="line">time_t t = tm.GetTime();</span><br><span class="line"></span><br><span class="line">34。unsigned char Exponent[10]; //e</span><br><span class="line">unsigned long eBytes; //e的字节数</span><br><span class="line">如何转换成DWord型! ??</span><br><span class="line"></span><br><span class="line">用强制类型转换呀</span><br><span class="line">(DWord)eBeytes;</span><br><span class="line">(DWord)Exponent[i];//(0&lt;=i&lt;=10);</span><br><span class="line"></span><br><span class="line">回复人：　xjl1980_81(阿龙)　(2001-7-26 16:47:29) 得0分 </span><br><span class="line">我是说把e转换成DWORD型</span><br><span class="line">也就是说把Exponent中的内容转换成DWORD型</span><br><span class="line"></span><br><span class="line">回复人：　cloudshadow1(云影)　(2001-7-26 17:13:30) 得0分 </span><br><span class="line">用强制类型转换就可以了，（DWORD的高24位自动加0）</span><br><span class="line">DWORD Des[10]</span><br><span class="line">for (int i=0;i&lt;11;i++)</span><br><span class="line">Des[i]=Exponent[i];</span><br><span class="line">至于那个ULONG的也是用强制类型软换就可以了</span><br><span class="line"></span><br><span class="line">35。请问怎样把time_t类型转换成SYSTEMTIME类型？</span><br><span class="line">回复人：　haven(大天)　(2001-7-26 17:12:36) 得0分 </span><br><span class="line">typedef struct _SYSTEMTIME</span><br><span class="line">typedef long time_t</span><br><span class="line">很明显不行嘛！ </span><br><span class="line">回复人：　facexy(FACE仔)　(2001-7-26 17:17:38) 得0分 </span><br><span class="line">哎呀，问错了，前后对象相反了；-（</span><br><span class="line">忙昏了的结果…………</span><br><span class="line"></span><br><span class="line">另外，TO 楼上的：</span><br><span class="line">转换是可以的</span><br><span class="line">struct tm *tblock;</span><br><span class="line">SYSTEMTIME SystemTime;</span><br><span class="line">memset(&amp;SystemTime,0,sizeof(SYSTEMTIME));</span><br><span class="line">tblock=localtime(&amp;timer);</span><br><span class="line">SystemTime.wYear=tblock-&gt;tm_year+1900;</span><br><span class="line">SystemTime.wMonth=tblock-&gt;tm_mon+1;</span><br><span class="line">SystemTime.wDay=tblock-&gt;tm_mday;</span><br><span class="line">SystemTime.wHour=tblock-&gt;tm_hour;</span><br><span class="line">SystemTime.wMinute=tblock-&gt;tm_min;</span><br><span class="line">SystemTime.wSecond=tblock-&gt;tm_sec;</span><br><span class="line">SystemTime.wDayOfWeek=tblock-&gt;tm_wday;</span><br><span class="line">return &amp;SystemTime; </span><br><span class="line">回复人：　zjh73(大章鱼)　(2001-7-26 20:28:28) 得0分 </span><br><span class="line">有两种方法：</span><br><span class="line">1、用CTime类</span><br><span class="line">先用time_t类型构造一个CTime对象，再定义一个SYSTEMTIME结构，最后用CTime类的成员函数GetAsSystemTime将时间转换到SYSTEMTIME结构中</span><br><span class="line">即可。</span><br><span class="line">2、用gmtime函数</span><br><span class="line">gmtime函数将time_t时间转换到tm结构中并返回一个tm指针，再将tm结构的相对应的项赋给SYSTEMTIME相对应的项即可，不过用这种方法要注</span><br><span class="line">意这两种结构在天、星期等方面的记数方法有点区别，一个一般从0开始，一个一般从1开始，赋值时要注意校正，还有要注意的是SYSTEMTIME</span><br><span class="line">结构中有一项是毫秒，而time_t是以秒记数的。 </span><br><span class="line">回复人：　zjh73(大章鱼)　(2001-7-26 20:32:13) 得0分 </span><br><span class="line">反过来也可以用Ctime类的方法</span><br><span class="line">就是先用SYSTEMTIME结构构造一个CTime对象，在用CTime类中的成员函数GetTime返回一个对应的time_t即可。 36。我现在正在学习SDK编程，遇到的问题是：</span><br><span class="line">我定义了一个静态长整形变量，</span><br><span class="line">static long lScore=0;</span><br><span class="line">我想把窗口的标题换成长整形数值,用SetWindowText函数来实现，</span><br><span class="line">由于它的第二个参数要求数据类型为 unsigned short *,但用其来实现强制转换时</span><br><span class="line">总是出现编译错误：</span><br><span class="line">cannot convert parameter 2 from &apos;unsigned short *&apos; to &apos;const char *&apos;</span><br><span class="line">后来改成来LPCTSTR 来实现强制转换，没有出现编译错误，但函数总是执行不成功,</span><br><span class="line">请教各位高人，这倒底是怎么回事？？？</span><br><span class="line"></span><br><span class="line">回复贴子： </span><br><span class="line">回复人：　prog_st(st)　(2001-8-4 21:20:07) 得0分 </span><br><span class="line">/* ITOA.C: This program converts integers of various</span><br><span class="line">* sizes to strings in various radixes.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main( void )</span><br><span class="line">&#123;</span><br><span class="line">char buffer[20];</span><br><span class="line">int i = 3445;</span><br><span class="line">long l = -344115L;</span><br><span class="line">unsigned long ul = 1234567890UL;</span><br><span class="line"></span><br><span class="line">_itoa( i, buffer, 10 );</span><br><span class="line">printf( &quot;String of integer %d (radix 10): %s/n&quot;, i, buffer );</span><br><span class="line">_itoa( i, buffer, 16 );</span><br><span class="line">printf( &quot;String of integer %d (radix 16): 0x%s/n&quot;, i, buffer );</span><br><span class="line">_itoa( i, buffer, 2 );</span><br><span class="line">printf( &quot;String of integer %d (radix 2): %s/n&quot;, i, buffer );</span><br><span class="line"></span><br><span class="line">_ltoa( l, buffer, 16 );</span><br><span class="line">printf( &quot;String of long int %ld (radix 16): 0x%s/n&quot;, l, </span><br><span class="line">buffer );</span><br><span class="line"></span><br><span class="line">_ultoa( ul, buffer, 16 );</span><br><span class="line">printf( &quot;String of unsigned long %lu (radix 16): 0x%s/n&quot;, ul,</span><br><span class="line">buffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">String of integer 3445 (radix 10): 3445</span><br><span class="line">String of integer 3445 (radix 16): 0xd75</span><br><span class="line">String of integer 3445 (radix 2): 110101110101</span><br><span class="line">String of long int -344115 (radix 16): 0xfffabfcd</span><br><span class="line">String of unsigned long 1234567890 (radix 16): 0x499602d2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回复人：　lwg7603(刑满释放人员)　(2001-8-4 21:36:15) 得0分 </span><br><span class="line">TCHAR str[255]=&#123;_T(&apos;/0&apos;)&#125;;</span><br><span class="line">_stprintf(str,_T(&quot;%d&quot;),lScore);</span><br><span class="line">SetWindowText(hwnd,str);</span><br><span class="line"></span><br><span class="line">37。我用socket发送的的buf中间需要的是 char *类型的数据，我想将一个 struct 直接转换成 char * 发过去。</span><br><span class="line">我用</span><br><span class="line">struct ABCD *abcd;</span><br><span class="line">char *buf;</span><br><span class="line">abcd = (ABCD *)calloc(1,sizeof(ABCD));</span><br><span class="line">buf = (char *)calloc(1,sizeof(ABCD));</span><br><span class="line">///</span><br><span class="line">给abcd 中间赋值，其中有多个char[]的值和int 的值</span><br><span class="line">///</span><br><span class="line">memcpy(buf,abcd,sizeof(ABCD));</span><br><span class="line">//strcpy(buf,(char *)abcd)；也不可以</span><br><span class="line">sock(host,buf,....);</span><br><span class="line">//sock(host,(char *)buf,...);也不可以</span><br><span class="line">问题就是在这里，这个buf中间的值总是不对，大家知道为什么否。</span><br><span class="line"></span><br><span class="line">回复人：　wolf721()　(2001-7-30 18:18:34) 得5分 </span><br><span class="line">你传的是个指针值，而不是数据 </span><br><span class="line">回复人：　kiko_lee(到处瞧瞧)　(2001-7-30 18:50:49) 得0分 </span><br><span class="line">但是用memcpy这个是将整个数据都复制过去 </span><br><span class="line">回复人：　lz_0618(lz_0618)　(2001-7-30 19:26:44) 得5分 </span><br><span class="line">你用的VC???改成ABCD *abcd;后编译一点问题也没有啊！</span><br><span class="line">sock(host,buf,....);这不知是什么，自定义函数？</span><br><span class="line"></span><br><span class="line">typedef struct _ABCD</span><br><span class="line">&#123;</span><br><span class="line">int ID;</span><br><span class="line">char Name[10];</span><br><span class="line">&#125;ABCD;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ABCD *abcd;</span><br><span class="line">char *buf;</span><br><span class="line">abcd = (ABCD *)calloc(2,sizeof(ABCD));</span><br><span class="line">buf = (char *)calloc(2,sizeof(ABCD));</span><br><span class="line">///</span><br><span class="line">//给abcd 中间赋值，其中有多个char[]的值和int 的值</span><br><span class="line">abcd[0].ID =1;</span><br><span class="line">abcd[1].ID =2;</span><br><span class="line">///</span><br><span class="line">memcpy(buf,abcd,2*sizeof(ABCD));</span><br><span class="line">strcpy(buf,(char *)abcd);//也不可以</span><br><span class="line"></span><br><span class="line">buf中的内容也正确！！</span><br><span class="line"></span><br><span class="line">回复人：　kiko_lee(到处瞧瞧)　(2001-7-31 8:57:52) 得0分 </span><br><span class="line">我按照楼上的兄弟说的，做了一下，但是仍然做不下来，我用</span><br><span class="line">memcpy(buf,abcd,sizeof(ABCD));</span><br><span class="line">中间的abcd，不知道是不是地址的问题。 </span><br><span class="line">回复人：　supersusheng(小苏)　(2001-7-31 14:30:42) 得0分 </span><br><span class="line">老大，你sizeof()得出的数值事多大，看看吧。 </span><br><span class="line">回复人：　ydogg(灰毛兔)　(2001-7-31 14:41:52) 得0分 </span><br><span class="line">只能传递流数据，结构是传递不过去的。 </span><br><span class="line">回复人：　IamNotMan(NorGirl)　(2001-7-31 14:50:53) 得5分 </span><br><span class="line">我常这么用</span><br><span class="line">ABCD a ;</span><br><span class="line">//给a的各个域赋值（一定不能含有指针项）</span><br><span class="line">char* buff = new char[sizeof(ABCD)];</span><br><span class="line">memcpy(buff,&amp;a,sizeof(ABCD));</span><br><span class="line">//或者 *（ABCD*)buff = a;</span><br><span class="line">.................</span><br><span class="line">如果buff里的数对，说明问题不在这儿吧</span><br><span class="line"></span><br><span class="line">回复人：　zb_china(最后一座水车zb_china新浪)　(2001-7-31 15:16:24) 得0分 </span><br><span class="line">看不明白 </span><br><span class="line">回复人：　eggplant(拉拉)　(2001-7-31 15:42:48) 得0分 </span><br><span class="line">最好使用memcpy(),因为struct中的值有可能包含零字节，所以strcpy（）可能不对，如果传递struct,最好把struct的字节对齐改为以字节为单位。 </span><br><span class="line">回复人：　lvfengxun(lfx)　(2001-7-31 16:06:57) 得5分 </span><br><span class="line">直接将结构指针作为send的参数发就可以了,还用转换什么</span><br><span class="line">有必要在这里讨论吗?</span><br><span class="line">struct AA</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b[100];</span><br><span class="line">&#125;;</span><br><span class="line">struct AA aa;</span><br><span class="line">aa.a=11;</span><br><span class="line">strcpy(aa.b,&quot;aaa&quot;);</span><br><span class="line">send(hSocket,(char *)(&amp;aa),sizeof(aa),0);</span><br><span class="line">//OK </span><br><span class="line">回复人：　mydewang(mydewang)　(2001-7-31 16:33:21) 得0分 </span><br><span class="line">其实这里是一个字节对齐的问题,</span><br><span class="line">比如</span><br><span class="line">struct AA</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">&#125;;</span><br><span class="line">那么sizeof( struct AA )就不等于5了,而是8了,所以,将这个结构赋值给一个char *,里面会多出一些零...</span><br><span class="line"></span><br><span class="line">需要解决这个问题,可以在Project-&gt;Setting-&gt;Link-&gt;Project Options里加上/Zp1</span><br><span class="line"></span><br><span class="line">另外,可以参考一下MSDN里/Zp的编译选项..... </span><br><span class="line">回复人：　lz_0618(lz_0618)　(2001-7-31 19:43:54) 得0分 </span><br><span class="line">根本不是什么字节对齐的问题，我上面的程序经过测试都好用啊，这位老兄用我的那段程序究竟是什么错误，能说清楚点吗？？？</span><br><span class="line"></span><br><span class="line">我这边用socket发送结构是一点问题也没有啊，而且是在VC和Delphi编的程序间通讯，当然，这时应该注意字节对齐的问题了，在VC程序间，</span><br><span class="line">只要不是故意将服务器和客户端的编译环境设的不一样，肯定是没有什么问题的，最多是多传几个Bit罢了。 </span><br><span class="line">回复人：　kiko_lee(到处瞧瞧)　(2001-8-3 11:02:51) 得0分 </span><br><span class="line">我发现将char * memcpy 到 char * 中间都有点问题，但是如果放到 char []中间就可以了，大家知道为什么否？ </span><br><span class="line">回复人：　ydogg(灰毛兔)　(2001-8-3 11:40:35) 得0分 </span><br><span class="line">memcpy不copy最后的&apos;/0&apos;... </span><br><span class="line">回复人：　wenjunlin2000(微软克星)　(2001-8-3 14:32:17) 得0分 </span><br><span class="line">是你看错了</span><br><span class="line">因为char*是以0 结尾的</span><br><span class="line"></span><br><span class="line">回复人：　mc_music(狂沙)　(2001-8-3 15:07:21) 得0分 </span><br><span class="line">请注意我的程序:</span><br><span class="line">struct ABCD *abcd;</span><br><span class="line">char *buf;</span><br><span class="line">abcd = (ABCD *)calloc(1,sizeof(ABCD));</span><br><span class="line">//初始化abcd</span><br><span class="line">buf=abcd;//指针直接符值就可以了 </span><br><span class="line">回复人：　zhangnanonnet(WinSockZhang)　(2001-8-3 16:21:03) 得0分 </span><br><span class="line">你试试把类型变为BYTE </span><br><span class="line">回复人：　kiko_lee(到处瞧瞧)　(2001-8-7 9:21:08) 得0分 </span><br><span class="line">不管了，给分，大家都有不少的建议呢。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">38。double dou=12.34;我如何可以得到char * ch=&quot;12.34&quot;;转换函数是什么？</span><br><span class="line"></span><br><span class="line">回复人：　wyzegg(蛋)　(2001-7-24 21:26:04) 得50分 </span><br><span class="line">double dou=12.34;</span><br><span class="line">char * ch;</span><br><span class="line">ch=malloc(100);</span><br><span class="line">sprintf(ch,&quot;%5.2f&quot;,dou); </span><br><span class="line">回复人：　wyzegg(蛋)　(2001-7-24 21:28:24) 得0分 </span><br><span class="line">或者</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main( void )</span><br><span class="line">&#123;</span><br><span class="line">int decimal, sign;</span><br><span class="line">char *buffer;</span><br><span class="line">int precision = 10;</span><br><span class="line">double source = 3.1415926535;</span><br><span class="line"></span><br><span class="line">buffer = _ecvt( source, precision, &amp;decimal, &amp;sign );</span><br><span class="line">printf( &quot;source: %2.10f buffer: &apos;%s&apos; decimal: %d sign: %d/n&quot;,</span><br><span class="line">source, buffer, decimal, sign );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但是第一种常用 </span><br><span class="line">回复人：　Matrix_w(学会一点点)　(2001-7-24 21:32:43) 得30分 </span><br><span class="line">int decimal, sign;</span><br><span class="line">double dou =12.34;</span><br><span class="line">char* ch;</span><br><span class="line">ch = _ecvt(dou,4,&amp;decimal,&amp;sign);</span><br><span class="line"></span><br><span class="line">回复人：　imhua(华弟)　(2001-7-24 21:35:02) 得20分 </span><br><span class="line">double dou=12.34;</span><br><span class="line">char *str;</span><br><span class="line">gcvt(dou,5,str); //5是长度</span><br><span class="line">MessageBox(str); </span><br><span class="line">回复人：　Matrix_w(学会一点点)　(2001-7-24 21:37:58) 得0分 </span><br><span class="line">/* _GCVT.C: This program converts -3.1415e5</span><br><span class="line">* to its string representation.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main( void )</span><br><span class="line">&#123;</span><br><span class="line">char buffer[50];</span><br><span class="line">double source = -3.1415e5;</span><br><span class="line">_gcvt( source, 7, buffer );</span><br><span class="line">printf( &quot;source: %f buffer: &apos;%s&apos;/n&quot;, source, buffer );</span><br><span class="line">_gcvt( source, 7, buffer );</span><br><span class="line">printf( &quot;source: %e buffer: &apos;%s&apos;/n&quot;, source, buffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">source: -314150.000000 buffer: &apos;-314150.&apos;</span><br><span class="line">source: -3.141500e+005 buffer: &apos;-314150.&apos;</span><br><span class="line"></span><br><span class="line">39。 我在ADO中调用一个存储过程，存储过程有三个输入参数@useradd char(30),@username char(10),@userage char(3)，现在要把char </span><br><span class="line">*addr,char *name,char *age分别赋值给他们。??</span><br><span class="line">我做了如下定义：</span><br><span class="line">_ParameterPtr para1;</span><br><span class="line">_variant_t var1,var2,var3；</span><br><span class="line">==============================================================</span><br><span class="line">var1.vt=VT_BSTR;</span><br><span class="line">var1.bstrval=addr;/////(编译错误）</span><br><span class="line">==============================================================</span><br><span class="line">para1=m_pCommand-&gt;CreateParameter(L&quot;useradd&quot;,adBSTR,adParamInput,30,var1);</span><br><span class="line">m_pCommand-&gt;Parameters-&gt;Append(para1);</span><br><span class="line">编译结果出现下面错误：</span><br><span class="line">cannot convert from &apos;char *&apos; to &apos;unsigned short *</span><br><span class="line">不知道类型是不是选择VT_BSTR?</span><br><span class="line">回复人：tar(GPS)　(2001-7-12 18:49:05) 得15分 </span><br><span class="line">var1.bstrval应该指向宽字符的字符串，</span><br><span class="line">即unicode字符串</span><br><span class="line">use _bstr_t to convert it</span><br><span class="line"></span><br><span class="line">_bstr_t var1(addr);</span><br><span class="line"></span><br><span class="line">　回复人：happyhackwang()　(2001-7-12 20:06:48) 得5分 </span><br><span class="line">char *要进行转换成BSTR</span><br><span class="line"></span><br><span class="line">　回复人：WhiteWaterBlueSky(疯狂数码)　(2001-7-13 9:35:15) 得10分 </span><br><span class="line">SDK中是这样的</span><br><span class="line">1。先用MultiByteToWideChar把char* 转为wchar_t*</span><br><span class="line">2。再用SysAllocString把wchar_t*转为BSTR </span><br><span class="line"></span><br><span class="line">　回复人：tar(GPS)　(2001-7-13 14:10:01) 得0分 </span><br><span class="line">faint,我都已经把语句写出来了</span><br><span class="line">_bstr_t a(addr);</span><br><span class="line">var1.vt=VT_BSTR;</span><br><span class="line">var1.bstrval=(wchar_t *)a; </span><br><span class="line"></span><br><span class="line">　回复人：xwchena(西风之神)　(2001-7-13 15:57:00) 得0分 </span><br><span class="line">大哥，我改完之后记录集无结果返回。我的代码是这样的：</span><br><span class="line">m_pRecordset.CreateInstance(__uuidof(Recordset));</span><br><span class="line">m_pRecordset=m_pCommand-&gt;Execute(NULL,NULL,adCmdStoredProc);</span><br><span class="line">if(!m_pRecordset-&gt;adoEOF)</span><br><span class="line">&#123;</span><br><span class="line">result1=m_pRecordset-&gt;GetCollect((long)0);</span><br><span class="line">if(result1.vt!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">result1.ChangeType(VT_BSTR);</span><br><span class="line">CString strResult1=result1.bstrVal;</span><br><span class="line">strcpy(resval,strResult1);</span><br><span class="line">&#125;</span><br><span class="line">调试的时候看到执行完m_pCommand-&gt;Execute()后m_pRecordset就到了记录集的尾部</span><br><span class="line">而如果把char*型都改成int型，结果就能返回记录集。</span><br><span class="line">这是为什么啊？？？</span><br><span class="line"></span><br><span class="line">　回复人：tar(GPS)　(2001-7-13 19:19:51) 得0分 </span><br><span class="line">try adVarChar </span><br><span class="line">　回复人：xwchena(西风之神)　(2001-7-13 22:54:21) 得0分 </span><br><span class="line">还是不行，记录集没有返回结果 </span><br><span class="line">　回复人：seesi(不是我想骗你，是我不知道怎么才能不骗！)　(2001-7-14 0:24:36)</span><br><span class="line">40。如何将 BSTR pVal 赋给：unsigned char *pw；如何将：unsigned char digest[16]赋给 BSTR *pOutVal?</span><br><span class="line">USES_CONVERSION;</span><br><span class="line">  *pOutVal=SysAllocString(A2W((LPTSTR)digest));</span><br><span class="line"></span><br><span class="line">unsigned char *pw = (unsigned char *)_com_util::ConvertBSTRToString(pInVal);</span><br></pre></td></tr></table></figure>
<p>========================================================================<br>转载声明：本文转自<a href="http://blog.csdn.net/ithomer/article/details/5019367" target="_blank" rel="noopener">http://blog.csdn.net/ithomer/article/details/5019367</a></p>

      
    </div>

    

    
    
    
	<div>
      	
        	
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Windows数据类型解析</p>
  <p><span>文章作者:</span>JoAiden Lee</p>
  <p><span>发布时间:</span>2019年06月11日 - 13:32:14</p>
  <p><span>最后更新:</span>2019年06月11日 - 14:57:03</p>
  <p><span>原始链接:</span><a href="/2019/06/11/windows数据类型/" title="Windows数据类型解析">http://yoursite.com/2019/06/11/windows数据类型/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://yoursite.com/2019/06/11/windows数据类型/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>


    	  
	</div>

	<div>
    	
    		<div>
    
        <div style="text-align:center;color: #636363;font-size:14px;letter-spacing: 10px">本文结束啦<i class="fa fa-bell"></i>感谢您的阅读</div>
    
</div>

    	
 	</div>

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/15/Point-Memory/" rel="next" title="Point指针和Memory内存">
                <i class="fa fa-chevron-left"></i> Point指针和Memory内存
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/11/排序和链表/" rel="prev" title="排序和链表">
                排序和链表 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="JoAiden Lee">
            
              <p class="site-author-name" itemprop="name">JoAiden Lee</p>
              <div class="site-description motion-element" itemprop="description">学海无涯，不一定非要苦作舟</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/yourname" title="GitHub &rarr; https://github.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:yourname@gmail.com" title="E-Mail &rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/yourname" title="Google &rarr; https://plus.google.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/yourname" title="Twitter &rarr; https://twitter.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yxyuxuan.github.io/" title="https://yxyuxuan.github.io/" rel="noopener" target="_blank">前端大佬</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Windows数据类型详解"><span class="nav-number">1.</span> <span class="nav-text">Windows数据类型详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-blog-csdn-net-ithomer-article-details-5019367"><span class="nav-number">2.</span> <span class="nav-text">http://blog.csdn.net/ithomer/article/details/5019367</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JoAiden Lee</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">{
  }Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0


</div>
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
