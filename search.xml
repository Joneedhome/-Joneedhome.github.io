<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Point指针和Memory内存]]></title>
    <url>%2F2019%2F05%2F15%2FPoint-Memory%2F</url>
    <content type="text"><![CDATA[================================== 内存C语言中使用的地址是假的，计算机是通过虚拟内存地址访问到真实的物理内存的。虚拟内存通过内存映射来找到物理内存。在CPU内部，有一个部件叫做MMU（Memory Management Unit，内存管理单元），由它来负责将虚拟地址映射为物理地址。 内存一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。 一个C语言程序在内存中分布： 程序代码区：(code)存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。 常量区：(constant)存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 全局数据区：(global data)存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 堆区：(heap)一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 动态链接库：用于在程序运行期间加载和卸载动态链接库。 栈区：(stack)存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。 问题思考堆和栈都是什么，它们在程序运行过程中起到什么作用？为什么栈内存的分配效率要高于堆？ 栈溢出是怎么回事，如何利用栈溢出进行攻击？ 内存泄漏、野指针、非法内存访问、段错误都是怎么产生的？ 内存池、线程池、连接池等这些莫名其妙的“池子”是怎么回事？ 注意：编译器对程序进行编译过程中，对于字节对齐有利于内存的寻址，从而提高程序的运行效率 、、、 #include &lt;stdio.h&gt; char *str1 = &quot;c.biancheng.net&quot;; //字符串在常量区，str1在全局数据区 int n; //全局数据区 char* func(){ char *str = &quot;C语言中文网&quot;; //字符串在常量区，str在栈区 return str; } int main(){ int a; //栈区 char *str2 = &quot;01234&quot;; //字符串在常量区，str2在栈区 char arr[20] = &quot;56789&quot;; //字符串和arr都在栈区 char *pstr = func(); //栈区 int b; //栈区 printf(&quot;str1: %#X\npstr: %#X\nstr2: %#X\n&quot;, str1, pstr, str2); puts(&quot;--------------&quot;); printf(&quot;&amp;str1: %#X\n &amp;n: %#X\n&quot;, &amp;str1, &amp;n); puts(&quot;--------------&quot;); printf(&quot; &amp;a: %#X\n arr: %#X\n &amp;b: %#X\n&quot;, &amp;a, arr, &amp;b); puts(&quot;--------------&quot;); printf(&quot;n: %d\na :%d\nb: %d\n&quot;, n, a, b); puts(&quot;--------------&quot;); printf(&quot;%s\n&quot;, pstr); return 0; } 、、、]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F08%2FCreateMyselfBlog%2F</url>
    <content type="text"><![CDATA[GitHub + git + hexo 建立自己的博客资源整合来自于:http://lowrank.science/Hexo-Github/https://yxyuxuan.github.io/以及hexo官网相关文档 关于gitHub &amp; git 的介绍：githubgithub 主要用来作为远程服务器端的代码文档等托管的平台。gitgit 主要是用来本地插件和远端服务器进行连接的插件。hexohexo 服务器主要是用来把文档生成网页，并上传到github的工具。hexo 一般是在node.js的环境下安装的。具体各个部件的安装顺序如下：github 账号申请，账号注册，远程仓库创建。git 软件的下载和使用。hexo的搭建。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MarkDown Document]]></title>
    <url>%2F2019%2F05%2F08%2FMarkDownMark%2F</url>
    <content type="text"><![CDATA[Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。相比WYSIWYG编辑器优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。还好，简书是支持Markdown编辑模式的。开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。示例： 这是一级标题（#）这是二级标题（##）这是三级标题（###）这是四级标题（####）这是五级标题（#####）这是六级标题（######）二、字体加粗要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 三、引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 貌似可以一直加下去，但没神马卵用示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四、分割线 三个或者三个以上的 - 或者 都可以。示例： — 1 —- 2 ** 3 * 4 五、图片 语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 六、超链接语法：超链接名title可加可不加 示例：简书百度 效果如下：简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例 简书 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 有序列表 语法： 数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容 一级无序列表内容二级有序列表内容二级有序列表内容二级有序列表内容 一级有序列表内容二级无序列表内容二级无序列表内容二级无序列表内容 一级有序列表内容二级有序列表内容二级有序列表内容二级有序列表内容 八、表格语法：表头|表头|表头—|:–:|—:内容|内容|内容内容|内容|内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：姓名|技能|排行–|:–:|–:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 九、代码语法：单行代码：代码之间分别用一个反引号包起来 代码内容 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123代码...代码...代码... 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例：单行代码create database hero; 代码块1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十、流程图12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Opengl]]></title>
    <url>%2F2019%2F05%2F08%2FOpengl%2F</url>
    <content type="text"></content>
  </entry>
</search>
