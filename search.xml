<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言文件操作api]]></title>
    <url>%2F2019%2F06%2F11%2FC%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Capi%2F</url>
    <content type="text"><![CDATA[在ANSIC中，对文件的操作分为两种方式，即: 流式文件操作 * I/O文件操作 * 一、流式文件操作这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：1234567891011typedef struct &#123; int level; /* fill/empty level of buffer */ unsigned flags; /* File status flags */ char fd; /* File descriptor */ unsigned char hold; /* Ungetc char if no buffer */ int bsize; /* Buffer size */ unsigned char _FAR *buffer; /* Data transfer buffer */ unsigned char _FAR *curp; /* Current active pointer */ unsigned istemp; /* Temporary file indicator */ short token; /* Used for validity checking */&#125; FILE; /* This is the FILE object */ 函数 功能fopen() 打开流fclose() 关闭流fputc() 写一个字符到流中fgetc() 从流中读一个字符fseek() 在流中定位到指定的字符fputs() 写字符串到流fgets() 从流中读一行或指定个字符fprintf() 按格式输出到流fscanf() 从流中按格式读取feof() 到达文件尾时返回真值ferror() 发生错误时返回其值rewind() 复位文件定位器到文件开始处remove() 删除文件fread() 从流中读指定个数的字符fwrite() 向流中写指定个数的字符tmpfile() 生成一个临时文件流tmpnam() 生成一个唯一的文件名 fopen()fopen的原型是：FILE fopen(const char filename,const char *mode)，fopen实现三个功能为使用而打开一个流 ;把一个文件和此流相连接;给此流返回一个FILR指针参数filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下表“r” 以只读方式打开文件 “w” 以只写方式打开文件 “a” 以追加方式打开文件“r+” 以读/写方式打开文件，如无文件出错 “w+” 以读/写方式打开文件，如无文件生成新文件一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’n’，而二进制模式认为它是两个字符0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。系统默认的是以文本模式打开，可以修改全部变量_fmode的值来修改这个设置，例如_fmode=O_TEXT；就设置默认打开方式为文本模式；而_fmode=O_BINARY；则设置默认打开方式是二进制模式。我们也可以在模式字符串中指定打开的模式，如”rb”表示以二进制模式打开只读文件，”w+t”或”wt+”表示以文本模式打开读/写文件。此函数返回一个FILE指针，所以申明一个FILE指针后不用初始化，而是用fopen()来返回一个指针并与一个特定的文件相连，如果成败，返回NULL。123456例: FILE *fp; if(fp=fopen(&quot;123.456&quot;,&quot;wb&quot;)) puts(&quot;打开文件成功&quot;); else puts(&quot;打开文件成败&quot;); fclose()功能是关闭用fopen()打开的文件，其原型是：int fclose(FILE *fp);如果成功，返回0,失败返回EOF。在程序结束时一定要记得关闭打开的文件，不然可能会造成数据丢失。 fputc()：向流写一个字符，原型是int fputc(int c, FILE *stream); 成功返回这个字符,失败返回EOF。例：fputc(‘X’,fp); fgetc()：从流中读一个字符，原型是int fputc(FILE *stream); 成功返回这个字符,失败返回EOF。 fseek()：此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是int fseek(FILE *stream, long offset, int whence);如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是符号常量 值 基准位置SEEK_SET 0 文件开头SEEK_CUR 1 当前读写的位置SEEK_END 2 文件尾部 fputs()：写一个字符串到流中，原型int fputs(const char s, FILE stream);例：fputs(“I Love You”,fp); fgets()：从流中读一行或指定个字符，原型是char fgets(char s, int n, FILE *stream); 从流中读取n-1个字符，除非读完一行，参数s是来接收字符串，如果成功则返回s的指针，否则返回NULL。如果用 fgets(str1,4,file1); 则执行后str1=”Lov”，读取了4-1=3个字符，而如果用 fgets(str1,23,file1);则执行str=”Love ,I Have”，读取了一行(不包括行尾的’n’)。 fprintf()：按格式输入到流，其原型是int fprintf(FILE stream, const char format[, argument, …]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了.例：fprintf(fp,”%2d%s”,4,”Hahaha”); fscanf()：从流中按格式读取，其原型是int fscanf(FILE stream, const char format[, address, …]);其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。例：fscanf(fp,”%d%d” ,&amp;x,&amp;y); feof()： 检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream); 1211. ferror()： 原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream);```例：printf(&quot;%d&quot;,ferror(fp)); rewind()：把当前的读写位置回到文件开始，原型是void rewind(FILE *stream);其实本函数相当于fseek(fp,0L,SEEK_SET);例：rewind(fp); remove()：删除文件，原型是int remove(const char *filename); 参数就是要删除的文件名，成功返回0。114. fread()：从流中读指定个数的字符，原型是size_t fread(void *ptr, size_t size, size_t n, FILE *stream);参数ptr是保存读取的数据，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。 例：char x[4230]; FILE *file1=fopen(“c:msdos.sys”,”r”); fread(x,200,12 ,file1);//共读取200*12=2400个字节115. fwrite()：与fread对应，向流中写指定的数据，原型是size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);参数ptr是要写入的数据指针，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。 例：char x[]=”I Love You”; fwire(x, 6,12,fp);//写入6*12=72字节 将把”I Love”写到流fp中12次，共72字节123456789101112131415161718192021222324252627282930313216. tmpfile()： 其原型是FILE *tmpfile(void); 生成一个临时文件，以&quot;w+b&quot;的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。例：FILE *fp=tmpfile();17. tmpnam()：其原型为char *tmpnam(char *s); 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。例：tmpnam(str1);## 二、直接I/O文件操作这是C提供的另一种文件操作，它是通过直接存/取文件来完成对文件的处理.而上篇所说流式文件操作是通过缓冲区来进行；流式文件操作是围绕一个FILE 指针来进行，而此类文件操作是围绕一个文件的“句柄”来进行。什么是句柄呢？它是一个整数，是系统用来标识一个文件(在WINDOWS中，句柄的概念扩展到所有设备资源的标识)的唯一的记号。此类文件操作常用的函数如下表，这些函数及其所用的一些符号在io.h和fcntl.h中定义，在使用时要加入相应的头文件。函数 说明open() 打开一个文件并返回它的句柄close() 关闭一个句柄lseek() 定位到文件的指定位置read() 块读文件write() 块写文件eof() 测试文件是否结束filelength() 取得文件长度rename() 重命名文件chsize() 改变文件长度下面就对这些函数一 一说明：1. open()：打开一个文件并返回它的句柄，如果失败，将返回一个小于0的值，原型是int open(const char *path, int access [, unsigned mode]); 参数path是要打开的文件名，access是打开的模式，mode是可选项。表示文件的属性，主要用于UNIX系统中，在DOS/WINDOWS这个参数没有意义。其中文件的打开模式如下表。符号 含义 符号 含义 符号 含义O_RDONLY 只读方式 O_WRONLY 只写方式 O_RDWR 读/写方式O_NDELAY 用于UNIX系统 O_APPEND 追加方式 O_CREAT 如果文件不存在就创建O_TRUNC 把文件长度截为0 O_EXCL 和O_CREAT连用，如果文件存在返回错误 O_BINARY 二进制方式O_TEXT 文本方式对于多个要求，可以用&quot;|&quot;运算符来连接，如O_APPEND|O_TEXT表示以文本模式和追加方式打开文件。例：int handle=open(&quot;c:msdos.sys&quot;,O_BINARY|O_CREAT|O_WRITE)2. close()：关闭一个句柄，原型是int close(int handle);如果成功返回0 .例：close(handle)3. lseek()：定位到指定的位置，原型是：long lseek(int handle, long offset, int fromwhere);参数offset是移动的量，fromwhere是移动的基准位置，取值和前面讲的fseek()一样，SEEK_SET：文件首部；SEEK_CUR：文件当前位置；SEEK_END：文件尾。此函数返回执行后文件新的存取位置。```例：lseek(handle,-1234L,SEEK_CUR);//把存取位置从当前位置向前移动1234个字节。 x=lseek(hnd1,0L,SEEK_END);//把存取位置移动到文件尾，x=文件尾的位置即文件长度 read()：从文件读取一块，原型是int read(int handle, void *buf, unsigned len);参数buf保存读出的数据，len是读取的字节。函数返回实际读出的字节。例：char x[200];read(hnd1,x,200); write()：写一块数据到文件中，原型是int write(int handle, void *buf, unsigned len);参数的含义同read()，返回实际写入的字节。例：char x[]=”I Love You”;write(handle,x,strlen(x)); 略过。。。 eof()：类似feof()，测试文件是否结束，是返回1，否则返回0;原型是：int eof(int handle);例：while(!eof(handle1)){……}; filelength()： 返回文件长度，原型是long filelength(int handle);相当于lseek(handle,0L,SEEK_END)例：long x=filelength(handle); rename()： 重命名文件，原型是int rename(const char oldname, const char newname); 参数oldname是旧文件名，newname是新文件名。成功返回0 。例：rename(“c:config.sys”,”c:config.w40”); chsize(); 改变文件长度，原型是int chsize(int handle, long size);参数size表示文件新的长度，成功返回0，否则返回-1，如果指定的长度小于文件长度，则文件被截短；如果指定的长度大于文件长度，则在文件后面补’’。例：chsize(handle,0x12345); 如果熟悉汇编可能会发现这种方式和汇编语言的DOS功能调用句柄式文件操作很像，比如open()就像DOS服务的3CH号功能调用，其实这种操作还有两种类型的函数就是直接用DOS功能来完成的，如_open()，_dos_open()等等。有兴趣可自已查询BCB的帮助。同流式文件操作相同，这种也提供了Unicode字符操作的函数，如_wopen()等等，用于9X/NT下的宽字符编程，有兴趣可自已查询BCB的帮助。另外，此种操作还有lock(),unlock(),locking()等用于多用户操作的函数，但在BCB中用得并不多，就不介绍了，但如果要用C来写CGI，这些就必要的常识了，如果你有这方面的要求，那就得自已好好看帮助了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言api]]></title>
    <url>%2F2019%2F06%2F11%2FC%E8%AF%AD%E8%A8%80api%2F</url>
    <content type="text"><![CDATA[getchar()用法 与 getch()函数使用方法getchar()用法： 从缓冲区读走一个字符，相当于清除缓冲区 前面的scanf()在读取输入时会在缓冲区中留下一个字符’\n’（输入完s[i]的值后按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，gets(）就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误 3.getchar()是在输入缓冲区顺序读入一个字符(包括空格、回车和Tab)getchar()使用不方便,解决方法：（1）使用下面的语句清除回车：12345678910111213141516171819202122232425（2）用getche()或getch()代替getchar()，其作用是从键盘读入一个字符（不用按回车），注意要包含头文件&lt;conio.h&gt;所在头文件：conio.h 函数用途：从控制台读取一个字符 函数原型：int getch(void) 返回值：读取的字符 例如： char ch;或int ch； getch();或ch=getch(); 用getch();会等待你按下任意键，再继续执行下面的语句； 用ch=getch();会等待你按下任意键之后，把该键字符所对应的ASCII码赋给ch,再执行下面的语句。 易错点： 1.所在头文件是conio.h。而不是stdio.h。 2.在使用之前要调用initscr()，结束时要调用endwin()。否则会出现不输入字符这个函数 也会返回的情况。 3.在不同平台，输入回车，getch()将返回不同数值，而getchar()统一返回10(即\n) 1)windows平台下ENTER键会产生两个转义字符 \r\n，因此getch返回13(\r)。 2)unix、 linux系统中ENTER键只产生 \n ，因此getch返回10(\n)。 3)MAC OS中ENTER键将产生 \r ，因此getch返回13(\r)。 getch();并非标准C中的函数，不存在C语言中。所以在使用的时候要注意程序的可移植性。国内C语言新手常常使用getch();来暂停程序且不知道此函数来源，建议使用getchar();（如果情况允许）代替此功能或更换一款编译器。eg： #include&lt;stdio.h&gt; #include&lt;conio.h&gt; int main() { charc; while((c=getch())!=’\r’) { printf(“*”); } return 0; }` strcat()函数和strcpy()函数的用法 strcpy原型声明：extern char strcpy(char dest, const char* src);头文件：#include &lt;string.h&gt;功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。 strcat原型 extern char strcat(char dest,char* src);用法#include &lt;string.h&gt;在C++中，则存在于头文件中。功能把src所指字符串添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’。说明src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。 eg:原文：https://blog.csdn.net/qq_33221533/article/details/80835209版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序和链表]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%8E%92%E5%BA%8F%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Windows数据类型解析]]></title>
    <url>%2F2019%2F06%2F11%2Fwindows%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Windows数据类型详解Windows字符和字符串处理友情提示：为了方便你更好的学习和阅读，也更好的体现尊重原创作者的劳动成果，请您直接查看转载原本链接： http://blog.csdn.net/ithomer/article/details/5019367VC++常用数据类型及其操作详解 一.VC常用数据类型列表二.常用数据类型转化2.1数学类型变量与字符串相互转换2.2 CString及string,char 与其他数据类型的转换和操作●CString,string,char的综合比较●数学类型与CString相互转化●CString与char*相互转换举例●CString 与 BSTR 型转换●VARIANT 型转化成 CString 型2.3 BSTR、_bstr_t与CComBSTR2.4 VARIANT 、_variant_t 与 COleVariant附录CString及字符串转及操作详解 参考书籍:CSDN,&lt;&lt;MFC深入浅出(Second Edit)&gt;&gt; 一．VC常用数据类型列表 Type Default Size Description boolean unsigned 8 bit 取值TRUE/FALSE byte unsigned 8 bit 整数,输出按字符输出 char unsigned 8 bit 字符 double signed 64 bit 浮点型 float signed32 bit 浮点型 hyper signed 64 bit 整型 int signed 32 bit 整型 long signed 32 bit 整型 short signed 16 bit 整型 small signed 8 bit 整型 void * 32-bit 指向未知类型的指针 wchar_t unsigned 16 bit 16位字符,比char可容纳更多的字符 Win32 API常用数据类型 全大写 Type Default Size Description BOOL\BOOLEAN 8bit,TRUE/FALSE 布尔型 BYTE unsigned 8 bit BSTR_bstr_t 32 bit BSTR是指向字符串的32位指针 是对BSTR的封装 是对BSTR的封装 CHAR 8 bit (ANSI）字符类型 COLORREF 32 bit RGB颜色值 整型 DWORD unsigned 32 bit 整型 FLOAT float型 float型 HANDLE ——- Object句柄 HBITMAP ——- bitmap句柄 HBRUSH ——- brush句柄 HCURSOR ——- cursor句柄 HDC ——- 设备上下文句柄 HFILE ——- OpenFile打开的File句柄 HFONT ——- font句柄 HHOOK ——- hook句柄 HKEY ——- 注册表键句柄 HPEN ——- pen句柄 HWND ——- window句柄 INT ——- ——– LONG ——– ——— LONGLONG ——- 64位带符号整型 LPARAM 32 bit 消息参数 LPBOOL ——- BOOL型指针 LPBYTE ——- BYTE型指针 LPCOLOREF ——- COLORREF型指针 LPCSTR/LPSTR/PCSTR ——- 指向8位（ANSI）字符串类型指针 LPCWSTR/LPWSTR/PCWSTR ——- 指向16位Unicode字符串类型 LPCTSTR/LPTSTR/PCTSTR ——- 指向一8位或16位字符串类型指针 LPVOID ——- 指向一个未指定类型的32位指针 LPDWORD ——- 指向一个DWORD型指针 SHORT usigned 整型 其他相似类型: LPHANDLE、LPINT、LPLONG、LPWORD、LPRESULTPBOOL、PBOOLEAN、PBYTE、PCHAR、PDWORD、PFLOAT、PHANDLE、PINT、PLONG、PSHORT…… (1)在16位系统中 LP为16bit,P为8bit,在32位系统中都是32bit(此时等价)(2)LPCSTR等 中的C指Const,T表示TCHAR模式即可以工作在ANSI下也可UNICODE 其他UCHAR、UINT、ULONG、ULONGLONG、USHORT为无符号相应类型 TBYTE ——- WCHAR型或者CHAR型 TCHAR ——- ANSI与unicode均可 VARIANT_variant_t\COleVariant ——- 一个结构体参考OAIDL.H_variant_t是VARIANT的封装类\COleVariant也是VARIANT的封装类 WNDPROC ——- 指向一个窗口过程的32位指针 WCHAR ——- 16位Unicode字符型 WORD ——- 16位无符号整型 WPARAM ——- 消息参数 MFC独有类型 ——- 下面两个数据类型是微软基础类库中独有的数据类型 POSITION ——- 标记集合中一个元素的位置的值,被MFC中的集合类所使用 LPCRECT ——- 指向一个RECT结构体常量（不能修改）的32位指针 CString ——- 其实是MFC中的一个类 说明:(1)——-表示省略(2)1Byte=8Bit,字与机器有关,在8位系统中:字=1字节,16位系统中,1字=2字节，32位中:1字=4字节,64位中1字=8字节.不要搞混这些概念. 二．常用数据类型转化及操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915702．1 数学类型变量与字符串相互转换(这些函数都在STDLIB.H里)（1）将数学类型转换为字符串可以用以下一些函数:举例: _CRTIMP char * __cdecl _itoa(int, char *, int);//这是一个将数字转换为一个字符串类型的函数,最后一个int表示转换的进制如以下程序:int iTyep=3;char *szChar;itoa(iType,szChar,2);cout&lt;&lt;szChar;//输出为1010类似函数列表:_CRTIMP char * __cdecl _itoa(int, char *, int);//为了完整性,也列在其中_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);_CRTIMP char * __cdecl _ltoa(long, char *, int);_CRTIMP char * __cdecl _i64toa(__int64, char *, int);_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);//转换为长字符串类型_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);还有很多,请自行研究 （2）将字符串类型转换为数学类型变量可以用以下一些函数:举例: _CRTIMP int __cdecl atoi(const char *);//参数一看就很明了char *szChar=”88”;int temp(0);temp=atoi(szChar);cout&lt;&lt;temp;类似的函数列表:_CRTIMP int __cdecl atoi(const char *);_CRTIMP double __cdecl atof(const char *);_CRTIMP long __cdecl atol(const char *);_CRTIMP long double __cdecl _atold(const char *);_CRTIMP __int64 __cdecl _atoi64(const char *);_CRTIMP double __cdecl strtod(const char *, char **);//_CRTIMP long __cdecl strtol(const char *, char **, int);//_CRTIMP long double __cdecl _strtold(const char *, char **);_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);//长字符串类型转换为数学类型_CRTIMP long __cdecl wcstol(const wchar_t *, wchar_t **, int);_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);_CRTIMP int __cdecl _wtoi(const wchar_t *);_CRTIMP long __cdecl _wtol(const wchar_t *);_CRTIMP __int64 __cdecl _wtoi64(const wchar_t *);还有很多,请自行研究 2．2．CString及string,char *与其他数据类型的转换和操作（1）CString,string,char*的综合比较（这部分CSDN上的作者joise的文章&lt;&lt; CString,string,char*的综合比较&gt;&gt;写的很详细,请大家在仔细阅读他的文章.地址: http://blog.csdn.net/joise/或参考附录: (2)转换:●数学类型与CString相互转化 数学类型转化为CString可用Format函数,举例:CString s;int i = 64;s.Format(&quot;%d&quot;, i)CString转换为数学类型:举例CString strValue(&quot;1.234&quot;);double dblValue;dblValue = atof((LPCTSTR)strValue);●CString与char*相互转换举例CString strValue(“Hello”);char *szValue;szValue=strValue.GetBuffer(szValue);也可用(LPSTR)(LPCTSTR)对CString // 进行强制转换. szValue=(LPSTR)(LPCTSTR)strValue;反过来可直接赋值:char *szChar=NULL;CString strValue;szChar=new char[10];memset(szChar,0,10);strcpy(szChar,”Hello”);strValue=szChar;●CString 与 BSTR 型转换CString 型转化成 BSTR 型当我们使用 ActiveX 控件编程时，经常需要用到将某个值表示成 BSTR 类型.BSTR 是一种记数字符串，Intel平台上的宽字符串（Unicode），并且可以包含嵌入的 NULL 字符。可以调用 CString 对象的 AllocSysString 方法将 CString 转化成 BSTR：CString str;str = .....; // whateverBSTR bStr = str.AllocSysString(); BSTR型转换为CString如果你在 UNICODE 模式下编译代码，你可以简单地写成：CString convert(BSTR bStr)&#123; if(bStr == NULL) return CString(_T(&quot;&quot;)); CString s(bStr); // in UNICODE mode return s;&#125;如果是 ANSI 模式CString convert(BSTR b)&#123; CString s; if(b == NULL) return s; // empty for NULL BSTR#ifdef UNICODE s = b;#else LPSTR p = s.GetBuffer(SysStringLen(b) + 1); ::WideCharToMultiByte(CP_ACP, // ANSI Code Page 0, // no flags b, // source widechar string -1, // assume NUL-terminated p, // target buffer SysStringLen(b)+1, // target buffer length NULL, // use system default char NULL); // don&apos;&apos;t care if default used s.ReleaseBuffer();#endif return s;&#125; ●VARIANT 型转化成 CString 型VARIANT 类型经常用来给 COM 对象传递参数，或者接收从 COM 对象返回的值。你也能自己编写返回 VARIANT 类型的方法，函数返回什么类型 依赖可能（并且常常）方法的输入参数（比如，在自动化操作中，依赖与你调用哪个方法。IDispatch::Invoke 可能返回（通过其一个参数）一个 包含有BYTE、WORD、float、double、date、BSTR 等等 VARIANT 类型的结果，（详见 MSDN 上的 VARIANT 结构的定义）。在下面的例子中，假设 类型是一个BSTR的变体，也就是说在串中的值是通过 bsrtVal 来引用，其优点是在 ANSI 应用中，有一个构造函数会把 LPCWCHAR 引用的值转换为一个 CString（见 BSTR-to-CString 部分）。在 Unicode 模式中，将成为标准的 CString 构造函数，参见对缺省::WideCharToMultiByte 转换的告诫，以及你觉得是否可以接受（大多数情况下，你会满意的）。VARIANT vaData;vaData = m_com.YourMethodHere();ASSERT(vaData.vt == VT_BSTR);CString strData(vaData.bstrVal);你还可以根据 vt 域的不同来建立更通用的转换例程。为此你可能会考虑：CString VariantToString(VARIANT * va)&#123; CString s; switch(va-&gt;vt) &#123; /* vt */ case VT_BSTR: return CString(vaData-&gt;bstrVal); case VT_BSTR | VT_BYREF: return CString(*vaData-&gt;pbstrVal); case VT_I4: s.Format(_T(&quot;%d&quot;), va-&gt;lVal); return s; case VT_I4 | VT_BYREF: s.Format(_T(&quot;%d&quot;), *va-&gt;plVal); case VT_R8: s.Format(_T(&quot;%f&quot;), va-&gt;dblVal); return s; ... 剩下的类型转换由读者自己完成 default: ASSERT(FALSE); // unknown VARIANT type (this ASSERT is optional) return CString(&quot;&quot;); &#125; /* vt */&#125; 2．3 BSTR、_bstr_t与CComBSTRCComBSTR、_bstr_t是对BSTR的封装,BSTR是指向字符串的32位指针。char *转换到BSTR可以这样:BSTR b=_com_util::ConvertStringToBSTR(&quot;数据&quot;);///使用前需要加上头文件comutil.h反之可以使用char *p=_com_util::ConvertBSTRToString(b); 2．4(引)VARIANT 、_variant_t 与 COleVariantVARIANT的结构可以参考头文件VC98/Include/OAIDL.H中关于结构体tagVARIANT的定义。对于VARIANT变量的赋值：首先给vt成员赋值，指明数据类型，再对联合结构中相同数据类型的变量赋值，举个例子：VARIANT va;int a=2001;va.vt=VT_I4;///指明整型数据va.lVal=a; ///赋值对于不马上赋值的VARIANT，最好先用Void VariantInit(VARIANTARG FAR* pvarg);进行初始化,其本质是将vt设置为VT_EMPTY,下表我们列举vt与常用数据的对应关系:unsigned char bVal; VT_UI1short iVal; VT_I2long lVal; VT_I4float fltVal; VT_R4double dblVal; VT_R8VARIANT_BOOL boolVal; VT_BOOLSCODE scode; VT_ERRORCY cyVal; VT_CYDATE date; VT_DATEBSTR bstrVal; VT_BSTRIUnknown FAR* punkVal; VT_UNKNOWNIDispatch FAR* pdispVal; VT_DISPATCHSAFEARRAY FAR* parray; VT_ARRAY|*unsigned char FAR* pbVal; VT_BYREF|VT_UI1short FAR* piVal; VT_BYREF|VT_I2long FAR* plVal; VT_BYREF|VT_I4float FAR* pfltVal; VT_BYREF|VT_R4double FAR* pdblVal; VT_BYREF|VT_R8VARIANT_BOOL FAR* pboolVal; VT_BYREF|VT_BOOLSCODE FAR* pscode; VT_BYREF|VT_ERRORCY FAR* pcyVal; VT_BYREF|VT_CYDATE FAR* pdate; VT_BYREF|VT_DATEBSTR FAR* pbstrVal; VT_BYREF|VT_BSTRIUnknown FAR* FAR* ppunkVal; VT_BYREF|VT_UNKNOWNIDispatch FAR* FAR* ppdispVal; VT_BYREF|VT_DISPATCHSAFEARRAY FAR* FAR* pparray; VT_ARRAY|*VARIANT FAR* pvarVal; VT_BYREF|VT_VARIANTvoid FAR* byref; VT_BYREF_variant_t是VARIANT的封装类，其赋值可以使用强制类型转换，其构造函数会自动处理这些数据类型。例如：long l=222;ing i=100;_variant_t lVal(l);lVal = (long)i;COleVariant的使用与_variant_t的方法基本一样，请参考如下例子：COleVariant v3 = &quot;字符串&quot;, v4 = (long)1999;CString str =(BSTR)v3.pbstrVal;long i = v4.lVal; 一、BSTR、LPSTR和LPWSTR 在Visual C++.NET的所有编程方式中，我们常常要用到这样的一些基本字符串类型，如BSTR、LPSTR和LPWSTR等。之所以出现类似上述的这些数据类型，是因为不同编程语言之间的数据交换以及对ANSI、Unicode和多字节字符集(MBCS)的支持。 那么什么是BSTR、LPSTR以及LPWSTR呢？ BSTR(Basic STRing，Basic字符串)是一个OLECHAR*类型的Unicode字符串。它被描述成一个与自动化相兼容的类型。由于操作系统提供相应的 API函数(如SysAllocString)来管理它以及一些默认的调度代码，因此BSTR实际上就是一个COM字符串，但它却在自动化技术以外的多种场合下得到广泛使用。图1描述了BSTR的结构，其中DWORD值是字符串中实际所占用的字节数，且它的值是字符串中Unicode字符的两倍。 LPSTR和LPWSTR是Win32和VC++所使用的一种字符串数据类型。LPSTR被定义成是一个指向以NULL(‘/0’)结尾的8位ANSI 字符数组指针，而LPWSTR是一个指向以NULL结尾的16位双字节字符数组指针。在VC++中，还有类似的字符串类型，如LPTSTR、 LPCTSTR等，它们的含义如图2所示。 例如，LPCTSTR是指“long pointer to a constant generic string”，表示“一个指向一般字符串常量的长指针类型”，与C/C++的const char*相映射，而LPTSTR映射为 char*。 一般地，还有下列类型定义： #ifdef UNICODE typedef LPWSTR LPTSTR; typedef LPCWSTR LPCTSTR; #else typedef LPSTR LPTSTR; typedef LPCSTR LPCTSTR; #endif 二、CString、CStringA 和 CStringW Visual C++.NET中将CStringT作为ATL和MFC的共享的“一般”字符串类，它有CString、CStringA和CStringW三种形式，分别操作不同字符类型的字符串。这些字符类型是TCHAR、char和wchar_t。TCHAR在Unicode平台中等同于WCHAR(16位 Unicode字符)，在ANSI中等价于char。wchar_t通常定义为unsigned short。由于CString在MFC应用程序中经常用到，这里不再重复。 三、VARIANT、COleVariant 和_variant_t 在OLE、ActiveX和COM中，VARIANT数据类型提供了一种非常有效的机制，由于它既包含了数据本身，也包含了数据的类型，因而它可以实现各种不同的自动化数据的传输。下面让我们来看看OAIDL.H文件中VARIANT定义的一个简化版： struct tagVARIANT &#123; VARTYPE vt; union &#123; short iVal; // VT_I2. long lVal; // VT_I4. float fltVal; // VT_R4. double dblVal; // VT_R8. DATE date; // VT_DATE. BSTR bstrVal; // VT_BSTR. … short * piVal; // VT_BYREF|VT_I2. long * plVal; // VT_BYREF|VT_I4. float * pfltVal; // VT_BYREF|VT_R4. double * pdblVal; // VT_BYREF|VT_R8. DATE * pdate; // VT_BYREF|VT_DATE. BSTR * pbstrVal; // VT_BYREF|VT_BSTR. &#125;; &#125;; 显然，VARIANT类型是一个C结构，它包含了一个类型成员vt、一些保留字节以及一个大的union类型。例如，如果vt为VT_I2，那么我们可以从iVal中读出VARIANT的值。同样，当给一个VARIANT变量赋值时，也要先指明其类型。例如： VARIANT va; :: VariantInit(&amp;va); // 初始化 int a = 2002; va.vt = VT_I4; // 指明long数据类型 va.lVal = a; // 赋值 为了方便处理VARIANT类型的变量，Windows还提供了这样一些非常有用的函数： VariantInit —— 将变量初始化为VT_EMPTY； VariantClear —— 消除并初始化VARIANT； VariantChangeType —— 改变VARIANT的类型； VariantCopy —— 释放与目标VARIANT相连的内存并复制源VARIANT。 COleVariant类是对VARIANT结构的封装。它的构造函数具有极为强大大的功能，当对象构造时首先调用VariantInit进行初始化，然后根据参数中的标准类型调用相应的构造函数，并使用VariantCopy进行转换赋值操作，当VARIANT对象不在有效范围时，它的析构函数就会被自动调用，由于析构函数调用了VariantClear，因而相应的内存就会被自动清除。除此之外，COleVariant的赋值操作符在与VARIANT类型转换中为我们提供极大的方便。例如下面的代码： COleVariant v1(&quot;This is a test&quot;); // 直接构造 COleVariant v2 = &quot;This is a test&quot;; // 结果是VT_BSTR类型，值为&quot;This is a test&quot; COleVariant v3((long)2002); COleVariant v4 = (long)2002; // 结果是VT_I4类型，值为2002 _variant_t是一个用于COM的VARIANT类，它的功能与COleVariant相似。不过在Visual C++.NET的MFC应用程序中使用时需要在代码文件前面添加下列两句： #include &quot;comutil.h&quot; #pragma comment( lib, &quot;comsupp.lib&quot; ) 四、CComBSTR和_bstr_t CComBSTR是对BSTR数据类型封装的一个ATL类，它的操作比较方便。例如： CComBSTR bstr1; bstr1 = &quot;Bye&quot;; // 直接赋值 OLECHAR* str = OLESTR(&quot;ta ta&quot;); // 长度为5的宽字符 CComBSTR bstr2(wcslen(str)); // 定义长度为5 wcscpy(bstr2.m_str, str); // 将宽字符串复制到BSTR中 CComBSTR bstr3(5, OLESTR(&quot;Hello World&quot;)); CComBSTR bstr4(5, &quot;Hello World&quot;); CComBSTR bstr5(OLESTR(&quot;Hey there&quot;)); CComBSTR bstr6(&quot;Hey there&quot;); CComBSTR bstr7(bstr6); // 构造时复制，内容为&quot;Hey there&quot; _bstr_t是是C++对BSTR的封装，它的构造和析构函数分别调用SysAllocString和SysFreeString函数，其他操作是借用BSTR API函数。与_variant_t相似，使用时也要添加comutil.h和comsupp.lib。 五、BSTR、char*和CString转换 (1) char*转换成CString 若将char*转换成CString，除了直接赋值外，还可使用CString::Format进行。例如： char chArray[] = &quot;This is a test&quot;; char * p = &quot;This is a test&quot;; 或 LPSTR p = &quot;This is a test&quot;; 或在已定义Unicode应的用程序中 TCHAR * p = _T(&quot;This is a test&quot;); 或 LPTSTR p = _T(&quot;This is a test&quot;); CString theString = chArray; theString.Format(_T(&quot;%s&quot;), chArray); theString = p; (2) CString转换成char* 若将CString类转换成char*(LPSTR)类型，常常使用下列三种方法： 方法一，使用强制转换。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz =(LPTSTR)(LPCTSTR)theString; 方法二，使用strcpy。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz = new TCHAR[theString.GetLength()+1]; _tcscpy(lpsz, theString); 需要说明的是，strcpy(或可移值Unicode/MBCS的_tcscpy)的第二个参数是 const wchar_t* (Unicode)或const char* (ANSI)，系统编译器将会自动对其进行转换。 方法三，使用CString::GetBuffer。例如： CString s(_T(&quot;This is a test &quot;)); LPTSTR p = s.GetBuffer(); // 在这里添加使用p的代码 if(p != NULL) *p = _T(&apos;/0&apos;); s.ReleaseBuffer(); // 使用完后及时释放，以便能使用其它的CString成员函数 (3) BSTR转换成char* 方法一，使用ConvertBSTRToString。例如： #include #pragma comment(lib, &quot;comsupp.lib&quot;) int _tmain(int argc, _TCHAR* argv[])&#123; BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); char* lpszText2 = _com_util::ConvertBSTRToString(bstrText); SysFreeString(bstrText); // 用完释放 delete[] lpszText2; return 0; &#125; 方法二，使用_bstr_t的赋值运算符重载。例如： _bstr_t b = bstrText; char* lpszText2 = b; (4) char*转换成BSTR 方法一，使用SysAllocString等API函数。例如： BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); BSTR bstrText = ::SysAllocStringLen(L&quot;Test&quot;,4); BSTR bstrText = ::SysAllocStringByteLen(&quot;Test&quot;,4); 方法二，使用COleVariant或_variant_t。例如： //COleVariant strVar(&quot;This is a test&quot;); _variant_t strVar(&quot;This is a test&quot;); BSTR bstrText = strVar.bstrVal; 方法三，使用_bstr_t，这是一种最简单的方法。例如： BSTR bstrText = _bstr_t(&quot;This is a test&quot;); 方法四，使用CComBSTR。例如： BSTR bstrText = CComBSTR(&quot;This is a test&quot;); 或 CComBSTR bstr(&quot;This is a test&quot;); BSTR bstrText = bstr.m_str; 方法五，使用ConvertStringToBSTR。例如： char* lpszText = &quot;Test&quot;; BSTR bstrText = _com_util::ConvertStringToBSTR(lpszText); (5) CString转换成BSTR 通常是通过使用CStringT::AllocSysString来实现。例如： CString str(&quot;This is a test&quot;); BSTR bstrText = str.AllocSysString(); … SysFreeString(bstrText); // 用完释放 (6) BSTR转换成CString 一般可按下列方法进行： BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); CStringA str; str.Empty(); str = bstrText; 或 CStringA str(bstrText); (7) ANSI、Unicode和宽字符之间的转换 方法一，使用MultiByteToWideChar将ANSI字符转换成Unicode字符，使用WideCharToMultiByte将Unicode字符转换成ANSI字符。 方法二，使用“_T”将ANSI转换成“一般”类型字符串，使用“L”将ANSI转换成Unicode，而在托管C++环境中还可使用S将ANSI字符串转换成String*对象。例如： TCHAR tstr[] = _T(&quot;this is a test&quot;); wchar_t wszStr[] = L&quot;This is a test&quot;; String* str = S”This is a test”; 方法三，使用ATL 7.0的转换宏和类。ATL7.0在原有3.0基础上完善和增加了许多字符串转换宏以及提供相应的类，它具有如图3所示的统一形式： 其中，第一个C表示“类”，以便于ATL 3.0宏相区别，第二个C表示常量，2表示“to”，EX表示要开辟一定大小的缓冲。SourceType和DestinationType可以是A、 T、W和OLE，其含义分别是ANSI、Unicode、“一般”类型和OLE字符串。例如，CA2CT就是将ANSI转换成一般类型的字符串常量。下面是一些示例代码： LPTSTR tstr= CA2TEX&lt;16&gt;(&quot;this is a test&quot;); LPCTSTR tcstr= CA2CT(&quot;this is a test&quot;); wchar_t wszStr[] = L&quot;This is a test&quot;; char* chstr = CW2A(wszStr); 六、结语几乎所有的程序都要用到字符串，而Visual C++.NET由于功能强大、应用广泛，因而字符串之间的转换更为频繁。本文几乎涉及到目前的所有转换方法。当然对于.NET框架来说，还可使用Convert和Text类进行不同数据类型以及字符编码之间的相互转换。int i = 100;long l = 2001;float f=300.2;double d=12345.119;char username[]=&quot;程佩君&quot;;char temp[200];char *buf;CString str;_variant_t v1;_bstr_t v2;一、其它数据类型转换为字符串 短整型(int)itoa(i,temp,10);///将i转换为字符串放入temp中,最后一个数字表示十进制itoa(i,temp,2); ///按二进制方式转换长整型(long)ltoa(l,temp,10);浮点数(float,double)用fcvt可以完成转换,这是MSDN中的例子:int decimal, sign; char *buffer; double source = 3.1415926535; buffer = _fcvt( source, 7, &amp;decimal, &amp;sign ); 运行结果:source: 3.1415926535 buffer: &apos;31415927&apos; decimal: 1 sign: 0decimal表示小数点的位置,sign表示符号:0为正数，1为负数CString变量str = &quot;2008北京奥运&quot;;buf = (LPSTR)(LPCTSTR)str;BSTR变量BSTR bstrValue = ::SysAllocString(L&quot;程序员&quot;); char * buf = _com_util::ConvertBSTRToString(bstrValue); SysFreeString(bstrValue); AfxMessageBox(buf); delete(buf);CComBSTR变量CComBSTR bstrVar(&quot;test&quot;); char *buf = _com_util::ConvertBSTRToString(bstrVar.m_str); AfxMessageBox(buf); delete(buf);_bstr_t变量_bstr_t类型是对BSTR的封装，因为已经重载了=操作符，所以很容易使用_bstr_t bstrVar(&quot;test&quot;); const char *buf = bstrVar;///不要修改buf中的内容 AfxMessageBox(buf);通用方法(针对非COM数据类型)用sprintf完成转换char buffer[200];char c = &apos;1&apos;;int i = 35;long j = 1000;float f = 1.7320534f;sprintf( buffer, &quot;%c&quot;,c);sprintf( buffer, &quot;%d&quot;,i);sprintf( buffer, &quot;%d&quot;,j);sprintf( buffer, &quot;%f&quot;,f);二、字符串转换为其它数据类型strcpy(temp,&quot;123&quot;);短整型(int)i = atoi(temp);长整型(long)l = atol(temp);浮点(double)d = atof(temp);CString变量CString name = temp;BSTR变量 BSTR bstrValue = ::SysAllocString(L&quot;程序员&quot;); ...///完成对bstrValue的使用SysFreeString(bstrValue);CComBSTR变量CComBSTR类型变量可以直接赋值CComBSTR bstrVar1(&quot;test&quot;);CComBSTR bstrVar2(temp);_bstr_t变量_bstr_t类型的变量可以直接赋值_bstr_t bstrVar1(&quot;test&quot;); _bstr_t bstrVar2(temp);三、其它数据类型转换到CString使用CString的成员函数Format来转换,例如:整数(int)str.Format(&quot;%d&quot;,i);浮点数(float)str.Format(&quot;%f&quot;,i);字符串指针(char *)等已经被CString构造函数支持的数据类型可以直接赋值str = username;对于Format所不支持的数据类型，可以通过上面所说的关于其它数据类型转化到char *的方法先转到char *，然后赋值给CString变量。四、BSTR、_bstr_t与CComBSTRCComBSTR 是ATL对BSTR的封装，_bstr_t是C++对BSTR的封装,BSTR是32位指针,但并不直接指向字串的缓冲区。char *转换到BSTR可以这样: BSTR b=_com_util::ConvertStringToBSTR(&quot;数据&quot;);///使用前需要加上comutil.h和comsupp.libSysFreeString(bstrValue); 反之可以使用char *p=_com_util::ConvertBSTRToString(b);delete p;具体可以参考一，二段落里的具体说明。CComBSTR与_bstr_t对大量的操作符进行了重载，可以直接进行=,!=,==等操作，所以使用非常方便。特别是_bstr_t,建议大家使用它。五、VARIANT 、_variant_t 与 COleVariantVARIANT的结构可以参考头文件VC98/Include/OAIDL.H中关于结构体tagVARIANT的定义。对于VARIANT变量的赋值：首先给vt成员赋值，指明数据类型，再对联合结构中相同数据类型的变量赋值，举个例子：VARIANT va;int a=2001;va.vt=VT_I4;///指明整型数据va.lVal=a; ///赋值对于不马上赋值的VARIANT，最好先用Void VariantInit(VARIANTARG FAR* pvarg);进行初始化,其本质是将vt设置为VT_EMPTY,下表我们列举vt与常用数据的对应关系:Byte bVal;// VT_UI1.Short iVal;// VT_I2.long lVal;// VT_I4.float fltVal;// VT_R4.double dblVal;// VT_R8.VARIANT_BOOL boolVal;// VT_BOOL.SCODE scode;// VT_ERROR.CY cyVal;// VT_CY.DATE date;// VT_DATE.BSTR bstrVal;// VT_BSTR.DECIMAL FAR* pdecVal// VT_BYREF|VT_DECIMAL.IUnknown FAR* punkVal;// VT_UNKNOWN.IDispatch FAR* pdispVal;// VT_DISPATCH.SAFEARRAY FAR* parray;// VT_ARRAY|*.Byte FAR* pbVal;// VT_BYREF|VT_UI1.short FAR* piVal;// VT_BYREF|VT_I2.long FAR* plVal;// VT_BYREF|VT_I4.float FAR* pfltVal;// VT_BYREF|VT_R4.double FAR* pdblVal;// VT_BYREF|VT_R8.VARIANT_BOOL FAR* pboolVal;// VT_BYREF|VT_BOOL.SCODE FAR* pscode;// VT_BYREF|VT_ERROR.CY FAR* pcyVal;// VT_BYREF|VT_CY.DATE FAR* pdate;// VT_BYREF|VT_DATE.BSTR FAR* pbstrVal;// VT_BYREF|VT_BSTR.IUnknown FAR* FAR* ppunkVal;// VT_BYREF|VT_UNKNOWN.IDispatch FAR* FAR* ppdispVal;// VT_BYREF|VT_DISPATCH.SAFEARRAY FAR* FAR* pparray;// VT_ARRAY|*.VARIANT FAR* pvarVal;// VT_BYREF|VT_VARIANT.void FAR* byref;// Generic ByRef.char cVal;// VT_I1.unsigned short uiVal;// VT_UI2.unsigned long ulVal;// VT_UI4.int intVal;// VT_INT.unsigned int uintVal;// VT_UINT.char FAR * pcVal;// VT_BYREF|VT_I1.unsigned short FAR * puiVal;// VT_BYREF|VT_UI2.unsigned long FAR * pulVal;// VT_BYREF|VT_UI4.int FAR * pintVal;// VT_BYREF|VT_INT.unsigned int FAR * puintVal;//VT_BYREF|VT_UINT._variant_t是VARIANT的封装类，其赋值可以使用强制类型转换，其构造函数会自动处理这些数据类型。使用时需加上#include &lt;comdef.h&gt;例如：long l=222;ing i=100;_variant_t lVal(l);lVal = (long)i;COleVariant的使用与_variant_t的方法基本一样，请参考如下例子：COleVariant v3 = &quot;字符串&quot;, v4 = (long)1999;CString str =(BSTR)v3.pbstrVal;long i = v4.lVal;六、其它一些COM数据类型根据ProgID得到CLSIDHRESULT CLSIDFromProgID( LPCOLESTR lpszProgID,LPCLSID pclsid);CLSID clsid;CLSIDFromProgID( L&quot;MAPI.Folder&quot;,&amp;clsid);根据CLSID得到ProgIDWINOLEAPI ProgIDFromCLSID( REFCLSID clsid,LPOLESTR * lplpszProgID); 例如我们已经定义了 CLSID_IApplication,下面的代码得到ProgIDLPOLESTR pProgID = 0;ProgIDFromCLSID( CLSID_IApplication,&amp;pProgID);...///可以使用pProgID CoTaskMemFree(pProgID);//不要忘记释放七、ANSI与UnicodeUnicode称为宽字符型字串,COM里使用的都是Unicode字符串。将ANSI转换到Unicode(1)通过L这个宏来实现，例如: CLSIDFromProgID( L&quot;MAPI.Folder&quot;,&amp;clsid);(2)通过MultiByteToWideChar函数实现转换,例如:char *szProgID = &quot;MAPI.Folder&quot;;WCHAR szWideProgID[128];CLSID clsid;long lLen = MultiByteToWideChar(CP_ACP,0,szProgID,strlen(szProgID),szWideProgID,sizeof(szWideProgID));szWideProgID[lLen] = &apos;/0&apos;; (3)通过A2W宏来实现,例如: USES_CONVERSION; CLSIDFromProgID( A2W(szProgID),&amp;clsid);将Unicode转换到ANSI(1)使用WideCharToMultiByte,例如:// 假设已经有了一个Unicode 串 wszSomeString... char szANSIString [MAX_PATH]; WideCharToMultiByte ( CP_ACP, WC_COMPOSITECHECK, wszSomeString, -1, szANSIString, sizeof(szANSIString), NULL, NULL ); (2)使用W2A宏来实现,例如:USES_CONVERSION;pTemp=W2A(wszSomeString);八、其它对消息的处理中我们经常需要将WPARAM或LPARAM等32位数据（DWORD)分解成两个16位数据（WORD),例如：LPARAM lParam;WORD loValue = LOWORD(lParam);///取低16位WORD hiValue = HIWORD(lParam);///取高16位对于16位的数据(WORD)我们可以用同样的方法分解成高低两个8位数据(BYTE),例如:WORD wValue;BYTE loValue = LOBYTE(wValue);///取低8位BYTE hiValue = HIBYTE(wValue);///取高8位两个16位数据（WORD）合成32位数据(DWORD,LRESULT,LPARAM,或WPARAM)LONG MAKELONG( WORD wLow, WORD wHigh );WPARAM MAKEWPARAM( WORD wLow, WORD wHigh ); LPARAM MAKELPARAM( WORD wLow, WORD wHigh );LRESULT MAKELRESULT( WORD wLow, WORD wHigh );两个8位的数据(BYTE)合成16位的数据(WORD)WORD MAKEWORD( BYTE bLow, BYTE bHigh );从R(red),G(green),B(blue)三色得到COLORREF类型的颜色值COLORREF RGB( BYTE byRed,BYTE byGreen,BYTE byBlue );例如COLORREF bkcolor = RGB(0x22,0x98,0x34);从COLORREF类型的颜色值得到RGB三个颜色值BYTE Red = GetRValue(bkcolor); ///得到红颜色BYTE Green = GetGValue(bkcolor); ///得到绿颜色BYTE Blue = GetBValue(bkcolor); ///得到兰颜色九、注意事项假如需要使用到ConvertBSTRToString此类函数,需要加上头文件comutil.h,并在setting中加入comsupp.lib或者直接加上#pragma comment( lib, &quot;comsupp.lib&quot; )后记：本文匆匆写成，错误之处在所难免，欢迎指正.关于把BSTR类型数据转换成CString 类型数据时的问题?当我在把BSTR类型数据转换成CString 或 “char* 类型”数据时，发现在BSTR类型字符串较短的情况下没问题，当较长时就会出现内存读写错了。（在NT，2000下都测试是这样的。）根据你所说：1）字符串指针(char *)等已经被CString构造函数支持的数据类型 可以直接赋值 str = username;2）当b 为BSTR类型时可以使用char *p=_com_util::ConvertBSTRToString(b);于是以下是对的：CString cstr;BSTR bstr;....cstr=com_util::ConvertBSTRToString(bstr);...可是当bstr非常大时（其实，较大时就会）就会出现内存读写错，不知何故。此外我发现cstr=com_util::ConvertBSTRToString(bstr);可以简化为 cstr=bstr; 但当bstr较大时同样出现这个问题。请兄弟帮忙！急。谢谢！如何转化((list*)fileip.bian)-&gt;liang关于把CString转化成LPCTSTR的问题 作者:jakiesun 发表日期:2001-9-5 20:08:48我记的我以前写过这样一段代码void function()&#123;CString str,str1,str2;function((char*)(LPCTSTR)str1);str=str1;...//调试道此发现str2的值随着str的改变而改变，请问能解释一下为什么，如有回答，请通知wangshaohong@sohu.com,tx先&#125;添加lib支持 作者:磨刀霍霍 发表日期:2001-9-10 11:32:12如果不添加会产生错误，在setting中加入comsupp.lib或者直接#pragma comment( lib, &quot;comsupp.lib&quot; )微软认为缺省的设置call convention如果不设置成__cdecl也会出现同样的错误。1。int 转成cstring ？？回复人： caigzhi(caigzhi) (2001-10-17 11:27:35) 得0分 CString 的成员函数Format()int a = 2131;CString str;str.Format(&quot;%d&quot;,a);回复人： tenchi(C与C++之间) (2001-10-17 11:32:12) 得0分 int i=2001;char str[10];_itoa(i,str,10);CString szString=str; 回复人： fiolin(幽深的水) (2001-10-17 11:45:40) 得0分 他们两个的都可以！！ 回复人： sohucsdnvc(thanks) (2001-10-17 13:24:17) 得0分 那如何把double转成cstring 回复人： yihugang(小虎子) (2001-10-17 13:29:15) 得6分 int i = 2131;char *c=new char[20];CString str;sprintf(c,&apos;%d&apos;,i);str=*c;回复人： Gu_c_h(Gu) (2001-10-17 14:07:17) 得0分 用 _gcvt 下面是 msdn 的例子Example/* _GCVT.C: This program converts -3.1415e5* to its string representation.*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void main( void )&#123;char buffer[50];double source = -3.1415e5;_gcvt( source, 7, buffer );printf( &quot;source: %f buffer: &apos;%s&apos;/n&quot;, source, buffer );_gcvt( source, 7, buffer );printf( &quot;source: %e buffer: &apos;%s&apos;/n&quot;, source, buffer );&#125;Outputsource: -314150.000000 buffer: &apos;-314150.&apos;source: -3.141500e+005 buffer: &apos;-314150.&apos;回复人： Gu_c_h(Gu) (2001-10-17 14:49:56) 得6分 int a = -3.1415e5;CString str;str.Format(&quot;%f&quot;,a); 回复人： ruixp(锐剑) (2001-10-17 15:06:48) 得6分 CString 的成员函数Format()int a = 2131;CString str;str.Format(&quot;%d&quot;,a);2。基类对象怎么能转换成派生类对象？int CDaoListView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123;lpCreateStruct-&gt;style |= LVS_REPORT |LVS_EDITLABELS;if (CListView::OnCreate(lpCreateStruct) == -1)return -1;//////////// 创建ImageList;CDaoViewApp * pApp = (CDaoViewApp *) AfxGetApp();m_pImageList = new CImageList();ASSERT(m_pImageList !=NULL);m_pImageList-&gt;Create(16,16,TRUE,4,4);m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_KEY));m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_ICON4));m_pImageList-&gt;Add(pApp-&gt;LoadIcon(IDI_ICON5));CListCtrlEx&amp; ctlList = (CListCtrlEx&amp;) GetListCtrl();//我不懂的就这句，cListCtrlEx看下面的声明。ctlList.SetImageList (m_pImageList, LVSIL_SMALL) ;////////////return 0;&#125;class CListCtrlEx : public CListCtrl//类cListCtrlEx定义。&#123;.....&#125;class CDaoListView : public CListView//cDaoListView定义！&#123;...&#125;注：我的问题是GetListCtrl()返回的是一个cListCtrl对象的引用,怎么能把它转换成一个它的派生类对象的引用？c++的类型转换怎么支持？ 回复贴子： 回复人： lhj(努力加油) (2002-1-29 18:56:06) 得0分 CListCtrlEx&amp; ctlList = (CListCtrlEx&amp;) GetListCtrl();这是强制类型转换，&amp;表示是一个引用，lctList的值在这次赋值后不能被修改。回复人： wwwsq(wwwsq) (2002-1-29 19:09:22) 得0分 建议你找本C++方面的书看看，VC虽然号称可视，实际上C++基础还是很重要的。回复人： xcopy(xcopy) (2002-1-29 19:26:16) 得0分 用dynamic_cast()可以安全的转换。 3。如何在CString和double之间转换？要求转换之后能保留小数点，保留正负号？？cstring::format(%.xe) x为精度位 回复人： pchaos(杂讲) (2002-1-28 11:21:46) 得0分 CString str;double db;str = &quot;123.456&quot;;db = atof((LPCTSTR)str); 回复人： hgw111(hg) (2002-1-28 11:52:57) 得0分 CString -&gt; double : atofdouble -&gt;CString :Format 回复人： pchaos(杂讲) (2002-1-28 13:46:04) 得0分 CString str;double db;str = &quot;123.456&quot;;db = atof((LPCTSTR)str); db = 777.999;str.format(&quot;%e&quot;, db); 4。字符型要转换成int？？atoi(str) 5。_bstr_t 到 unsigned int？？_bstr_t str;unsigned int Length=6;Length=Length-str.length(); 6。VARIANT类型转换问题？我在使用MSCOMM中SetOutput()函数时形参必须为VARIANT变量如何将其它的数据类型转换为VARIANT类型？如：Cstring-&gt;VARIANT、 *char-&gt;VARIANT我对VARIANT的类型结构体不太熟，请讲详细些（最好有范例），谢谢！回复贴子： 回复人： vc_xiaoxin(小新) (2001-12-26 15:43:57) 得0分 VARIANT本身是一个复杂的结构，别的数据怎么转呀？关注 回复人： mpg_liu(星仁) (2001-12-27 18:33:50) 得10分 定义一个VARIANT变量后，他应该是一个结构体变量，其中有一个成员是字符型的，给这个成员赋值 回复人： LLnju(LLnju) (2001-12-27 18:36:10) 得0分 实在不清楚嘛就用 _variant_t , COleVariant 这些东东嘛，很好用的啊 回复人： softarts(CDMA2000) (2001-12-27 18:41:32) 得10分 构造一个就行了。VARIANT varXX;CString strYY;varXX.vt=VT_BSTR;varXX.bstrVal = strYY.allocsysstring();应该可以了。回复人： softarts(CDMA2000) (2001-12-27 18:42:11) 得0分 我也觉得COleVariant要好用一些，呵呵，我都用它。 回复人： bobofu(有问题要问) (2001-12-27 19:32:18) 得10分 CString str;_variant_t var;var = _variant_t(str); 7。COleVarant 如何转换为 CString?CString 如何转换为 char *CString 如何转换为 char[xx] ？？CString 如何转换为 char * wsprintf或者＝CString 如何转换为 char[xx] strcpy（） 回复人： SecretGarden(天堂鸟) (2002-1-14 11:55:23) 得0分 COleVarant封装了VAREANT类型。VAREANT类型其实是个巨大地Union，里面自然有你想要地unsigned char *类型。CString地GetBuffer和Format可以实现你的后两个问题8。v_variant_t类型转换成cstring总提示我cstring未定义程序如下_variant_t vfirstname;//存储的是数据库中的数据CString str;//提示出错vfirstname=pRs-&gt;GetCollect (_variant_t(&quot;Phone_Num&quot;));vfirstname.ChangeType (VT_BSTR);str=vfirstname.bstrVal;//提示出错 回复贴子： 回复人： hydnoahark(诺亚方舟) (2001-11-12 11:56:51) 得10分 &gt;&gt;CString str;//提示出错要求include &lt;afx.h&gt;并且设置Use run-time Library为Multithreaded 回复人： zhengyun_ustc(^-^) (2001-11-12 12:04:39) 得15分 CString未定义，说明你的工程没有引用MFC！！要想使你的工程支持MFC，请按照以下步骤作：1：在你的stdafx.h的头文件中加入：#include &quot;afxtempl.h&quot;这是一个囊括了MFC的集合定义的头文件，有了它，你的工程就识别Cstring类了。2：在你的工程设置中，在General页中，选择“MFC”为“Using MFC in a shared DLL”OK，现在再编译你的工程即可。 回复人： zhengyun_ustc(^-^) (2001-11-12 12:06:56) 得5分 _variant_t的bstrVal成员是BSTR类型。它是一个指向一个OLECHART*的指针。 回复人： vickowang(小苍) (2001-11-12 12:48:21) 得5分 (char *)_bstr_t(vfirstname) 回复人： smallfool(smallfool) (2001-11-12 13:52:54) 得4分 或许你还需要一个从UNICODE字符到ANSI字符的转变函数 回复人： sun_1112(萧) (2001-11-12 17:34:44) 得0分 谢谢大家给我这么大的支持！：） 回复人： zhengyun_ustc(^-^) (2001-11-14 13:24:07) 得0分 用vickowang(小苍)的意见可能会有问题，转换出的字符串应该是乱码。因为(char *)转换需要一个const的字符串资源，才能强制转换。所以应该：_bstr_t bstrTemp = _bstr_t(vfirstname.bstrVal);TCHAR szTemp[MAX_PATH];szTemp = (char*)bstrTemp;9。char * 转换为TCHAR类型？？直接转换,TCHAR相当于char了char * s;TCHAR * s1=(TCHAR *)s; 回复人： dysxq() (2001-12-21 21:26:25) 得0分 要看你的程序设置是ANSI还是UNICODE, 如果是ANSI,直接转,如果是UNICODE,TCHAR相当于WCHAR, 要用mbstowcsz转一下 回复人： xiaoxiaohan(萧晓寒) (2001-12-21 23:52:17) 得0分 Unicode ：宽字节字符集1. 如何取得一个既包含单字节字符又包含双字节字符的字符串的字符个数？可以调用Microsoft Visual C++的运行期库包含函数_mbslen来操作多字节（既包括单字节也包括双字节）字符串。调用strlen函数，无法真正了解字符串中究竟有多少字符，它只能告诉你到达结尾的0之前有多少个字节。2. 如何对DBCS（双字节字符集）字符串进行操作？函数 描述PTSTR CharNext （ LPCTSTR ）; 返回字符串中下一个字符的地址PTSTR CharPrev （ LPCTSTR, LPCTSTR ）； 返回字符串中上一个字符的地址BOOL IsDBCSLeadByte( BYTE )； 如果该字节是DBCS字符的第一个字节，则返回非0值3. 为什么要使用Unicode？（1） 可以很容易地在不同语言之间进行数据交换。（2） 使你能够分配支持所有语言的单个二进制.exe文件或DLL文件。（3） 提高应用程序的运行效率。Windows 2000是使用Unicode从头进行开发的，如果调用任何一个Windows函数并给它传递一个ANSI字符串，那么系统首先要将字符串转换成Unicode，然后将Unicode字符串传递给操作系统。如果希望函数返回ANSI字符串，系统就会首先将Unicode字符串转换成ANSI字符串，然后将结果返回给你的应用程序。进行这些字符串的转换需要占用系统的时间和内存。通过从头开始用Unicode来开发应用程序，就能够使你的应用程序更加有效地运行。Windows CE 本身就是使用Unicode的一种操作系统，完全不支持ANSI Windows函数Windows 98 只支持ANSI，只能为ANSI开发应用程序。Microsoft公司将COM从16位Windows转换成Win32时，公司决定需要字符串的所有COM接口方法都只能接受Unicode字符串。4. 如何编写Unicode源代码？Microsoft公司为Unicode设计了WindowsAPI，这样，可以尽量减少代码的影响。实际上，可以编写单个源代码文件，以便使用或者不使用Unicode来对它进行编译。只需要定义两个宏（UNICODE和_UNICODE），就可以修改然后重新编译该源文件。_UNICODE宏用于C运行期头文件，而UNICODE宏则用于Windows头文件。当编译源代码模块时，通常必须同时定义这两个宏。5. Windows定义的Unicode数据类型有哪些？数据类型 说明WCHAR Unicode字符PWSTR 指向Unicode字符串的指针PCWSTR 指向一个恒定的Unicode字符串的指针对应的ANSI数据类型为CHAR，LPSTR和LPCSTR。ANSI/Unicode通用数据类型为TCHAR，PTSTR,LPCTSTR。6. 如何对Unicode进行操作？字符集 特性 实例ANSI 操作函数以str开头 strcpyUnicode 操作函数以wcs开头 wcscpyMBCS 操作函数以_mbs开头 _mbscpyANSI/Unicode 操作函数以_tcs开头 _tcscpy（C运行期库）ANSI/Unicode 操作函数以lstr开头 lstrcpy（Windows函数）所有新的和未过时的函数在Windows2000中都同时拥有ANSI和Unicode两个版本。ANSI版本函数结尾以A表示；Unicode版本函数结尾以W表示。Windows会如下定义：#ifdef UNICODE#define CreateWindowEx CreateWindowExW#else#define CreateWindowEx CreateWindowExA#endif // !UNICODE7. 如何表示Unicode字符串常量？字符集 实例ANSI “string”Unicode L“string”ANSI/Unicode T(“string”)或_TEXT(“string”)if( szError[0] == _TEXT(‘J’) )&#123; &#125;8. 为什么应当尽量使用操作系统函数？这将有助于稍稍提高应用程序的运行性能，因为操作系统字符串函数常常被大型应用程序比如操作系统的外壳进程Explorer.exe所使用。由于这些函数使用得很多，因此，在应用程序运行时，它们可能已经被装入RAM。如：StrCat，StrChr，StrCmp和StrCpy等。9. 如何编写符合ANSI和Unicode的应用程序？（1） 将文本串视为字符数组，而不是chars数组或字节数组。（2） 将通用数据类型（如TCHAR和PTSTR）用于文本字符和字符串。（3） 将显式数据类型（如BYTE和PBYTE）用于字节、字节指针和数据缓存。（4） 将TEXT宏用于原义字符和字符串。（5） 执行全局性替换（例如用PTSTR替换PSTR）。（6） 修改字符串运算问题。例如函数通常希望在字符中传递一个缓存的大小，而不是字节。这意味着不应该传递sizeof(szBuffer),而应该传递（sizeof(szBuffer)/sizeof(TCHAR)。另外，如果需要为字符串分配一个内存块，并且拥有该字符串中的字符数目，那么请记住要按字节来分配内存。这就是说，应该调用malloc(nCharacters *sizeof(TCHAR)),而不是调用malloc(nCharacters)。10. 如何对字符串进行有选择的比较？通过调用CompareString来实现。标志 含义NORM_IGNORECASE 忽略字母的大小写NORM_IGNOREKANATYPE 不区分平假名与片假名字符NORM_IGNORENONSPACE 忽略无间隔字符NORM_IGNORESYMBOLS 忽略符号NORM_IGNOREWIDTH 不区分单字节字符与作为双字节字符的同一个字符SORT_STRINGSORT 将标点符号作为普通符号来处理11. 如何判断一个文本文件是ANSI还是Unicode？判断如果文本文件的开头两个字节是0xFF和0xFE，那么就是Unicode，否则是ANSI。12. 如何判断一段字符串是ANSI还是Unicode？用IsTextUnicode进行判断。IsTextUnicode使用一系列统计方法和定性方法，以便猜测缓存的内容。由于这不是一种确切的科学方法，因此 IsTextUnicode有可能返回不正确的结果。13. 如何在Unicode与ANSI之间转换字符串？Windows函数MultiByteToWideChar用于将多字节字符串转换成宽字符串；函数WideCharToMultiByte将宽字符串转换成等价的多字节字符串。回复人： xtky_limi(痛在心中笑在脸上) (2001-12-22 0:35:58) 得0分 上面说的已经比较全了。 回复人： xtky_limi(痛在心中笑在脸上) (2001-12-22 0:38:13) 得0分 TEXT是宏相当于L##它可以根据编译环境确定为DBMS,还是UNICODE字符集10。int类型转换为CString类型？回复人： tjmxf(天涯) (2001-12-17 19:59:34) 得0分 itoa() 回复人： zf925(天下哪来那么多高手) (2001-12-17 20:00:30) 得22分 char m[20];str=str + itoa(i,m,10); 回复人： yuezifeng(wybzd) (2001-12-17 20:00:50) 得22分 CString str;str.Format(&quot;%d&quot;,i);回复人： kingfish(今飞) (2001-12-17 20:06:27) 得0分 str.Format(&quot;%s%d&quot;,str,i); 回复人： tanyajun(谈子) (2001-12-17 20:09:25) 得0分 CString str=&quot;test&quot;;int i=11;CString str1;str1.Format(&quot;%d&quot;,i);str = str+str1;回复人： guanjinke(纶巾客) (2001-12-17 20:10:42) 得0分 int i=11;CString str=&quot;test&quot;;CString addition;addition.Format(&quot;%d&quot;,i);str+=addition;就可以了。 11。关于sprintf类型转换的问题sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%&apos;&quot;,t_date)其中t_date是CTime类型，%后面应该是什么呢？%s是String类型,%c是char,那么CTime型对应的是什么呢？ 回复人： yakai(日落长河) (2001-12-17 17:45:47) 得0分 sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%S&apos;&quot;,(LPCSTR)t_date.Format( &quot;%A, %B %d, %Y&quot; ));如果不行，就char temp[50];CString str=t_date.Format( &quot;%A, %B %d, %Y&quot; );strcpy(temp,(LPCSTR)str);sprintf(buf,&quot;select price from ls01 where p_date&gt;=&apos;%S&apos;&quot;,temp);CTime::Format返回CString 回复人： loh(乐啸天涯) (2001-12-17 17:52:57) 得0分 waitdon&apos;t know 回复人： masterz() (2001-12-17 20:21:05) 得0分 SQL语句中日期要写成字符串&quot;yyyymmdd&quot; 12。类型转换 unsigned int &lt;==&gt;CString??回复次数：8发表时间：2001-12-17 10:25:23unsigned int f;//unsigned int 0~4294967295CString g;f=2300000000;g.Format(&quot;%d&quot;,f);AfxMessageBox(g);出错。 回复人： ydogg(灰毛兔频频) (2001-12-17 10:31:29) 得0分 unsigned int f;//unsigned int 0~4294967295CString g;f=2300000000;g.Format(&quot;%d&quot;,f);MessageBox(g);//使用AfxMessageBox，需要窗口的句炳参数回复人： asdmusic8(asdmusic8) (2001-12-17 10:35:15) 得0分 我 AfxMessageBox(g); 和MessageBox(g); 都不错。错的是g.从 2300000000=》1994967296回复人： asdmusic8(asdmusic8) (2001-12-17 10:36:10) 得0分 是2300000000=》-1994967296 类型转换错。回复人： ydogg(灰毛兔频频) (2001-12-17 10:37:54) 得6分 g.Format(&quot;%u&quot;,f);回复人： asdmusic8(asdmusic8) (2001-12-17 10:40:24) 得0分 to dgsnmpoperate 那怎么从 CString ==&gt;&gt;unsigned int 回复人： kingfish(今飞) (2001-12-17 10:42:10) 得6分 既然是 unsigned int,超过 0x7f000000 (2130706432) 当然不能用 %d (signed int)用%u 回复人： kingfish(今飞) (2001-12-17 10:44:57) 得8分 CString ==&gt;&gt;unsigned int char *p = (LPSTR)(LPCSTR) g;f = atoi(p); 13。static_cast、dynamic_cast 和直接类型转换（如 (void *)p ）的区别?发表时间：2001-12-14 9:31:13先拷贝MSDN中的一小段话：class B &#123; ... &#125;;class C : public B &#123; ... &#125;;class D : public C &#123; ... &#125;;void f(D* pd)&#123;C* pc = dynamic_cast&lt;C*&gt;(pd); // ok: C is a direct base class// pc points to C subobject of pd B* pb = dynamic_cast&lt;B*&gt;(pd); // ok: B is an indirect base class// pb points to B subobject of pd ...&#125;我已经知道 static_cast 和 dynamic_cast 的作用，但MSDN中并没有提到这两个操作符与直接类型转换如void f(D* pd)&#123;C* pc = （C*）(pd);B* pb = （B*）(pd); ...&#125;的不同啊。不知道那位知道的告诉一声，在此不胜感谢，50分奉上。回复贴子：ysdesigned(清泉) (2001-12-14 10:03:07) 得0分 static_cast、dynamic_cast 代 替 简 单 的 强 制 转 化， 从 而 消 除 多 继 承 带 来 的 歧 义。 使 用 这 两 个 运 算 符 号， 我 们可以 在 对 象 运 行 过 程 中 获 取 对 象 的 类 型 信 息dynamic_cast 用于多态类型的转换static_cast 用于非多态类型的转换回复人： masterz() (2001-12-14 10:05:48) 得0分 static_cast&lt;...&gt;compile时能发现不正确的指针类型转换dynamic_cast&lt;...&gt;运行时如果发现是不正确的指针类型转换会返回NULL(void*)强制转换，如果是不正确的指针类型转换，没有办法检查，不如上面2中安全 回复人： meady() (2001-12-14 11:29:05) 得0分 类型安全 回复人： bluecrest(为什么我的VC还是那么的菜) (2001-12-14 11:45:34) 得0分 com技术内幕介绍过我刚看完就忘了 14。byte数据类型转换成int型??我用byte型读进一组数据想把他转成int型进行运算如何做呢?如果再把int型转回byte又怎么实现呢? 回复人： louifox(兰陵笑笑生) (2001-12-6 9:18:38) 得0分 用下面这些宏：WORD MAKEWORD(BYTE bLow, BYTE bHigh );BYTE LOBYTE(WORD wValue );BYTE HIBYTE(WORD wValue );回复人： chskim(大刀阔斧) (2001-12-6 9:21:04) 得0分 int i;BYTE b;b=128;i=(int)b;回复人： nannet(似的) (2001-12-6 9:38:24) 得0分 这个宏怎么用呀?有没有简单一点儿的，我现在能把BYTE 转成INT 型了，再转回去直接赋值可以吗？ 回复人： louifox(兰陵笑笑生) (2001-12-6 9:46:24) 得20分 WORD wa;BYTE ba=32,bb=64;wa=MAKEWORD(ba,bb);...WORD wa=1234;BYTE ba,bb;ba=LOBYTE(wa);bb=LOBYTE(wa);回复人： nannet(似的) (2001-12-6 9:54:55) 得0分 问题解决了，多谢各位 15。类型转换的问题，unsigned int --&gt; lptstr/lpctstr??发表时间：2001-8-7 23:49:41如果强制转换的话，会出现致命错误，有什么好的办法呢？能列举一些其他的办法吗？谢谢大虾！ 回复人： AlphaOne(总是第一个倒下) (2001-8-8 0:02:43) 得5分 你为什么要强行转换呢？如果你是要把int 的值作为 lptstr/lpctstr 的内容的话，可以用CString:unsigned int a = 100;LPCTSTR lpText;CString str;str.Format(&quot;%d&quot;,a);lpText = (LPCTSTR)str;回复人： tryibest(编の魂) (2001-8-8 8:20:20) 得5分 wsprintf(str,&quot;%u&quot;,ui); 回复人： zzh() (2001-8-8 9:04:39) 得5分 这种情况不需要进行强制转换，直接使用wsprintf就可以了。 回复人： GJA106(中文字符) (2001-8-8 10:10:51) 得5分 unsigned int m_na=22;LPTSTR lptstr;wsprintf(lptstr,&quot;%u&quot;,m_na);16。关于COM类型转换问题??我定义了两个变量，一个是void *piaRef=new unsigned char[1000];另一个是m_Temp=new CComVariant();我的问题是如何将piaRef中的值COPY到m_Temp中。 回复人： nichang() (2001-11-21 15:34:04) 得0分 CComBSTR bsRef=piaRef;m_Temp=bsRef.copy() 回复人： VincentChin(瘟神) (2001-11-21 17:04:24) 得0分 CComBSTR bsRef=piaRef;//error C2440: &apos;initializing&apos; : cannot convert from &apos;void *&apos; to &apos;class ATL::CComBSTR&apos;m_Temp=bsRef.copy();//error C2440: &apos;=&apos; : cannot convert from &apos;unsigned short *&apos; to &apos;class ATL::CComVariant *&apos; 回复人： nichang() (2001-11-21 17:14:28) 得0分 将void*改为unsigned char * 回复人： VincentChin(瘟神) (2001-11-21 17:22:22) 得0分 我用CComBSTR bsRef=(unsigned char*)piaRef，也不行吗？ 回复人： VincentChin(瘟神) (2001-11-21 17:28:06) 得0分 会报错：error C2440: &apos;type cast&apos; : cannot convert from &apos;unsigned char *&apos; to &apos;class ATL::CComBSTR&apos; 回复人： nichang() (2001-11-22 9:12:14) 得0分 m_Temp=::SysAllocString((OLECHAR *)piaRef) 回复人： VincentChin(瘟神) (2001-11-22 10:43:07) 得0分 //error C2440: &apos;=&apos; : cannot convert from &apos;unsigned short *&apos; to &apos;class ATL::CComVariant *&apos; 回复人： VincentChin(瘟神) (2001-11-22 11:22:35) 得0分 m_Temp=new CComVariant(::SysAllocString(OLECHAR *)piaRef));没有出错，但是我的m_Temp是COM组件中的一个PROPERTY，我想返回的是unsigned char类型（单字节），但经过上述转换后，就不再是单字节了呀！怎么办？ 回复人： jiangsheng(蒋晟) (2001-11-22 11:36:58) 得0分 把这个属性的类型改成BSTR 回复人： GrayWhite(灰白) (2001-11-22 12:01:09) 得0分 m_Temp = new CComVariant((char*) piaRef);就可以了。VB就是用的BSTR,你要给谁用阿？VC不用VARIANT的。 回复人： GrayWhite(灰白) (2001-11-22 12:18:18) 得19分 哦，我明白了，你要各字节数组：SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, 1000);if (!psa)_com_issue_error(ERROR_NOT_ENOUGH_MEMORY);HRESULT hrfor (long i = 0; i &lt; 2; i ++)&#123;if (FAILED (hr = SafeArrayPutElement(psa, &amp;i, piaRef + i)))_com_issue_error(hr);&#125;_variant_t va; // include &lt;comdef.h&gt;va.vt = VT_ARRAY | VT_UI1;va.parray = psa;m_Temp = new CComVariant(va); 回复人： VincentChin(瘟神) (2001-11-22 14:21:08) 得0分 SafeArrayPutElement(psa, &amp;i, piaRef + i)//error C2036: &apos;void *&apos; : unknown size 回复人： VincentChin(瘟神) (2001-11-22 14:46:05) 得0分 To GrayWhite:为什么要for(long i=0;i&lt;2;i++)? 回复人： nichang() (2001-11-22 15:16:35) 得0分 到底你想怎样转换嘛，是将数组内的值拷贝到CComVariant中存为字符串吗? 回复人： VincentChin(瘟神) (2001-11-22 15:28:35) 得0分 我是想把piaRef中的值照原样返回给其它程序使用。我正在做的是一个COM组件。谢谢各位！ 回复人： nichang() (2001-11-22 15:34:40) 得10分 unsigned char *s=new unsigned char[1000];strcpy((char*)s,&quot;1234&quot;);//可以用你自己方法设置s中的值。BSTR bstrS;oleS=A2WBSTR((char*)s);//将char*转换成BSTR类型CComVariant comVT;comVT=oleS;//将BSTR转成CComVariant,这里一步也可，comVT=A2WBSTR((char*)s);回复人： VincentChin(瘟神) (2001-11-22 16:54:07) 得0分 谢谢你！但我还有一个问题，就是如果在s中有&apos;/0&apos;之类的东西我该怎么返回呢？char *遇到&apos;/0&apos;会认为到头了。完整的设计是这样的，我定义一个void * 用来从一个外部设备获取数据，该数据应该是unsigned char，我想把这个返回的数据作为属性传出，让其它应用使用（如VB）。 回复人： nichang() (2001-11-22 17:18:09) 得0分 将&apos;/0&apos;转换成其它如&apos;/1&apos;就OK了， 回复人： jiangsheng(蒋晟) (2001-11-22 18:07:16) 得0分 用字符串数组 回复人： VincentChin(瘟神) (2001-11-23 15:54:39) 得0分 谢谢各位的回复！我的问题解决了！如下：SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, 1000);if (!psa)return S_FALSE;HRESULT hr;for (long i = 0; i &lt; 1000; i ++)if (FAILED (hr = SafeArrayPutElement(psa, &amp;i, ((unsigned char*)piaRefTemplate) + i)))return S_FALSE;VARIANT va;va.vt = VT_ARRAY | VT_UI1;va.parray = psa;CComVariant *m_Temp = new CComVariant();m_Temp-&gt;Copy(&amp;va);17。类型转换 static_cast reinterprete_cast 的区别??static_cast reinterprete_cast 的区别 回复人： tar(GPS) (2001-11-21 10:06:41) 得0分 static_cast会检查转换类型健的相关性如果没有的画会有编译错误reinterprete_cast就是硬转了 回复人： tigerwoods(tao) (2001-11-21 12:28:19) 得0分 是否可以这样理解：在多重继承中，static_cast可实现对象指针的移动，从而指向正确的父类对象部分，而reinterprete_cast不作偏移？ 回复人： liu_feng_fly(我恨死驱动程序了，哎，就是为了混口饭吃) (2001-11-21 12:35:14) 得0分 在多重继承中可以用dynamic_cast啊 18。那如何取得CString中的字符串？？回复人： nichang() (2001-11-5 17:06:00) 得0分 =(LPCTSTR)CString变量 回复人： snake1122(领悟) (2001-11-5 17:12:16) 得0分 方法太多了:GetAt,Left,Mid,Right等等，就看你怎么取了！ 回复人： dusb(保时捷) (2001-11-5 17:34:29) 得0分 可是不管是GetAt，Left，Mid，Right返回类型都是CString，还是不能用，我是要取其中的字符串，奇怪的是，VC中没有string类型。（我要的字符串是给树型控件中的分支名称） 回复人： Alps_lou(云飞扬) (2001-11-5 17:41:36) 得0分 有string类型的啊，要包含&lt;string&gt; 回复人： luxes() (2001-11-5 17:42:19) 得0分 加上(LPCTSTR)，相当于一个const char *了，还不能用？ 回复人： wt007(tt) (2001-11-5 17:48:33) 得0分 GetBuffer 回复人： espon99() (2001-11-5 17:54:06) 得20分 (LPSTR)(LPCTSTR)回复人： ineedyou(古寺僧) (2001-11-5 17:59:29) 得0分 ...m_str.GetBuffer(needlen)...;....m_str.ReleaseBuffer() 回复人： dusb(保时捷) (2001-11-6 15:08:36) 得0分 espon99大侠，果然是绝招，不过能否解释一下啊？ 19。如何从CString类型转换为Unicode string 类型？回复人： ychener(贫血) (2001-10-20 10:28:48) 得0分 CString本身就支持Unicode的。 只要你选择的是UniCode编译，生成的可执行程序就是支持UniCode的 回复人： ychener(贫血) (2001-10-20 10:30:04) 得0分 CString类是自适应的就像TCHAR一样，如果你定义了UniCode宏 就会以UniCode编译 回复人： xjl1980_81(阿龙) (2001-10-20 10:35:16) 得0分 不是呀，我有个函数中有一个参数需Unicode string 类型的，比如应该填L&quot;abc&quot;,而且引号中的内容要有变化，现在我有一个 temp变量，是CString类型的，如何用呀？ 回复人： xt_jat(桑巴) (2001-10-20 10:39:37) 得0分 _T()_TEXT()行不行？ 回复人： xjl1980_81(阿龙) (2001-10-20 10:43:18) 得0分 不行 回复人： Jeffery__Chen() (2001-10-20 11:04:53) 得0分 强制转化：CString temp;WCHAR wTemp = (WCHAR)temp; 回复人： xjl1980_81(阿龙) (2001-10-20 11:37:06) 得0分 to:Jeffery__Chen() 不对呀，出现不能转换的错误 回复人： hongzhh(关儿) (2001-10-20 11:39:42) 得0分 问题是这样的：temp 是 CString类型变量，值为zhh现在有一个API PCCERT_CONTEXT WINAPI CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, //此处用 L&quot;zhh&quot; 没问题 //请问怎么转换 可以 用tempPCCERT_CONTEXT pPrevCertContext );在此谢谢大家，请帮忙看看回复人： hongzhh(关儿) (2001-10-20 13:27:10) 得0分 WCHAR wszDomain[256]; MultiByteToWideChar( CP_ACP, 0, temp,strlen(temp)+1, wszUserName, sizeof(wszUserName)/sizeof(wszUserName[0]) );wszUserName就是转换后的值回复人： ychener(贫血) (2001-10-23 11:43:05) 得0分 只要你用的是CString的函数就行的，如果你要用类似strcpy函数时，看看MSDN中一般情况下都有响应的函数对于Unicode的。只要换成_tcscpy等等。 回复人： ychener(贫血) (2001-10-23 11:44:10) 得0分 你有没有定义Unicode宏？ 20。请问在用ATL且不支持MFC的组件开发中，如何将从数据库中读到的DATE数据类型转换回为字符串?? 复人： zhxuys(zhxuys) (2001-9-24 10:36:47) 得0分 ATL把datetime类型的列映射为DBTIMESTAMP类型，可取出该类型的year、month、day等，然后将这些数据传递回客户端，在客户端用CTime来构造 回复人： YUANXU(旭) (2001-9-24 11:18:14) 得0分 to zhxuys:CTime是MFC类，在ATL 不支持MFC时不能用。DATE其实质是个double* 回复人： zhxuys(zhxuys) (2001-9-24 11:57:01) 得0分 你在客户端与服务器端只用ATL规定的数据类型或VARIANT类型，而在客户端，可以用MFC来重新构造想要的数据结构 21。类型转换，CString to wchar_t ??CString ss(&quot;aabb&quot;);wchar_t* cc;cc=ss.AllocSysString();22。如何将CString类型转换为_bstr_t类型？回复人： wei97081116(韦小宝) (2001-9-4 11:19:30) 得20分 CString b;_bstr_t a;a=(_bstr_t)b; 回复人： zhaozhen1212(赵振) (2001-9-18 1:30:18) 得0分 _bstr_t a=b.AllocSysString();;23。如何把一个CString类型转换成一个普通的字符串，如char*?回复人： liu_feng_fly(我恨死驱动程序了，哎，就是为了混口饭吃) (2001-9-17 18:00:52) 得0分 所以，直接用就可以，因为类里边有这样的转换函数 回复人： ydogg(灰毛兔频频) (2001-9-17 18:01:21) 得0分 CString show;char *p = show.GetBuffer(show.GetLength()); 回复人： jiangping_zhu(娜可露露之风之刃) (2001-9-17 18:02:05) 得0分 (char*)(LPCTSTR)str 回复人： bmouse(老鼠) (2001-9-18 0:10:56) 得0分 同意楼上! 回复人： bmouse(老鼠) (2001-9-18 0:13:22) 得0分 你还可以通过GetBuff来直接操作CString的缓冲区,不过要记着释放缓冲区. 24。CString 类型转换成 unsigned char类型吗？？回复人： LJN(*)风流倜傥无人及，玉树偏又临风立(*) (2001-9-17 12:46:01) 得0分 可以用CString.GetBuffer函数 回复人： xpmao() (2001-9-17 13:09:09) 得0分 CString strWork;MessageBox(0,(LPSTR)strWork,0,0);或MessageBox(0,strWork.GetBuffer(0),0,0);回复人： sandd(降龙掌) (2001-9-17 13:17:32) 得0分 CString string;(LPCTSTR)string; 回复人： jeff_hunter(PandaLee) (2001-9-17 13:45:30) 得0分 (unsigned char *)(LPCTSTR) 回复人： fandh(好了) (2001-9-17 14:00:57) 得0分 用(unsigned char *)(LPCTSTR)即可 回复人： ygd(ygd) (2001-9-17 16:11:17) 得0分 unsigned char *p;CString str;int length=str.GetLength();for(int i=0;i&lt;length;i++)p[i]=str.GetAt(i); 回复人： swordbroken(断剑书生) (2001-9-17 16:25:57) 得0分 CString str;unsigned char string[30];strcpy(string,str); 25。何将一个unsigned int 类型变量值赋给类型为unsigned short的变量，并保证数值不丢失（当然数值在一定范围内)？回复人： maxsuy(魔法师兔子) (2001-8-14 16:37:30) 得0分 直接=就OK了 回复人： oppmm(ppmm) (2001-8-14 16:38:11) 得0分 直接赋值 回复人： milefo(弥勒佛) (2001-8-14 16:40:40) 得0分 如果数值在一定范围内怎么回丢失呢？unsigned short a;unsigned int b;a=( b &amp; 0xffff);你试试看吧！26。CString ----char* 定义了char* aa的变量，现在有一个CString的变量bb，怎样把bb的值赋给aa呢? 回复人： emmai(WaTaXiWaWaTaXi) (2001-8-10 11:57:33) 得0分 aa=bb.GetBuffer(); 回复人： hswqs(??????????????????) (2001-8-10 11:59:01) 得0分 aa= (LPSTR)(LPCTSTR)bb; 回复人： ydogg(灰毛兔) (2001-8-10 12:27:23) 得0分 1.aa=bb.GetBuffer(bb.GetLenth());//第一种方法2.aa= (LPSTR)(LPCTSTR)bb; //第二种方法 回复人： zhizhi() (2001-8-10 13:16:23) 得0分 aa= (char *)(LPCTSTR)bb,hehe 27。在一个COM的接口函数中有一个 BSTR* 类型的参数，需要把一个 char * 类型转换为 BSTR* 类型，不知道如何转换？ 由于调用这个函数后需要把这个参数值再取出来所以只能用指针，另外在调用的时候应该用什么类型的数据传递参数呢？大虾帮忙。BSTR bstr = SysAllocString(L&quot;字符串&quot;);这样转换,用的时候你用地址操作符&amp;啊，要不指针还得new 回复人： yongyue2000i(小吕) (2001-9-9 18:38:26) 得13分 CString str = &quot;abcd&quot;;BSTR bstr = str.AllocSysString(); 回复人： houjzs() (2001-9-9 19:14:44) 得13分 BSTR b = SysAllocString(OLESTR(&quot;your string&quot;));28。要把一个double的数字输出到CEdit控件是否需要类型转换？回复人： jiangsheng(蒋晟) (2001-8-24 14:46:17) 得0分 void AFXAPI DDX_Text( CDataExchange* pDX, int nIDC, double&amp; value ); 回复人： xiezhsh(雪中行) (2001-8-24 14:56:22) 得0分 假如你的ＣＥｄｉｔ相关的成员变量是Ｄｏｕｂｌｅ型的，那根本用不着．（ＣｌａｓｓＷｉｚａｒｄ增加成员变量的对话框中，Variable Type选择Double可） 回复人： xiezhsh(雪中行) (2001-8-24 14:58:16) 得0分 假如你的ＣＥｄｉｔ相关的成员变量不是Ｄｏｕｂｌｅ型的，是ＣＳｔｒｉｎｇ型，那就需要用ltoa()来转换成ＣＳｔｒｉｎｇ型， 回复人： haven(大天) (2001-8-24 14:58:32) 得0分 m_Edit.Fromat(&quot;%l&quot;,VarBouble);updatedata(false); 回复人： 12345678() (2001-8-24 14:59:54) 得0分 CString m_Edit.Format(&quot;%lf&quot;, doubleVar); GetDlgItem(EditID)-&gt;SetWindowText(m_strEdit); 29。该如何把 WINDOWPLACEMENT * 转换成 char **类型??(char**)&amp;pWP 30。怎样把CString的类型转换成char*型的？回复人： dcz(dcz) (2001-8-19 19:13:27) 得5分 // str is CString varchar* temp = strdup(str);...free(temp); 回复人： yu900(疾风之狼) (2001-8-19 19:57:25) 得0分 getbuffer()；即可！ 回复人： aileen_long(挑战2001) (2001-8-19 21:10:35) 得0分 同意楼上的意见！ 回复人： czh912() (2001-8-19 21:27:08) 得0分 char buf[20];printf(buf,&quot;%s&quot;,string);回复人： casl(casl) (2001-8-19 22:59:44) 得5分 CString s(&quot;abc&quot;);char* temp=s.GetBuffer(10);...s.ReleaseBuffer(); 回复人： cocia(高亚) (2001-8-19 23:04:23) 得0分 char* temp=s.GetBuffer(10);10是什么意思啊回复人： kevin_dong(梦仙人) (2001-8-20 10:26:35) 得0分 // str is CString varchar* temp = strdup(str);// freefree(temp); 我的这段代码在一个程序中能通过编译，但是在另外一个中总是出现cannot convert parameter 1 from &apos;class CString&apos; to &apos;const char *&apos;的错误。str和temp的类型都一样。这是为什么？回复人： dcz(dcz) (2001-8-20 14:13:45) 得0分 you may setting your compiler option to UNICODE, in this case, declare the var:// str is CString var_TCHAR* temp = _tcsdup(str);// freefree(str);31。SA,SB为两个结构类型??SA* A;SB* B;(SB*)A-&gt;...（调用函数）请问此时A的类型，是指向SA还是SB此时编译器是生成一个临时指针吗？另外，B=(SB*)A;此时A又是什么类型？？？回复贴子： 回复人： ddeng(登登) (2001-8-9 17:13:58) 得0分 A的类型始终是SA *B的类型始终是SB *当进行强制类型转换时使的是临时指针 回复人： gold_water(风雨无阻) (2001-8-9 17:30:46) 得0分 同意楼上的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438532。char buff[100],char UserName[50][100],怎么将buff的值传给UserName，是其成为UserName数组中的某一项呢？？//0=&lt;i&lt;50strcpy(UserName[i],buff); 回复人： Ashura(阿修罗) (2001-7-26 10:08:20) 得0分 呵呵，benbensan抢先一步。 回复人： tuita(斗牛士) (2001-7-26 10:13:22) 得0分 for (i=0;i&lt;100;i++)*(*(username+x)+i)=*(buffer+i)其中0《X〈50benbensan写的也对回复人： kekeke(我是来向大家学习的) (2001-7-26 10:24:22) 得0分 那反过来呢？把UserName中的某一项读出赋值给buff呢？怎么弄？ 回复人： benbensan(笨笨三) (2001-7-26 10:26:53) 得0分 //0=&lt;i&lt;50strcpy(UserName[i],buff); 回复人： benbensan(笨笨三) (2001-7-26 10:28:15) 得0分 对不起，能错了，不过建议你看一下C语言了的指针和数组//0=&lt;i&lt;50strcpy(buff,UserName[i]); 回复人： jfzsl(剿匪总司令) (2001-7-26 10:32:57) 得0分 好好看看老潭的书先！OK？ 回复人： kekeke(我是来向大家学习的) (2001-7-26 10:44:25) 得0分 好。。。。！ 33。请问怎样把SYSTEMTIME类型转换成time_t类型?SYSTEMTIME st;GetLocalTime(&amp;st);CTime tm(st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);time_t t = tm.GetTime();34。unsigned char Exponent[10]; //eunsigned long eBytes; //e的字节数如何转换成DWord型! ??用强制类型转换呀(DWord)eBeytes;(DWord)Exponent[i];//(0&lt;=i&lt;=10);回复人： xjl1980_81(阿龙) (2001-7-26 16:47:29) 得0分 我是说把e转换成DWORD型也就是说把Exponent中的内容转换成DWORD型回复人： cloudshadow1(云影) (2001-7-26 17:13:30) 得0分 用强制类型转换就可以了，（DWORD的高24位自动加0）DWORD Des[10]for (int i=0;i&lt;11;i++)Des[i]=Exponent[i];至于那个ULONG的也是用强制类型软换就可以了35。请问怎样把time_t类型转换成SYSTEMTIME类型？回复人： haven(大天) (2001-7-26 17:12:36) 得0分 typedef struct _SYSTEMTIMEtypedef long time_t很明显不行嘛！ 回复人： facexy(FACE仔) (2001-7-26 17:17:38) 得0分 哎呀，问错了，前后对象相反了；-（忙昏了的结果…………另外，TO 楼上的：转换是可以的struct tm *tblock;SYSTEMTIME SystemTime;memset(&amp;SystemTime,0,sizeof(SYSTEMTIME));tblock=localtime(&amp;timer);SystemTime.wYear=tblock-&gt;tm_year+1900;SystemTime.wMonth=tblock-&gt;tm_mon+1;SystemTime.wDay=tblock-&gt;tm_mday;SystemTime.wHour=tblock-&gt;tm_hour;SystemTime.wMinute=tblock-&gt;tm_min;SystemTime.wSecond=tblock-&gt;tm_sec;SystemTime.wDayOfWeek=tblock-&gt;tm_wday;return &amp;SystemTime; 回复人： zjh73(大章鱼) (2001-7-26 20:28:28) 得0分 有两种方法：1、用CTime类先用time_t类型构造一个CTime对象，再定义一个SYSTEMTIME结构，最后用CTime类的成员函数GetAsSystemTime将时间转换到SYSTEMTIME结构中即可。2、用gmtime函数gmtime函数将time_t时间转换到tm结构中并返回一个tm指针，再将tm结构的相对应的项赋给SYSTEMTIME相对应的项即可，不过用这种方法要注意这两种结构在天、星期等方面的记数方法有点区别，一个一般从0开始，一个一般从1开始，赋值时要注意校正，还有要注意的是SYSTEMTIME结构中有一项是毫秒，而time_t是以秒记数的。 回复人： zjh73(大章鱼) (2001-7-26 20:32:13) 得0分 反过来也可以用Ctime类的方法就是先用SYSTEMTIME结构构造一个CTime对象，在用CTime类中的成员函数GetTime返回一个对应的time_t即可。 36。我现在正在学习SDK编程，遇到的问题是：我定义了一个静态长整形变量，static long lScore=0;我想把窗口的标题换成长整形数值,用SetWindowText函数来实现，由于它的第二个参数要求数据类型为 unsigned short *,但用其来实现强制转换时总是出现编译错误：cannot convert parameter 2 from &apos;unsigned short *&apos; to &apos;const char *&apos;后来改成来LPCTSTR 来实现强制转换，没有出现编译错误，但函数总是执行不成功,请教各位高人，这倒底是怎么回事？？？回复贴子： 回复人： prog_st(st) (2001-8-4 21:20:07) 得0分 /* ITOA.C: This program converts integers of various* sizes to strings in various radixes.*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void main( void )&#123;char buffer[20];int i = 3445;long l = -344115L;unsigned long ul = 1234567890UL;_itoa( i, buffer, 10 );printf( &quot;String of integer %d (radix 10): %s/n&quot;, i, buffer );_itoa( i, buffer, 16 );printf( &quot;String of integer %d (radix 16): 0x%s/n&quot;, i, buffer );_itoa( i, buffer, 2 );printf( &quot;String of integer %d (radix 2): %s/n&quot;, i, buffer );_ltoa( l, buffer, 16 );printf( &quot;String of long int %ld (radix 16): 0x%s/n&quot;, l, buffer );_ultoa( ul, buffer, 16 );printf( &quot;String of unsigned long %lu (radix 16): 0x%s/n&quot;, ul,buffer );&#125;OutputString of integer 3445 (radix 10): 3445String of integer 3445 (radix 16): 0xd75String of integer 3445 (radix 2): 110101110101String of long int -344115 (radix 16): 0xfffabfcdString of unsigned long 1234567890 (radix 16): 0x499602d2回复人： lwg7603(刑满释放人员) (2001-8-4 21:36:15) 得0分 TCHAR str[255]=&#123;_T(&apos;/0&apos;)&#125;;_stprintf(str,_T(&quot;%d&quot;),lScore);SetWindowText(hwnd,str);37。我用socket发送的的buf中间需要的是 char *类型的数据，我想将一个 struct 直接转换成 char * 发过去。我用struct ABCD *abcd;char *buf;abcd = (ABCD *)calloc(1,sizeof(ABCD));buf = (char *)calloc(1,sizeof(ABCD));///给abcd 中间赋值，其中有多个char[]的值和int 的值///memcpy(buf,abcd,sizeof(ABCD));//strcpy(buf,(char *)abcd)；也不可以sock(host,buf,....);//sock(host,(char *)buf,...);也不可以问题就是在这里，这个buf中间的值总是不对，大家知道为什么否。回复人： wolf721() (2001-7-30 18:18:34) 得5分 你传的是个指针值，而不是数据 回复人： kiko_lee(到处瞧瞧) (2001-7-30 18:50:49) 得0分 但是用memcpy这个是将整个数据都复制过去 回复人： lz_0618(lz_0618) (2001-7-30 19:26:44) 得5分 你用的VC???改成ABCD *abcd;后编译一点问题也没有啊！sock(host,buf,....);这不知是什么，自定义函数？typedef struct _ABCD&#123;int ID;char Name[10];&#125;ABCD;.......ABCD *abcd;char *buf;abcd = (ABCD *)calloc(2,sizeof(ABCD));buf = (char *)calloc(2,sizeof(ABCD));/////给abcd 中间赋值，其中有多个char[]的值和int 的值abcd[0].ID =1;abcd[1].ID =2;///memcpy(buf,abcd,2*sizeof(ABCD));strcpy(buf,(char *)abcd);//也不可以buf中的内容也正确！！回复人： kiko_lee(到处瞧瞧) (2001-7-31 8:57:52) 得0分 我按照楼上的兄弟说的，做了一下，但是仍然做不下来，我用memcpy(buf,abcd,sizeof(ABCD));中间的abcd，不知道是不是地址的问题。 回复人： supersusheng(小苏) (2001-7-31 14:30:42) 得0分 老大，你sizeof()得出的数值事多大，看看吧。 回复人： ydogg(灰毛兔) (2001-7-31 14:41:52) 得0分 只能传递流数据，结构是传递不过去的。 回复人： IamNotMan(NorGirl) (2001-7-31 14:50:53) 得5分 我常这么用ABCD a ;//给a的各个域赋值（一定不能含有指针项）char* buff = new char[sizeof(ABCD)];memcpy(buff,&amp;a,sizeof(ABCD));//或者 *（ABCD*)buff = a;.................如果buff里的数对，说明问题不在这儿吧回复人： zb_china(最后一座水车zb_china新浪) (2001-7-31 15:16:24) 得0分 看不明白 回复人： eggplant(拉拉) (2001-7-31 15:42:48) 得0分 最好使用memcpy(),因为struct中的值有可能包含零字节，所以strcpy（）可能不对，如果传递struct,最好把struct的字节对齐改为以字节为单位。 回复人： lvfengxun(lfx) (2001-7-31 16:06:57) 得5分 直接将结构指针作为send的参数发就可以了,还用转换什么有必要在这里讨论吗?struct AA&#123;int a;char b[100];&#125;;struct AA aa;aa.a=11;strcpy(aa.b,&quot;aaa&quot;);send(hSocket,(char *)(&amp;aa),sizeof(aa),0);//OK 回复人： mydewang(mydewang) (2001-7-31 16:33:21) 得0分 其实这里是一个字节对齐的问题,比如struct AA&#123;int a;char b;&#125;;那么sizeof( struct AA )就不等于5了,而是8了,所以,将这个结构赋值给一个char *,里面会多出一些零...需要解决这个问题,可以在Project-&gt;Setting-&gt;Link-&gt;Project Options里加上/Zp1另外,可以参考一下MSDN里/Zp的编译选项..... 回复人： lz_0618(lz_0618) (2001-7-31 19:43:54) 得0分 根本不是什么字节对齐的问题，我上面的程序经过测试都好用啊，这位老兄用我的那段程序究竟是什么错误，能说清楚点吗？？？我这边用socket发送结构是一点问题也没有啊，而且是在VC和Delphi编的程序间通讯，当然，这时应该注意字节对齐的问题了，在VC程序间，只要不是故意将服务器和客户端的编译环境设的不一样，肯定是没有什么问题的，最多是多传几个Bit罢了。 回复人： kiko_lee(到处瞧瞧) (2001-8-3 11:02:51) 得0分 我发现将char * memcpy 到 char * 中间都有点问题，但是如果放到 char []中间就可以了，大家知道为什么否？ 回复人： ydogg(灰毛兔) (2001-8-3 11:40:35) 得0分 memcpy不copy最后的&apos;/0&apos;... 回复人： wenjunlin2000(微软克星) (2001-8-3 14:32:17) 得0分 是你看错了因为char*是以0 结尾的回复人： mc_music(狂沙) (2001-8-3 15:07:21) 得0分 请注意我的程序:struct ABCD *abcd;char *buf;abcd = (ABCD *)calloc(1,sizeof(ABCD));//初始化abcdbuf=abcd;//指针直接符值就可以了 回复人： zhangnanonnet(WinSockZhang) (2001-8-3 16:21:03) 得0分 你试试把类型变为BYTE 回复人： kiko_lee(到处瞧瞧) (2001-8-7 9:21:08) 得0分 不管了，给分，大家都有不少的建议呢。 38。double dou=12.34;我如何可以得到char * ch=&quot;12.34&quot;;转换函数是什么？回复人： wyzegg(蛋) (2001-7-24 21:26:04) 得50分 double dou=12.34;char * ch;ch=malloc(100);sprintf(ch,&quot;%5.2f&quot;,dou); 回复人： wyzegg(蛋) (2001-7-24 21:28:24) 得0分 或者#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void main( void )&#123;int decimal, sign;char *buffer;int precision = 10;double source = 3.1415926535;buffer = _ecvt( source, precision, &amp;decimal, &amp;sign );printf( &quot;source: %2.10f buffer: &apos;%s&apos; decimal: %d sign: %d/n&quot;,source, buffer, decimal, sign );&#125;但是第一种常用 回复人： Matrix_w(学会一点点) (2001-7-24 21:32:43) 得30分 int decimal, sign;double dou =12.34;char* ch;ch = _ecvt(dou,4,&amp;decimal,&amp;sign);回复人： imhua(华弟) (2001-7-24 21:35:02) 得20分 double dou=12.34;char *str;gcvt(dou,5,str); //5是长度MessageBox(str); 回复人： Matrix_w(学会一点点) (2001-7-24 21:37:58) 得0分 /* _GCVT.C: This program converts -3.1415e5* to its string representation.*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void main( void )&#123;char buffer[50];double source = -3.1415e5;_gcvt( source, 7, buffer );printf( &quot;source: %f buffer: &apos;%s&apos;/n&quot;, source, buffer );_gcvt( source, 7, buffer );printf( &quot;source: %e buffer: &apos;%s&apos;/n&quot;, source, buffer );&#125;Outputsource: -314150.000000 buffer: &apos;-314150.&apos;source: -3.141500e+005 buffer: &apos;-314150.&apos;39。 我在ADO中调用一个存储过程，存储过程有三个输入参数@useradd char(30),@username char(10),@userage char(3)，现在要把char *addr,char *name,char *age分别赋值给他们。??我做了如下定义：_ParameterPtr para1;_variant_t var1,var2,var3；==============================================================var1.vt=VT_BSTR;var1.bstrval=addr;/////(编译错误）==============================================================para1=m_pCommand-&gt;CreateParameter(L&quot;useradd&quot;,adBSTR,adParamInput,30,var1);m_pCommand-&gt;Parameters-&gt;Append(para1);编译结果出现下面错误：cannot convert from &apos;char *&apos; to &apos;unsigned short *不知道类型是不是选择VT_BSTR?回复人：tar(GPS) (2001-7-12 18:49:05) 得15分 var1.bstrval应该指向宽字符的字符串，即unicode字符串use _bstr_t to convert it_bstr_t var1(addr); 回复人：happyhackwang() (2001-7-12 20:06:48) 得5分 char *要进行转换成BSTR 回复人：WhiteWaterBlueSky(疯狂数码) (2001-7-13 9:35:15) 得10分 SDK中是这样的1。先用MultiByteToWideChar把char* 转为wchar_t*2。再用SysAllocString把wchar_t*转为BSTR 回复人：tar(GPS) (2001-7-13 14:10:01) 得0分 faint,我都已经把语句写出来了_bstr_t a(addr);var1.vt=VT_BSTR;var1.bstrval=(wchar_t *)a; 回复人：xwchena(西风之神) (2001-7-13 15:57:00) 得0分 大哥，我改完之后记录集无结果返回。我的代码是这样的：m_pRecordset.CreateInstance(__uuidof(Recordset));m_pRecordset=m_pCommand-&gt;Execute(NULL,NULL,adCmdStoredProc);if(!m_pRecordset-&gt;adoEOF)&#123;result1=m_pRecordset-&gt;GetCollect((long)0);if(result1.vt!=NULL)&#123;result1.ChangeType(VT_BSTR);CString strResult1=result1.bstrVal;strcpy(resval,strResult1);&#125;调试的时候看到执行完m_pCommand-&gt;Execute()后m_pRecordset就到了记录集的尾部而如果把char*型都改成int型，结果就能返回记录集。这是为什么啊？？？ 回复人：tar(GPS) (2001-7-13 19:19:51) 得0分 try adVarChar 回复人：xwchena(西风之神) (2001-7-13 22:54:21) 得0分 还是不行，记录集没有返回结果 回复人：seesi(不是我想骗你，是我不知道怎么才能不骗！) (2001-7-14 0:24:36)40。如何将 BSTR pVal 赋给：unsigned char *pw；如何将：unsigned char digest[16]赋给 BSTR *pOutVal?USES_CONVERSION; *pOutVal=SysAllocString(A2W((LPTSTR)digest));unsigned char *pw = (unsigned char *)_com_util::ConvertBSTRToString(pInVal); ========================================================================转载声明：本文转自http://blog.csdn.net/ithomer/article/details/5019367]]></content>
  </entry>
  <entry>
    <title><![CDATA[Point指针和Memory内存]]></title>
    <url>%2F2019%2F05%2F15%2FPoint-Memory%2F</url>
    <content type="text"><![CDATA[一、内存C语言中使用的地址是假的，计算机是通过虚拟内存地址访问到真实的物理内存的。虚拟内存通过内存映射来找到物理 内存。在CPU内部，有一个部件叫做MMU（内存管理单元），由它来负责将虚拟地址映射为物理地址。内存一部分给操 作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。 Windows在默认情况下会将高地址的2GB空间分配给内核（也可以配置为1GB），而linux默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 地址空间3G，称为用户空间（User Space）。 一个C语言程序在内存中分布： 程序代码区：(code) 存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。 常量区：(constant) 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 全局数据区：(global data) 存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 堆区：(heap) 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。 malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。 注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 动态链接库：用于在程序运行期间加载和卸载动态链接库。 栈区：(stack)存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被 销毁。 所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是 堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块 内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数 内部产生的数据只要放到堆中，就可以在函数外部使用。 问题思考 堆和栈都是什么，它们在程序运行过程中起到什么作用？为什么栈内存的分配效率要高于堆？ 栈溢出是怎么回事，如何利用栈溢出进行攻击？ 内存泄漏、野指针、非法内存访问、段错误都是怎么产生的？ 内存池、线程池、连接池等这些莫名其妙的“池子”是怎么回事？ 注意：编译器对程序进行编译过程中，对于字节对齐有利于内存的寻址，从而提高程序的运行效率 在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。 cdecl是C语言默认的调用惯例，在平时编程中，我们其实很少去指定调用惯例，这个时候就使用默认的 cdecl。 注意：cdecl 并不是标准关键字，上面的写法在 VC/VS 下有效，但是在 GCC 下，要使用 attribute__((cdecl))。 调用惯例 参数传递方式 参数出栈方式 名字修饰 cdecl 按照从右到左的顺序入栈 调用方 下划线+函数名，如函数 max() 的修饰名为 _max stdcall 按照从右到左的顺序入栈 函数本身（被调用方） 下划线+函数名+@+参数的字节数 fastcall 部分参数放入寄存器，余部从右到左的顺序入栈 函数本身（被调用方） @+函数名+@+参数的字节数 pascal 按照从左到右的顺序入栈 函数本身（被调用方） 较为复杂，这里不再展开讨论 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;char *str1 = &quot;c.biancheng.net&quot;; //字符串在常量区，str1在全局数据区int n; //全局数据区char* func()&#123; char *str = &quot;C语言中文网&quot;; //字符串在常量区，str在栈区 return str;&#125;int main()&#123; int a; //栈区 char *str2 = &quot;01234&quot;; //字符串在常量区，str2在栈区 char arr[20] = &quot;56789&quot;; //字符串和arr都在栈区 char *pstr = func(); //栈区 int b; //栈区 printf(&quot;str1: %#X\npstr: %#X\nstr2: %#X\n&quot;, str1, pstr, str2); puts(&quot;--------------&quot;); printf(&quot;&amp;str1: %#X\n &amp;n: %#X\n&quot;, &amp;str1, &amp;n); puts(&quot;--------------&quot;); printf(&quot; &amp;a: %#X\n arr: %#X\n &amp;b: %#X\n&quot;, &amp;a, arr, &amp;b); puts(&quot;--------------&quot;); printf(&quot;n: %d\na :%d\nb: %d\n&quot;, n, a, b); puts(&quot;--------------&quot;); printf(&quot;%s\n&quot;, pstr); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[#栈和队列 入栈 ：先入后出队列 ：先入先出123456789101112131415161718192021222324顺序栈入栈函数pushstatus push(elemtype e)&#123; if(top&gt;m)&#123;上溢&#125; else s[top++]=e;&#125;顺序栈出栈函数popstatus pop()&#123; if(top=L)&#123;下溢&#125; else&#123;e=s[--top]; return(e);&#125;&#125;队列：typedef struct qnode&#123; qelemtype data; struct qnode *next;&#125;qnode,*queueptr;链队列定义：typedef struct &#123; queueptr front; queueptr rear;&#125;linkqueue;]]></content>
  </entry>
  <entry>
    <title><![CDATA[时间和空间复杂度]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间和空间复杂度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768时间复杂度： 时间频率：语句执行次数T(n)1.对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间(1)、O(1) Temp=i; i=j; j=temp; (2)、O(n2)2.1. 交换i和j的内容sum=0； （一次） for(i=1;i&lt;=n;i++) （n+1次） for(j=1;j&lt;=n;j++) （n2次） sum++； （n2次） 解：因为Θ(2n2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)；2.2. for (i=1;i&lt;n;i++) &#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) x++; ② &#125; 解： 语句1的频度是n-1 语句2的频度是(n-1)*(2n+1)=2n2-n-1 f(n)=2n2-n-1+(n-1)=2n2-2； 又Θ(2n2-2)=n2 该程序的时间复杂度T(n)=O(n2). (3)、O（n） a=0; b=1; ① for (i=1;i&lt;=n;i++) ② &#123; s=a+b; ③ b=a; ④ a=s; ⑤ &#125; 解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n). (4)、O(log2n) i=1; ① hile (i&lt;=n) i=i*2; ② 解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=log2n 取最大值f(n)=log2n, T(n)=O(log2n )(5)、O(n3) for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;i;j++) &#123; for(k=0;k&lt;j;k++) x=x+2; &#125; &#125; 解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3). 【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 数据结构运算：修改，插入，删除，查找，排序 修改： V[i] = x;时间复杂度：O(1)空间复杂度：O(1)稳定性：稳定1234567插入： 插入于 1=&lt; i &gt;= n+1 for(j=n;j&gt;=i;j--) a[j+1]=a[j]; a[i]=x; n++;时间复杂度：O(n)空间复杂度：]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组问题]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数组问题数组是最常用的基础数据结构，它将元素保存在连续的内存中。它也是面试最喜欢的问题之一，在代码面试中你会经常听到很多关于数组的问题，例如，数组的反转、数组的排序或者查找数组中的一个元素。数组结构的一个关键优点是在知道索引的情况能够以 O(1) 的复杂度找到一个元素。但是增加或者删除一个元素是很慢的，因为一旦创建了一个数组，你就不能改变它的大小了。为了创建一个更长或者更短的数组，你需要创建一个新的数组，然后将所有元素从旧数组中复制到新数组中。 kjmeng翻译于 2018/12/19 17:39 顶0 解决数组问题的关键是，你要对数组这种数据结构有一个深刻的认识，同时还要了解基本的程序流程如循环、递归以及基本的操作符。下面是一些经常问到和数组相关的面试题，你可以拿来练习：在一个给定的从1到100的整型数组中，如何快速找到缺失的数字？（解决方案）如何找到一个给定的整型数组中的重复数字？（解决方案）在一个未排序的整型数组中，如何找到最大和最小的数字？（解决方案）在一个整型数组中，如何找到一个所有成对的数字，满足它们的和等于一个给定的数字？（解决方案）如果一个数组包含多个重复元素，如何找到这些重复的数字？（解决方案）用 Java 实现从一个给定数组中删除重复元素？（解决方案）如何利用快速排序对一个整型数组进行排序？（解决方案）如何从一个数组中删除重复元素？（解决方案）用 Java 实现数组反转？（解决方案）如何不借助库实现从数组中删除重复元素？（解决方案）这些问题不仅可以帮助你提高解决问题的技巧，还可以帮助提升对数组结构的认识。如果你需要更多关于数组的进阶的问题，可以参考《代码面试训练营：算法和数据结构》，这是一个训练营形式的算法课程，特别针对像 Google、微软、Apple 和 Facebook 这样的技术巨人面试准备而设计。如果你感觉 10 个问题还不够，还需要更多的联系，那就看看这个 30 个数组问题的列表。]]></content>
  </entry>
  <entry>
    <title><![CDATA[树和二叉树]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构概念]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[#数据结构概念数据结构分为逻辑结构，存储结构，数据运算 数据： 所有被计算机识别存储和处理的符号的集合数据元素：数据的基本单位，具有完整意义数据对象：具有相同性质的数据元素的集合，是数据的一个子集数据结构：是相互之间存在一种或多种特定关系的数据的集合Data_Structure =(D,R)数据类型：是一个值的集合和定义在该值上的一组操作的总成抽象数据类型：由用户定义的一个数据模型与定义在该模型上的一组操作 算法：问题求解步骤算法要求：正确性，可读性，健壮性，效率与存储低 算法衡量：时间复杂度，空间复杂度，稳定性 #一、线性表学习 数据元素的有限序列表示=线性表存储结构：顺序存储结构和链式存储结构 物理上相邻的存储是顺序的 = 顺序存储物理上非相邻的存储，通过指针来实现的 = 链式存储 增加 删除 修改 查询 排序增加： 找到位置插入删除： 找到位置删除修改： 找到位置修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394插入：步骤:1.将第n至第i位的元素向后移动一个位置2.将要插入的元素写到第i个位置3.表长加1for(j=n;j&lt;=i;j--) a[j+1]=a[j];a[i]=x;n++;删除：步骤1.将第i+1至第n位的元素向前移动一个位置3.表长减1for(j=i+1;j&lt;=n;j++) a[j-1]=a[j];n--;单链表#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; char data; struct node*next;&#125;node;node *p,*q,*head;int n; //节点个数int m=sizeof(node); //节点的大小head = (node*)malloc(m);void build()&#123; int i; p=head; for(i=1;i&lt;26;i++) &#123; p-&gt;data=i+&apos;a&apos;-1; p-&gt;next = (node*)malloc(m); p=p-&gt;next; &#125; p-&gt;data = i+&apos;a&apos;-1; p-&gt;next = NULL;&#125;void display()&#123; p= head; while(p) &#123; printf(&quot;%c&quot;,p-&gt;data); p=p-&gt;next; &#125;&#125;单链表的修改---用到查找接口：Linklist *find(Linklist *head,int i)&#123; int j = 1; Linklist *p; p=head-&gt;next; while((p!=NULL)&amp;&amp;(j&lt;i)) &#123; p= p-&gt;next; j++; &#125; return p;&#125;find函数找到需要插入的位置。插入：s-&gt;next = p-&gt;next;p-&gt;next = s;删除：q=p-&gt;next;p-&gt;next=q-&gt;next;free(q);双链表插入：ai-1 的后继从ai(p)变成了x(s)s-&gt;next=p;p-&gt;prior-&gt;next =s;ai的前驱从ai-1(p-&gt;prior)变为x(s)s-&gt;prior=p-&gt;prior;p-&gt;prior=s;双链表删除：设p指向第i个元素，删除第i个元素后继方向：ai-1的后继由ai(p)变为ai+1(p-Next)p-&gt;prior-Next = p-&gt;next前驱方向：ai+1的前驱由ai（指针P）变为ai-1(p-&gt;prior);p-next-&gt;prior = p-&gt;prior; 数组的逻辑结构定义和存储 数组矩阵多维数组多维矩阵稀松矩阵]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E8%AF%A2%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构链表链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。单链表：每个节点仅指向下一个节点，最后一个节点指向空（null）。双链表：每个节点有两个指针p，n。p指向前一个节点，n指向下一个节点；最后一个节点指向空。循环链表：每个节点指向下一个节点，最后一个节点指向第一个节点。时间复杂度：索引：O(n)查找：O(n)插入：O(1)删除：O(1)栈栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。后进先出的数据结构（Last In First Out, LIFO）时间复杂度索引：O(n)查找：O(n)插入：O(1)删除：O(1)队列队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。先进先出的数据结构（First In First Out, FIFO）。时间复杂度索引：O(n)查找：O(n)插入：O(1)删除：O(1)树树是无向、联通的无环图。二叉树二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。满二叉树（Full Tree）：二叉树中的每个节点有 0 或者 2 个子节点。完美二叉树（Perfect Binary）：二叉树中的每个节点有两个子节点，并且所有的叶子节点的深度是一样的。完全二叉树：二叉树中除最后一层外其他各层的节点数均达到最大值，最后一层的节点都连续集中在最左边。二叉查找树二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。时间复杂度索引：O(log(n))查找：O(log(n))插入：O(log(n))删除：O(log(n)) 字典树字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。 树状数组树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。时间复杂度区间求和：O(log(n))更新：O(log(n)) 线段树线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。时间复杂度区间查找：O(log(n))更新：O(log(n)) 堆堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。时间复杂度索引：O(log(n))查找：O(log(n))插入：O(log(n))删除：O(log(n))删除最大值/最小值：O(1) 哈希哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。Hash Map：hash map 是一个存储键值间关系的数据结构。HashMap 通过哈希函数将键转化为桶或者槽中的下标，从而便于指定值的查找。冲突解决链地址法（Separate Chaining）：在链地址法中，每个桶（bucket）是相互独立的，每一个索引对应一个元素列表。处理HashMap 的时间就是查找桶的时间（常量）与遍历列表元素的时间之和。开放地址法（Open Addressing）：在开放地址方法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个未被占用的地址。开放地址即某个元素的位置并不永远由其哈希值决定。 图图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。无向图：图的邻接矩阵是对称的，因此如果存在节点 u 到节点 v 的边，那节点 v 到节点 u 的边也一定存在。有向图：图的邻接矩阵不是对称的。因此如果存在节点 u 到节点 v 的边并不意味着一定存在节点 v 到节点 u 的边。 算法排序快速排序稳定：否时间复杂度最优：O(nlog(n))最差：O(n^2)平均：O(nlog(n)) 合并排序合并排序是一种分治算法。这个算法不断地将一个数组分为两部分，分别对左子数组和右子数组排序，然后将两个数组合并为新的有序数组。稳定：是时间复杂度：最优：O(nlog(n))最差：O(nlog(n))平均：O(nlog(n)) 桶排序桶排序是一种将元素分到一定数量的桶中的排序算法。每个桶内部采用其他算法排序，或递归调用桶排序。时间复杂度最优：Ω(n + k)最差: O(n^2)平均：Θ(n + k) 基数排序基数排序类似于桶排序，将元素分发到一定数目的桶中。不同的是，基数排序在分割元素之后没有让每个桶单独进行排序，而是直接做了合并操作。时间复杂度最优：Ω(nk)最差: O(nk)平均：Θ(nk)图算法深度优先搜索深度优先搜索是一种先遍历子节点而不回溯的图遍历算法。时间复杂度：O(|V| + |E|) 广度优先搜索广度优先搜索是一种先遍历邻居节点而不是子节点的图遍历算法。时间复杂度：O(|V| + |E|) 拓扑排序拓扑排序是有向图节点的线性排序。对于任何一条节点 u 到节点 v 的边，u 的下标先于 v。时间复杂度：O(|V| + |E|)Dijkstra算法Dijkstra 算法是一种在有向图中查找单源最短路径的算法。时间复杂度：O(|V|^2) Bellman-Ford算法Bellman-Ford 是一种在带权图中查找单一源点到其他节点最短路径的算法。虽然时间复杂度大于 Dijkstra 算法，但它可以处理包含了负值边的图。时间复杂度：最优：O(|E|)最差：O(|V||E|) Floyd-Warshall 算法Floyd-Warshall 算法是一种在无环带权图中寻找任意节点间最短路径的算法。该算法执行一次即可找到所有节点间的最短路径（路径权重和）。时间复杂度：最优：O(|V|^3)最差：O(|V|^3)平均：O(|V|^3)最小生成树算法最小生成树算法是一种在无向带权图中查找最小生成树的贪心算法。换言之，最小生成树算法能在一个图中找到连接所有节点的边的最小子集。时间复杂度：O(|V|^2) Kruskal 算法Kruskal 算法也是一个计算最小生成树的贪心算法，但在 Kruskal 算法中，图不一定是连通的。时间复杂度：O(|E|log|V|) 贪心算法贪心算法总是做出在当前看来最优的选择，并希望最后整体也是最优的。使用贪心算法可以解决的问题必须具有如下两种特性：最优子结构问题的最优解包含其子问题的最优解。贪心选择每一步的贪心选择可以得到问题的整体最优解。实例-硬币选择问题给定期望的硬币总和为 V 分，以及 n 种硬币，即类型是 i 的硬币共有 coinValue[i] 分，i的范围是 [0…n – 1]。假设每种类型的硬币都有无限个，求解为使和为 V 分最少需要多少硬币？硬币：便士（1美分），镍（5美分），一角（10美分），四分之一（25美分）。假设总和 V 为41,。我们可以使用贪心算法查找小于或者等于 V 的面值最大的硬币，然后从 V 中减掉该硬币的值，如此重复进行。V = 41 | 使用了0个硬币V = 16 | 使用了1个硬币(41 – 25 = 16)V = 6 | 使用了2个硬币(16 – 10 = 6)V = 1 | 使用了3个硬币(6 – 5 = 1)V = 0 | 使用了4个硬币(1 – 1 = 0)位运算位运算即在比特级别进行操作的技术。使用位运算技术可以带来更快的运行速度与更小的内存使用。测试第 k 位：s &amp; (1 &lt;&lt; k);设置第k位：s |= (1 &lt;&lt; k);关闭第k位：s &amp;= ~(1 &lt;&lt; k);切换第k位：s ^= (1 &lt;&lt; k);乘以2n：s &lt;&lt; n;除以2n：s &gt;&gt; n;交集：s &amp; t;并集：s | t;减法：s &amp; ~t;提取最小非0位：s &amp; (-s);提取最小0位：~s &amp; (s + 1);交换值：x ^= y; y ^= x; x ^= y;运行时分析大 O 表示大 O 表示用于表示某个算法的上界，用于描述最坏的情况。 小 O 表示小 O 表示用于描述某个算法的渐进上界，二者逐渐趋近。大 Ω 表示大 Ω 表示用于描述某个算法的渐进下界。 小 ω 表示小 ω 表示用于描述某个算法的渐进下界，二者逐渐趋近。Theta Θ 表示Theta Θ 表示用于描述某个算法的确界，包括最小上界和最大下界。 以为这就结束了？No, 这些知识不仅仅是停留在理论，还有代码实现。 这其实是来自 GitHub 的一个 repo：https://github.com/kdn251/interviews除了上述算法和数据结知识外，其中还有推荐了一些算法练习网站、视频教程、面试宝典、Google、Facebook 等知名公司面试题及解答代码。下载实例代码或者收藏练习网站。Enjoy!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows API函数总结]]></title>
    <url>%2F2019%2F05%2F08%2FWindows-api%2F</url>
    <content type="text"><![CDATA[API函数（Windows）一、隐藏和显示光标 函数： int ShowCursor ( BOOL bShow ); 参数 bshow，为布尔型，bShow的值为False时隐藏光标，为True时显示光标；该函数的返回值为整型，为鼠标隐藏或显示的指数器；返回值大于等于0时显示光标，否则隐藏鼠标；如果安装了鼠标初值为0。二、交换鼠标左右键和恢复 函数：BOOL SwapMouseButton ( BOOL fSwap ); 参数 fSwap，为布尔型，TRUE表示交换鼠标左右键，FALSE表示恢复系统默认左右手习惯；返回值亦为布尔型，交换后，返回值TRUE，恢复正常值为FALSE。三、得到鼠标双击时间 函数： UINT GetDoubleClickTime(VOID); 该函数无参数；它的返回值为毫秒，为双击鼠标双击有效的时间间隔。四、设置鼠标双击时间 函数： BOOL SetDoubleClickTime ( UINT uInterval ); 参数uInterval，表示鼠标双击时间，为毫秒级,系统默认时间为500；返回值为布尔值。五、将鼠标锁定在一定范围 函数：BOOL ClipCursor ( CONST RECT lpRect ); 参数lpRect，指向鼠标活动矩形区域的指针；返回值为布尔型，表示锁定成功与否。 API之网络函数WNetAddConnection 创建同一个网络资源的永久性连接WNetAddConnection2 创建同一个网络资源的连接WNetAddConnection3 创建同一个网络资源的连接WNetCancelConnection 结束一个网络连接WNetCancelConnection2 结束一个网络连接WNetCloseEnum 结束一次枚举操作WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接WNetEnumResource 枚举网络资源WNetGetConnection 获取本地或已连接的一个资源的网络名称WNetGetLastError 获取网络错误的扩展错误信息WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称WNetGetUser 获取一个网络资源用以连接的名字WNetOpenEnum 启动对网络资源进行枚举的过程 API之消息函数BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置GetMessageTime 取得消息队列中上一条消息处理完毕时的时间PostMessage 将一条消息投递到指定窗口的消息队列PostThreadMessage 将一条消息投递给应用程序RegisterWindowMessage 获取分配给一个字串标识符的消息编号ReplyMessage 答复一个消息SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口SendMessageCallback 将一条消息发给窗口SendMessageTimeout 向窗口发送一条消息SendNotifyMessage 向窗口发送一条消息 API之文件处理函数CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等CompareFileTime 对比两个文件的时间CopyFile 复制文件CreateDirectory 创建一个新目录CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台CreateFileMapping 创建一个新的文件映射对象DeleteFile 删除指定文件DeviceIoControl 对设备执行指定的操作DosDateTimeToFileTime 将DOS日期和时间值转换成一个 win32 FILETIME 值FileTimeToDosDateTime 将一个 win32 FILETIME 值转换成DOS日期和时间值FileTimeToLocalFileTime 将一个FILETIME结构转换成本地时间FileTimeToSystemTime 根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构FindClose 关闭由FindFirstFile函数创建的一个搜索句柄FindFirstFile 根据文件名查找文件FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘GetBinaryType 判断文件是否可以执行GetCompressedFileSize 判断一个压缩文件在磁盘上实际占据的字节数GetCurrentDirectory 在一个缓冲区中装载当前目录GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量GetDiskFreeSpaceEx 获取与一个磁盘的组织以及剩余空间容量有关的信息GetDriveType 判断一个磁盘驱动器的类型GetExpandedName 取得一个压缩文件的全名GetFileAttributes 判断指定文件的属性GetFileInformationByHandle 这个函数提供了获取文件信息的一种机制GetFileSize 判断文件长度GetFileTime 取得指定文件的时间信息GetFileType 在给出文件句柄的前提下，判断文件类型GetFileVersionInfo 从支持版本标记的一个模块里获取文件版本信息GetFileVersionInfoSize 针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区GetFullPathName 获取指定文件的完整路径名GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母GetLogicalDriveStrings 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径GetOverlappedResult 判断一个重叠操作当前的状态GetPrivateProfileInt 为初始化文件（.ini文件）中指定的条目获取一个整数值GetPrivateProfileSection 获取指定小节（在.ini文件中）所有项名和值的一个列表GetPrivateProfileString 为初始化文件中指定的条目取得字串GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表GetProfileString 为win.ini初始化文件中指定的条目取得字串GetShortPathName 获取指定文件的短路径名GetSystemDirectory 取得Windows系统目录（即System目录）的完整路径名GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用GetTempPath 获取为临时文件指定的路径GetVolumeInformation 获取与一个磁盘卷有关的信息GetWindowsDirectory 获取Windows目录的完整路径名hread 参考lreadhwrite 参考lwrite函数lclose 关闭指定的文件lcreat 创建一个文件llseek 设置文件中进行读写的当前位置LockFile 锁定文件的某一部分，使其不与其他应用程序共享LockFileEx 与LockFile相似，只是它提供了更多的功能lopen 以二进制模式打开指定的文件lread 将文件中的数据读入内存缓冲区lwrite 将数据从内存缓冲区写入一个文件LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件LZCopy 复制一个文件LZInit 这个函数用于初始化内部缓冲区LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件LZRead 将数据从文件读入内存缓冲区LZSeek 设置一个文件中进行读写的当前位置MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间MoveFile 移动文件OpenFile 这个函数能执行大量不同的文件操作OpenFileMapping 打开一个现成的文件映射对象QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况ReadFile 从文件中读出数据ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调RegCloseKey 关闭系统注册表中的一个项（或键）RegConnectRegistry 访问远程系统的部分注册表RegCreateKey 在指定的项下创建或打开一个项RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数RegDeleteKey 删除现有项下方一个指定的子项RegDeleteValue 删除指定项下方的一个值RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyExRegEnumKeyEx 枚举指定项下方的子项RegEnumValue 枚举指定项的值RegFlushKey 将对项和它的子项作出的改动实际写入磁盘RegGetKeySecurity 获取与一个注册表项有关的安全信息RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息RegNotifyChangeKeyValue 注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制RegOpenKey 打开一个现有的注册表项RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数RegQueryInfoKey 获取与一个项有关的信息RegQueryValue 取得指定项或子项的默认（未命名）值RegQueryValueEx 获取一个项的设置值RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息RegRestoreKey 从一个磁盘文件恢复注册表信息RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件RegSetKeySecurity 设置指定项的安全特性RegSetValue 设置指定项或子项的默认值RegSetValueEx 设置指定项的值RegUnLoadKey 卸载指定的项以及它的所有子项RemoveDirectory 删除指定目录SearchPath 查找指定文件SetCurrentDirectory 设置当前目录SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾SetFileAttributes 设置文件属性SetFilePointer 在一个文件中设置当前的读写位置SetFileTime 设置文件的创建、访问及上次修改时间SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果SetVolumeLabel 设置一个磁盘的卷标（Label）SystemTimeToFileTime 根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构UnlockFile 解除对一个文件的锁定UnlockFileEx 解除对一个文件的锁定UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射VerFindFile 用这个函数决定一个文件应安装到哪里VerInstallFile 用这个函数安装一个文件VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称VerQueryValue 这个函数用于从版本资源中获取信息WriteFile 将数据写入一个文件WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调WritePrivateProfileSection 为一个初始化文件（.ini）中指定的小节设置所有项名和值WritePrivateProfileString 在初始化文件指定小节内设置一个字串WriteProfileSection 为Win.ini初始化文件中一个指定的小节设置所有项名和值WriteProfileString 在Win.ini初始化文件指定小节内设置一个字串 API之打印函数AbortDoc 取消一份文档的打印AbortPrinter 删除与一台打印机关联在一起的缓冲文件AddForm 为打印机的表单列表添加一个新表单AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号AddMonitor 为系统添加一个打印机监视器AddPort 启动”添加端口”对话框，允许用户在系统可用端口列表中加入一个新端口AddPrinter 在系统中添加一台新打印机AddPrinterConnection 连接指定的打印机AddPrinterDriver 为指定的系统添加一个打印驱动程序AddPrintProcessor 为指定的系统添加一个打印处理器AddPrintProvidor 为系统添加一个打印供应商AdvancedDocumentProperties 启动打印机文档设置对话框ClosePrinter 关闭一个打开的打印机对象ConfigurePort 针对指定的端口，启动一个端口配置对话框ConnectToPrinterDlg 启动连接打印机对话框，用它同访问网络的打印机连接DeleteForm 从打印机可用表单列表中删除一个表单DeleteMonitor 删除指定的打印监视器DeletePort 启动”删除端口”对话框，允许用户从当前系统删除一个端口DeletePrinter 将指定的打印机标志为从系统中删除DeletePrinterConnection 删除与指定打印机的连接DeletePrinterDriver 从系统删除一个打印机驱动程序DeletePrintProcessor 从指定系统删除一个打印处理器DeletePrintProvidor 从系统中删除一个打印供应商DeviceCapabilities 利用这个函数可获得与一个设备的能力有关的信息DocumentProperties 打印机配置控制函数EndDocAPI 结束一个成功的打印作业EndDocPrinter 在后台打印程序的级别指定一个文档的结束EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页EndPagePrinter 指定一个页在打印作业中的结尾EnumForms 枚举一台打印机可用的表单EnumJobs 枚举打印队列中的作业EnumMonitors 枚举可用的打印监视器EnumPorts 枚举一个系统可用的端口EnumPrinterDrivers 枚举指定系统中已安装的打印机驱动程序EnumPrinters 枚举系统中安装的打印机EnumPrintProcessorDatatypes 枚举由一个打印处理器支持的数据类型EnumPrintProcessors 枚举系统中可用的打印处理器Escape 设备控制函数FindClosePrinterChangeNotification 关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象FindFirstPrinterChangeNotification 创建一个新的改变通告对象，以便我们注意打印机状态的各种变化FindNextPrinterChangeNotification 用这个函数判断触发一次打印机改变通告信号的原因FreePrinterNotifyInfo 释放由FindNextPrinterChangeNotification函数分配的一个缓冲区GetForm 取得与指定表单有关的信息GetJob 获取与指定作业有关的信息GetPrinter 取得与指定打印机有关的信息GetPrinterData 为打印机设置注册表配置信息GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息GetPrinterDriverDirectory 判断指定系统中包含了打印机驱动程序的目录是什么GetPrintProcessorDirectory 判断指定系统中包含了打印机处理器驱动程序及文件的目录OpenPrinter 打开指定的打印机，并获取打印机的句柄PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框PrinterProperties 启动打印机属性对话框，以便对打印机进行配置ReadPrinter 从打印机读入数据ResetDC 重设一个设备场景ResetPrinter 改变指定打印机的默认数据类型及文档设置ScheduleJob 提交一个要打印的作业SetAbortProc 为Windows指定取消函数的地址SetForm 为指定的表单设置信息SetJob 对一个打印作业的状态进行控制SetPrinter 对一台打印机的状态进行控制SetPrinterData 设置打印机的注册表配置信息StartDoc 开始一个打印作业StartDocPrinter 在后台打印的级别启动一个新文档StartPage 打印一个新页前要先调用这个函数StartPagePrinter 在打印作业中指定一个新页的开始WritePrinter 将发送目录中的数据写入打印机 API之文本和字体函数AddFontResource 在Windows系统中添加一种字体资源CreateFont 用指定的属性创建一种逻辑字体CreateFontIndirect 用指定的属性创建一种逻辑字体CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统DrawText 将文本描绘到指定的矩形中DrawTextEx 与DrawText相似，只是加入了更多的功能EnumFontFamilies 列举指定设备可用的字体EnumFontFamiliesEx 列举指定设备可用的字体EnumFonts 列举指定设备可用的字体ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串GetCharWidth 调查字体中一个或多个字符的宽度GetFontData 接收一种可缩放字体文件的数据GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息GetKerningPairs 取得指定字体的字距信息GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息GetRasterizerCaps 了解系统是否有能力支持可缩放的字体GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素GetTextAlign 接收一个设备场景当前的文本对齐标志GetTextCharacterExtra 判断额外字符间距的当前值GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息GetTextColor 判断当前字体颜色。通常也称为”前景色”GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息GetTextExtentPoint 判断一个字串的大小（范围）GetTextFace 获取一种字体的字样名GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态PolyTextOut 描绘一系列字串RemoveFontResource 从Windows系统中删除一种字体资源SetMapperFlags Windows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距SetTextColor 设置当前文本颜色。这种颜色也称为”前景色”SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理TabbedTextOut 支持制表站的一个文本描绘函数TextOut 文本绘图函数 API之菜单函数AppendMenu 在指定的菜单里添加一个菜单项CheckMenuItem 复选或撤消复选指定的菜单条目CheckMenuRadioItem 指定一个菜单条目被复选成”单选”项目CreateMenu 创建新菜单CreatePopupMenu 创建一个空的弹出式菜单DeleteMenu 删除指定的菜单条目DestroyMenu 删除指定的菜单DrawMenuBar 为指定的窗口重画菜单EnableMenuItem 允许或禁止指定的菜单条目GetMenu 取得窗口中一个菜单的句柄GetMenuCheckMarkDimensions 返回一个菜单复选符的大小GetMenuContextHelpId 取得一个菜单的帮助场景IDGetMenuDefaultItem 判断菜单中的哪个条目是默认条目GetMenuItemCount 返回菜单中条目（菜单项）的数量GetMenuItemID 返回位于菜单中指定位置处的条目的菜单IDGetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息GetMenuState 取得与指定菜单条目状态有关的信息GetMenuString 取得指定菜单条目的字串GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置GetSystemMenu 取得指定窗口的系统菜单的句柄HiliteMenuItem 控制顶级菜单条目的加亮显示状态InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动InsertMenuItem 插入一个新菜单条目IsMenu 判断指定的句柄是否为一个菜单的句柄LoadMenu 从指定的模块或应用程序实例中载入一个菜单LoadMenuIndirect 载入一个菜单MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点ModifyMenu 改变菜单条目RemoveMenu 删除指定的菜单条目SetMenu 设置窗口菜单SetMenuContextHelpId 设置一个菜单的帮助场景IDSetMenuDefaultItem 将一个菜单条目设为默认条目SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√）SetMenuItemInfo 为一个菜单条目设置指定的信息TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能 API之位图、图标和光栅运算函数BitBlt 将一幅位图从一个设备场景复制到另一个CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作CreateBitmap 按照规定的格式创建一幅与设备有关位图CreateBitmapIndirect 创建一幅与设备有关位图CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容CreateCursor 创建一个鼠标指针CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图CreateDIBSection 创建一个DIBSectionCreateIcon 创建一个图标CreateIconIndirect 创建一个图标DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源DestroyIcon 清除图标DrawIcon 在指定的位置画一个图标DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来GetBitmapBits 将来自位图的二进制位复制到一个缓冲区GetBitmapDimensionEx 取得一幅位图的宽度和高度GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里GetIconInfo 取得与图标有关的信息GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式LoadBitmap 从指定的模块或应用程序实例中载入一幅位图LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针LoadIcon 从指定的模块或应用程序实例中载入一个图标LoadImage 载入一个位图、图标或指针MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式StretchBlt 将一幅位图从一个设备场景复制到另一个StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 API之绘图函数AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作AngleArc 用一个连接弧画一条线Arc 画一个圆弧BeginPath 启动一个路径分支CancelDC 取消另一个线程里的长时间绘图操作Chord 画一个弦CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄CloseFigure 描绘到一个路径时，关闭当前打开的图形CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝）CopyMetaFile 制作指定（标准）图元文件的一个副本CreateBrushIndirect 在一个LOGBRUSH数据结构的基础上创建一个刷子CreateDIBPatternBrush 用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案）CreateEnhMetaFile 创建一个增强型的图元文件设备场景CreateHatchBrush 创建带有阴影图案的一个刷子CreateMetaFile 创建一个图元文件设备场景CreatePatternBrush 用指定了刷子图案的一幅位图创建一个刷子CreatePen 用指定的样式、宽度和颜色创建一个画笔CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔CreateSolidBrush 用纯色创建一个刷子DeleteEnhMetaFile 删除指定的增强型图元文件DeleteMetaFile 删除指定的图元文件DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放DrawEdge 用指定的样式描绘一个矩形的边框DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序DrawFocusRect 画一个焦点矩形DrawFrameControl 描绘一个标准控件DrawState 为一幅图象或绘图操作应用各式各样的效果Ellipse 描绘一个椭圆，由指定的矩形围绕EndPath 停止定义一个路径EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录EnumObjects 枚举可随同指定设备场景使用的画笔和刷子ExtCreatePen 创建一个扩展画笔（装饰或几何）ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域FillPath 关闭路径中任何打开的图形，并用当前刷子填充FillRect 用指定的刷子填充一个矩形FlattenPath 将一个路径中的所有曲线都转换成线段FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域FrameRect 用指定的刷子围绕一个矩形画一个边框GdiComment 为指定的增强型图元文件设备场景添加一条注释信息GdiFlush 执行任何未决的绘图操作GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列GetArcDirection 画圆弧的时候，判断当前采用的绘图方向GetBkColor 取得指定设备场景当前的背景颜色GetBkMode 针对指定的设备场景，取得当前的背景填充模式GetBrushOrgEx 判断指定设备场景中当前选定刷子起点GetCurrentObject 获得指定类型的当前选定对象GetCurrentPositionEx 在指定的设备场景中取得当前的画笔位置GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄GetEnhMetaFileBits 将指定的增强型图元文件复制到一个内存缓冲区里GetEnhMetaFileDescription 返回对一个增强型图元文件的说明GetEnhMetaFileHeader 取得增强型图元文件的图元文件头GetEnhMetaFilePaletteEntries 取得增强型图元文件的全部或部分调色板GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区GetMiterLimit 取得设备场景的斜率限制（Miter）设置GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色GetObjectAPI 取得对指定对象进行说明的一个结构GetObjectType 判断由指定句柄引用的GDI对象的类型GetPath 取得对当前路径进行定义的一系列数据GetPixel 在指定的设备场景中取得一个像素的RGB值GetPolyFillMode 针对指定的设备场景，获得多边形填充模式GetROP2 针对指定的设备场景，取得当前的绘图模式GetStockObject 取得一个固有对象（Stock）GetSysColorBrush 为任何一种标准系统颜色取得一个刷子GetWinMetaFileBits 通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形LineDDA 枚举指定线段中的所有点LineTo 用当前画笔画一条线，从当前位置连到一个指定的点MoveToEx 为指定的设备场景指定一个新的当前画笔位置PaintDesk 在指定的设备场景中描绘桌面墙纸图案PathToRegion 将当前选定的路径转换到一个区域里Pie 画一个饼图PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件PlayEnhMetaFileRecord 回放单独一条增强型图元文件记录PlayMetaFile 在指定的设备场景中回放一个图元文件PlayMetaFileRecord 回放来自图元文件的单条记录PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成Polygon 描绘一个多边形Polyline 用当前画笔描绘一系列线段PolyPolygon 用当前选定画笔描绘两个或多个多边形PolyPolyline 用当前选定画笔描绘两个或多个多边形Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充SelectClipPath 将设备场景当前的路径合并到剪切区域里SelectObject 为当前设备场景选择图形对象SetArcDirection 设置圆弧的描绘方向SetBkColor 为指定的设备场景设置背景颜色SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点SetEnhMetaFileBits 用指定内存缓冲区内包含的数据创建一个增强型图元文件SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件SetMiterLimit 设置设备场景当前的斜率限制SetPixel 在指定的设备场景中设置一个像素的RGB值SetPixelV 在指定的设备场景中设置一个像素的RGB值SetPolyFillMode 设置多边形的填充模式SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致SetWinMetaFileBits 将一个标准Windows图元文件转换成增强型图元文件StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用SetBrushOrgEx修改，则必须先调用本函数WidenPath 根据选定画笔的宽度，重新定义当前选定的路径 API之设备场景函数CombineRgn 将两个区域组合为一个新区域CombineTransform 驱动世界转换。它相当于依顺序进行两次转换CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景CreateDC 为专门设备创建设备场景CreateEllipticRgn 创建一个椭圆CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域CreateIC 为专用设备创建一个信息场景CreatePolygonRgn 创建一个由一系列点围成的区域CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的CreateRectRgn 创建一个矩形区域CreateRectRgnIndirect 创建一个矩形区域CreateRoundRectRgn 创建一个圆角矩形DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标EqualRgn 确定两个区域是否相等ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域ExtCreateRegion 根据世界转换修改区域ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区FillRgn 用指定刷子填充指定区域FrameRgn 用指定刷子围绕指定区域画一个外框GetBoundsRect 获取指定设备场景的边界矩形GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形GetClipRgn 获取设备场景当前剪裁区GetDC 获取指定窗口的设备场景GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示）GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息GetGraphicsMode 确定是否允许增强图形模式（世界转换）GetMapMode 为特定设备场景调入映象模式GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区GetRgnBox 获取完全包含指定区域的最小矩形GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新GetViewportExtEx 获取设备场景视口（viewport）范围GetViewportOrgEx 获取设备场景视口起点GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景GetWindowExtEx 获取指定设备场景的窗口范围GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点GetWindowRgn 获取窗口区域GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换IntersectClipRect 为指定设备定义一个新的剪裁区InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画InvertRgn 通过颠倒每个像素值反转设备场景指定区域LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标ModifyWorldTransform 根据指定的模式修改世界转换OffsetClipRgn 按指定量平移设备场景剪裁区OffsetRgn 按指定偏移量平移指定区域OffsetViewportOrgEx 平移设备场景视口区域OffsetWindowOrgEx 平移指定设备场景窗口起点PaintRgn 用当前刷子背景色填充指定区域PtInRegion 确定点是否在指定区域内PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内）RectInRegion 确定矩形是否有部分在指定区域内RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内）ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景SaveDC 将指定设备场景状态保存到Windows设备场景堆栈ScaleViewportExtEx 缩放设备场景视口的范围ScaleWindowExtEx 缩放指定设备场景窗口范围ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形SelectClipRgn 为指定设备场景选择新的剪裁区SetBoundsRect 设置指定设备场景的边界矩形SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换）SetMapMode 设置指定设备场景的映射模式SetRectRgn 设置区域为指定的矩形SetViewportExtEx 设置设备场景视口范围SetViewportOrgEx 设置设备场景视口起点SetWindowExtEx 设置指定设备场景窗口范围SetWindowOrgEx 设置指定设备场景窗口起点SetWindowRgn 设置窗口区域SetWorldTransform 设置世界转换ValidateRgn 激活窗口中指定区域，把它从刷新区移走WindowFromDC 取回与某一设备场景相关的窗口的句柄 API之硬件与系统函数ActivateKeyboardLayout 激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义Beep 用于生成简单的声音CharToOem 将一个字串从ANSI字符集转换到OEM字符集ClipCursor 将指针限制到指定区域ConvertDefaultLocale 将一个特殊的地方标识符转换成真实的地方IDCreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符DestroyCaret 清除（破坏）一个插入符EnumCalendarInfo 枚举在指定”地方”环境中可用的日历信息EnumDateFormats 列举指定的”当地”设置中可用的长、短日期格式EnumSystemCodePages 枚举系统中已安装或支持的代码页EnumSystemLocales 枚举系统已经安装或提供支持的”地方”设置EnumTimeFormats 枚举一个指定的地方适用的时间格式ExitWindowsEx 退出windows，并用特定的选项重新启动ExpandEnvironmentStrings 扩充环境字串FreeEnvironmentStrings 翻译指定的环境字串块GetACP 判断目前正在生效的ANSI代码页GetAsyncKeyState 判断函数调用时指定虚拟键的状态GetCaretBlinkTime 判断插入符光标的闪烁频率GetCaretPos 判断插入符的当前位置GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域GetCommandLine 获得指向当前命令行缓冲区的一个指针GetComputerName 取得这台计算机的名称GetCPInfo 取得与指定代码页有关的信息GetCurrencyFormat 针对指定的”地方”设置，根据货币格式格式化一个数字GetCursor 获取目前选择的鼠标指针的句柄GetCursorPos 获取鼠标指针的当前位置GetDateFormat 针对指定的”当地”格式，对一个系统日期进行格式化GetDoubleClickTime 判断连续两次鼠标单击之间会被处理成双击事件的间隔时间GetEnvironmentStrings 为包含了当前环境字串设置的一个内存块分配和返回一个句柄GetEnvironmentVariable 取得一个环境变量的值GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件GetKBCodePage 由GetOEMCP取代，两者功能完全相同GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局GetKeyboardLayoutList 获得系统适用的所有键盘布局的一个列表GetKeyboardLayoutName 取得当前活动键盘布局的名称GetKeyboardState 取得键盘上每个虚拟键当前的状态GetKeyboardType 了解与正在使用的键盘有关的信息GetKeyNameText 在给出扫描码的前提下，判断键名GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息GetLocaleInfo 取得与指定”地方”有关的信息GetLocalTime 取得本地日期和时间GetNumberFormat 针对指定的”地方”，按特定的格式格式化一个数字GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型GetSysColor 判断指定windows显示对象的颜色GetSystemDefaultLangID 取得系统的默认语言IDGetSystemDefaultLCID 取得当前的默认系统”地方”GetSystemInfo 取得与底层硬件平台有关的信息GetSystemMetrics 返回与windows环境有关的信息GetSystemPowerStatus 获得与当前系统电源状态有关的信息GetSystemTime 取得当前系统时间，这个时间采用的是”协同世界时间”（即UTC，也叫做GMT）格式GetSystemTimeAdjustment 使内部系统时钟与一个外部的时钟信号源同步GetThreadLocale 取得当前线程的地方IDGetTickCount 用于获取自windows启动以来经历的时间长度（毫秒）GetTimeFormat 针对当前指定的”地方”，按特定的格式格式化一个系统时间GetTimeZoneInformation 取得与系统时区设置有关的信息GetUserDefaultLangID 为当前用户取得默认语言IDGetUserDefaultLCID 取得当前用户的默认”地方”设置GetUserName 取得当前用户的名字GetVersion 判断当前运行的Windows和DOS版本GetVersionEx 取得与平台和操作系统有关的版本信息HideCaret 在指定的窗口隐藏插入符（光标）IsValidCodePage 判断一个代码页是否有效IsValidLocale 判断地方标识符是否有效keybd_event 这个函数模拟了键盘行动LoadKeyboardLayout 载入一个键盘布局MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的mouse_event 模拟一次鼠标事件OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态OemToChar 将OEM字符集的一个字串转换到ANSI字符集SetCaretBlinkTime 指定插入符（光标）的闪烁频率SetCaretPos 指定插入符的位置SetComputerName 设置新的计算机名SetCursor 将指定的鼠标指针设为当前指针SetCursorPos 设置指针的位置SetDoubleClickTime 设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间SetEnvironmentVariable 将一个环境变量设为指定的值SetKeyboardState 设置每个虚拟键当前在键盘上的状态SetLocaleInfo 改变用户”地方”设置信息SetLocalTime 设置当前地方时间SetSysColors 设置指定窗口显示对象的颜色SetSystemCursor 改变任何一个标准系统指针SetSystemTime 设置当前系统时间SetSystemTimeAdjustment 定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步SetThreadLocale 为当前线程设置地方SetTimeZoneInformation 设置系统时区信息ShowCaret 在指定的窗口里显示插入符（光标）ShowCursor 控制鼠标指针的可视性SwapMouseButton 决定是否互换鼠标左右键的功能SystemParametersInfo 获取和设置数量众多的windows系统参数SystemTimeToTzSpecificLocalTime 将系统时间转换成地方时间ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符UnloadKeyboardLayout 卸载指定的键盘布局VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态 API之进程和线程函数CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接CreateEvent 创建一个事件对象CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人）CreateMutex 创建一个互斥体（MUTEX）CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用CreatePipe 创建一个匿名管道CreateProcess 创建一个新进程（比如执行一个程序）CreateSemaphore 创建一个新的信号机CreateWaitableTimer 创建一个可等待的计时器对象DisconnectNamedPipe 断开一个客户与一个命名管道的连接DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄ExitProcess 中止一个进程FindCloseChangeNotification 关闭一个改动通知对象FindExecutable 查找与一个指定文件关联在一起的程序的文件名FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化FreeLibrary 释放指定的动态链接库GetCurrentProcess 获取当前进程的一个伪句柄GetCurrentProcessId 获取当前进程一个唯一的标识符GetCurrentThread 获取当前线程的一个伪句柄GetCurrentThreadId 获取当前线程一个唯一的线程标识符GetExitCodeProces 获取一个已中断进程的退出代码GetExitCodeThread 获取一个已中止线程的退出代码GetHandleInformation 获取与一个系统对象句柄有关的信息GetMailslotInfo 获取与一个邮路有关的信息GetModuleFileName 获取一个已装载模板的完整路径名称GetModuleHandle 获取一个应用程序或动态链接库的模块句柄GetPriorityClass 获取特定进程的优先级别GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况GetProcessTimes 获取与一个进程的经过时间有关的信息GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存GetSartupInfo 获取一个进程的启动信息GetThreadPriority 获取特定线程的优先级别GetTheardTimes 获取与一个线程的经过时间有关的信息GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间LoadModule 载入一个Windows应用程序，并在指定的环境中运行MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回SetPriorityClass 设置一个进程的优先级别SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量SetThreadPriority 设定线程的优先级别ShellExecute 查找与指定文件关联在一起的程序的文件名TerminateProcess 结束一个进程WinExec 运行指定的程序 API之控件与消息函数AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小AnyPopup 判断屏幕上是否存在任何弹出式窗口ArrangeIconicWindows 排列一个父窗口的最小化子窗口AttachThreadInput 连接线程输入函数BeginDeferWindowPos 启动构建一系列新窗口位置的过程BringWindowToTop 将指定的窗口带至窗口列表顶部CascadeWindows 以层叠方式排列窗口ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标CloseWindow 最小化指定的窗口CopyRect 矩形内容复制DeferWindowPos 该函数为特定的窗口指定一个新窗口位置DestroyWindow 清除指定的窗口以及它的所有子窗口DrawAnimatedRects 描绘一系列动态矩形EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态EnumChildWindows 为指定的父窗口枚举子窗口EnumThreadWindows 枚举与指定任务相关的窗口EnumWindows 枚举窗口列表中的所有父窗口EqualRect 判断两个矩形结构是否相同FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口FlashWindow 闪烁显示指定窗口GetActiveWindow 获得活动窗口的句柄GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收）GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息GetClassLong 取得窗口类的一个Long变量条目GetClassName 为指定的窗口取得类名GetClassWord 为窗口类取得一个整数变量GetClientRect 返回指定窗口客户区矩形的大小GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄GetFocus 获得拥有输入焦点的窗口的句柄GetForegroundWindow 获得前台窗口的句柄GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄GetParent 判断指定窗口的父窗口GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系GetWindowContextHelpId 取得与窗口关联在一起的帮助场景IDGetWindowLong 从指定窗口的结构中取得信息GetWindowPlacement 获得指定窗口的状态及位置信息GetWindowRect 获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容GetWindowTextLength 调查窗口标题文字或控件内容的长短GetWindowWord 获得指定窗口结构的信息InflateRect 增大或减小一个矩形的大小IntersectRect 这个函数在lpDestRect里载入一个矩形，它是lpSrc1Rect与lpSrc2Rect两个矩形的交集InvalidateRect 屏蔽一个窗口客户区的全部或部分区域IsChild 判断一个窗口是否为另一窗口的子或隶属窗口IsIconic 判断窗口是否已最小化IsRectEmpty 判断一个矩形是否为空IsWindow 判断一个窗口句柄是否有效IsWindowEnabled 判断窗口是否处于活动状态IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字IsWindowVisible 判断窗口是否可见IsZoomed 判断窗口是否最大化LockWindowUpdate 锁定指定窗口，禁止它更新MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统MoveWindow 改变指定窗口的位置和大小OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来OpenIcon 恢复一个最小化的程序，并将其激活PtInRect 判断指定的点是否位于矩形内部RedrawWindow 重画全部或部分窗口ReleaseCapture 为当前的应用程序释放鼠标捕获ScreenToClient 判断屏幕上一个指定点的客户区坐标ScrollWindow 滚动窗口客户区的全部或一部分ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分SetActiveWindow 激活指定的窗口SetCapture 将鼠标捕获设置到指定的窗口SetClassLong 为窗口类设置一个Long变量条目SetClassWord 为窗口类设置一个条目SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口SetForegroundWindow 将窗口设为系统的前台窗口SetParent 指定一个窗口的新父SetRect 设置指定矩形的内容SetRectEmpty 将矩形设为一个空矩形SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）IDSetWindowLong 在窗口结构中为指定的窗口设置信息SetWindowPlacement 设置窗口状态和位置信息SetWindowPos 为窗口指定一个新位置和状态SetWindowText 设置窗口的标题文字或控件的内容SetWindowWord 在窗口结构中为指定的窗口设置信息ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口ShowWindow 控制窗口的可见性ShowWindowAsync 与ShowWindow相似SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果TileWindows 以平铺顺序排列窗口UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果UpdateWindow 强制立即更新窗口ValidateRect 校验窗口的全部或部分客户区WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口http://blog.csdn.net/jiangxinyu/article/details/1614631]]></content>
  </entry>
</search>
